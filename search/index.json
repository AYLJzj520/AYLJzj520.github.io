[{"content":" “Happy！”\n","date":"2025-03-29T00:00:00Z","permalink":"https://ayljzj520.github.io/p/%E8%AE%B0%E5%BD%95/","title":"记录"},{"content":" “Work！ ”\n1.内容概述 短信登录 这部分会使用Redis共享session来实现 用Redis替换session来存储邮箱验证码 商户查询缓存 这部分要理解缓存击穿，缓存穿透，缓存雪崩等问题，对于这些概念的理解不仅仅是停留在概念上，更是能在代码中看到对应的内容 优惠券秒杀(重中之重) 这部分我们可以学会Redis的计数器功能，结合Lua完成高性能的Redis操作，同时学会Redis分布式锁的原理，包括Redis的三种消息队列 好友关注 基于Set集合的关注、取消关注，共同关注等等功能，这部分在上篇的练习题中出现过，这次我们在项目中来使用一下 达人探店 基于List来完成点赞列表的操作，同时基于SortedSet来完成点赞的排行榜功能 2.短信登录 2.1基于Session实现登录 发送短信验证码 请求网址: http://localhost:8080/api/user/code?phone=15832165478\n请求方法: POST\n调用UserController中的code方法，携带参数是phone 并没有使用真的短信服务，只是随机生成了一个验证码 在UserServiceImpl实现sendCode方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 @Override public Result sendCode(String phone, HttpSession session) { //1、校验手机号格式 if(RegexUtils.isPhoneInvalid(phone)){ //2、如果不符合，返回错误消息 return Result.fail(\u0026#34;手机格式错误\u0026#34;); } //3、符合，生成验证码 String code = RandomUtil.randomNumbers(6); //4、保存验证码至Session session.setAttribute(\u0026#34;code\u0026#34;,code); //5、发送验证码 log.debug(\u0026#34;发送验证码成功，验证码{}\u0026#34;,code); //返回🆗 return Result.ok(); } 2.2短信验证码登录、注册实现登录 请求网址: http://localhost:8080/api/user/login\n请求方法: POST\n在UserServiceImpl实现login方法，逻辑如下\n校验手机号 不正确则返回错误信息 正确则继续校验验证码 不一致则报错 一致则先根据手机号/邮箱查询用户 用户不存在则创建 存在则继续执行程序 保存用户信息到session中（无论之前是否存在都要保存） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 @Override public Result login(LoginFormDTO loginForm, HttpSession session) { //1、校验手机号格式 String phone = loginForm.getPhone(); if(RegexUtils.isPhoneInvalid(phone)){ //2、如果不符合，返回错误消息 return Result.fail(\u0026#34;手机格式错误\u0026#34;); } //2、校验验证码 Object cacheCode= session.getAttribute(\u0026#34;code\u0026#34;); String code = (String) cacheCode; if (cacheCode == null||!cacheCode.equals(code)) { //3、校验不一致，报错 return Result.fail(\u0026#34;验证码错误\u0026#34;); } //4、一致，根据手机号查询用户 User user = query().eq(\u0026#34;phone\u0026#34;, phone).one(); //5、判断用户是否才存在 if (user == null) { //6、不存在，创建用户 user = createUserWithPhone(phone); } //7、保存用户信息到session session.setAttribute(\u0026#34;user\u0026#34;,user); return Result.ok(); } private User createUserWithPhone(String phone) { //1、创建用户 User user = new User(); user.setPhone(phone); user.setNickName(USER_NICK_NAME_PREFIX+RandomUtil.randomString(10)); //2、保存用户 save(user); return null; } 2.3校验登录状态（拦截器） 创建一个LoginInterceptor类，实现HandlerInterceptor接口，重写其中的两个方法，前置拦截器和完成处理方法，前置拦截器主要用于我们登陆之前的权限校验，完成处理方法是用于处理登录后的信息，避免内存泄露 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public class loginInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { //1.获取session HttpSession session = request.getSession(); //2.获取session中的用户 Object user = session.getAttribute(\u0026#34;user\u0026#34;); //3.判断用户是否存在 if (user == null) { //4.不存在，拦截，返回401状态码 response.setStatus(401); return false; } //5.存在，保存用户信息到ThreadLocal UserHolder.saveUser((User) user); //6.放行 return true; } @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { //移除用户 UserHolder.removeUser(); } } 创建MvcConfig 加入拦截器MvcConfig，配置放行路径 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 @Configuration public class MvcConfig implements WebMvcConfigurer { @Override public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(new loginInterceptor()) .excludePathPatterns( \u0026#34;/shop-type/**\u0026#34;, \u0026#34;/shop/**\u0026#34;, \u0026#34;/voucher/**\u0026#34;, \u0026#34;/upload/**\u0026#34;, \u0026#34;/blog/hot\u0026#34;, \u0026#34;/user/code\u0026#34;, \u0026#34;/user/login\u0026#34; ); } } 完善UserController下/me方法 1 2 3 4 5 6 @GetMapping(\u0026#34;/me\u0026#34;) public Result me(){ //获取当前登录的用户并返回 User user = UserHolder.getUser(); return Result.ok(user); } 2.4用户数据脱敏 我们通过浏览器观察到此时用户的全部信息都在，这样极为不靠谱，所以我们应当在返回用户信息之前，将用户的敏感信息进行隐藏，采用的核心思路就是书写一个UserDto对象，这个UserDto对象就没有敏感信息了，我们在返回前，将有用户敏感信息的User对象转化成没有敏感信息的UserDto对象，那么就能够避免这个尴尬的问题了 UserDto类如下，将User对象中的属性拷贝给UserDto，就可以避免暴露用户的隐藏信息 1 2 3 4 5 6 @Data public class UserDTO { private Long id; private String nickName; private String icon; } 修改login方法 1 2 3 4 //7. 保存用户信息到session中 UserDTO userDTO = new UserDTO(); BeanUtils.copyProperties(user,userDTO); session.setAttribute(\u0026#34;user\u0026#34;, userDTO); 修改拦截器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { //1.获取session HttpSession session = request.getSession(); //2.获取session中的用户 UserDTO userDTO = (UserDTO)session.getAttribute(\u0026#34;user\u0026#34;); //3.判断用户是否存在 if (userDTO == null) { //4.不存在，拦截，返回401状态码 response.setStatus(401); return false; } //5.存在，保存用户信息到ThreadLocal log.info(\u0026#34;用户信息：{}\u0026#34;,userDTO); UserHolder.saveUser((UserDTO) userDTO); //6.放行 return true; } 重启服务器，登录后查看此时的用户信息，敏感信息已经不存在了 1 2 3 4 5 6 7 8 { \u0026#34;success\u0026#34;:true, \u0026#34;data\u0026#34;:{ \u0026#34;id\u0026#34;:1016, \u0026#34;nickName\u0026#34;:\u0026#34;user_zkhf7cfv\u0026#34;, \u0026#34;icon\u0026#34;:\u0026#34;\u0026#34; } } 2.5session共享问题 每个tomcat中都有一份属于自己的session,假设用户第一次访问第一台tomcat，并且把自己的信息存放到第一台服务器的session中，但是第二次这个用户访问到了第二台tomcat，那么在第二台服务器上，肯定没有第一台服务器存放的session，所以此时整个登录拦截功能就会出现问题，我们能如何解决这个问题呢？早期的方案是session拷贝，就是说虽然每个tomcat上都有不同的session，但是每当任意一台服务器的session修改时，都会同步给其他的Tomcat服务器的session，这样的话，就可以实现session的共享了 但是这种方案具有两个大问题 每台服务器中都有完整的一份session数据，服务器压力过大。 session拷贝数据时，可能会出现延迟 所以我们后面都是基于Redis来完成，我们把session换成Redis，Redis数据本身就是共享的，就可以避免session共享的问题了 2.6Redis替代session的业务流程 设计key结构 首先我们来思考一下该用什么数据结构来存储数据 由于存入的数据比较简单，我们可以使用String或者Hash 如果使用String，以JSON字符串来保存数据，会额外占用部分空间 如果使用Hash，则它的value中只会存储数据本身 如果不是特别在意内存，直接使用String就好了 设计key的具体细节 我们这里就采用的是简单的K-V键值对方式 但是对于key的处理，不能像session一样用phone或code来当做key 因为Redis的key是共享的，code可能会重复，phone这种敏感字段也不适合存储到Redis中 在设计key的时候，我们需要满足两点 key要有唯一性 key要方便携带 所以我们在后台随机生成一个token，然后让前端带着这个token就能完成我们的业务逻辑了 整体访问流程 当注册完成后，用户去登录，然后校验用户提交的手机号/邮箱和验证码是否一致 如果一致，则根据手机号查询用户信息，不存在则新建，最后将用户数据保存到Redis，并生成一个token作为Redis的key 当我们校验用户是否登录时，回去携带着token进行访问，从Redis中获取token对应的value，判断是否存在这个数据 如果不存在，则拦截 如果存在，则将其用户信息(userDto)保存到threadLocal中，并放行 2.7基于Redis实现短信登录 由于前面已经分析过业务逻辑了，所以这里我们直接开始写代码，在此之前我们要在UserServiceImpl中注入RedisTemplate 1 2 @Autowired private StringRedisTemplate stringRedisTemplate; 修改sendCode方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 @Override public Result sendCode(String phone, HttpSession session) { //1、校验手机号格式 if(RegexUtils.isPhoneInvalid(phone)){ //2、如果不符合，返回错误消息 return Result.fail(\u0026#34;手机格式错误\u0026#34;); } //3、符合，生成验证码 String code = RandomUtil.randomNumbers(6); //4、保存验证码至Redis stringRedisTemplate.opsForValue().set(LOGIN_CODE_KEY+phone,code,LOGIN_CODE_TTL, TimeUnit.MINUTES); //5、发送验证码 log.debug(\u0026#34;发送验证码成功，验证码{}\u0026#34;,code); //返回🆗 return Result.ok(); } 修改Login方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 @Override public Result login(LoginFormDTO loginForm, HttpSession session) { //1、校验手机号格式 String phone = loginForm.getPhone(); if(RegexUtils.isPhoneInvalid(phone)){ //2、如果不符合，返回错误消息 return Result.fail(\u0026#34;手机格式错误\u0026#34;); } //2、从redis中校验验证码 + String cacheCode= stringRedisTemplate.opsForValue().get(LOGIN_CODE_KEY+phone); - // Object cacheCode = session.getAttribute(\u0026#34;code\u0026#34;); String code = loginForm.getCode(); if (cacheCode == null||!cacheCode.equals(code)) { //3、校验不一致，报错 return Result.fail(\u0026#34;验证码错误\u0026#34;); } //4、一致，根据手机号查询用户 User user = query().eq(\u0026#34;phone\u0026#34;, phone).one(); //5、判断用户是否才存在 if (user == null) { //6、不存在，创建用户 user = createUserWithPhone(phone); } + //7、保存用户信息到redis中 + //7.1随机生成token作为登录令牌 + String token = UUID.randomUUID().toString(true); + //7.2将user对象转为HashMap存储 + UserDTO userDTO = BeanUtil.copyProperties(user, UserDTO.class); + Map\u0026lt;String, Object\u0026gt; userMap = BeanUtil.beanToMap(userDTO); + //7.3存储 + String tokenKey= LOGIN_USER_KEY+token; + stringRedisTemplate.opsForHash().putAll(tokenKey,userMap); + //7.4设置token有效期 + stringRedisTemplate.expire(tokenKey,LOGIN_USER_TTL, TimeUnit.MINUTES); + //8.返回token + return Result.ok(token); } 2.8解决状态登录刷新问题 2.8.1初始方案 我们可以通过拦截器拦截到的请求，来证明用户是否在操作，如果用户没有任何操作30分钟，则token会消失，用户需要重新登录 通过查看请求，我们发现我们存的token在请求头里，那么我们就在拦截器里来刷新token的存活时间 修改我们的登陆拦截器LoginInterceptor类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 private StringRedisTemplate stringRedisTemplate; public loginInterceptor(StringRedisTemplate stringRedisTemplate) { this.stringRedisTemplate = stringRedisTemplate; } @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { //1.请求头中的token String token = request.getHeader(\u0026#34;authorization\u0026#34;); if (StrUtil.isEmpty(token)) { //不存在，拦截，返回401状态码 response.setStatus(401); return false; }; //2.基于token获取redis中的用户 String key = RedisConstants.LOGIN_USER_KEY + token; Map\u0026lt;Object, Object\u0026gt; userMap = stringRedisTemplate.opsForHash().entries(key); //3.判断用户是否存在 if (userMap.isEmpty()) { //4.不存在，拦截，返回401状态码 response.setStatus(401); return false; } //5.将查询到的hash数据准尉UserDTO对象 UserDTO userDTO = BeanUtil.fillBeanWithMap(userMap, new UserDTO(), false); //6.存在，保存用户信息到ThreadLocal log.info(\u0026#34;用户信息：{}\u0026#34;,userDTO); UserHolder.saveUser((UserDTO) userDTO); //7.刷新token有效期 stringRedisTemplate.expire(key,RedisConstants.LOGIN_USER_TTL, TimeUnit.MINUTES); //8.放行 return true; } 修改MvcConfig配置类 由于这个loginInterceptor对象是我们手动在WebConfig里创建的，所以这里不能用@AutoWired自动装配，只能声明一个私有的，到了WebConfig里再自动装配 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 @Configuration public class MvcConfig implements WebMvcConfigurer { @Resource private StringRedisTemplate stringRedisTemplate; @Override public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(new loginInterceptor(stringRedisTemplate)) .excludePathPatterns( \u0026#34;/shop-type/**\u0026#34;, \u0026#34;/shop/**\u0026#34;, \u0026#34;/voucher/**\u0026#34;, \u0026#34;/upload/**\u0026#34;, \u0026#34;/blog/hot\u0026#34;, \u0026#34;/user/code\u0026#34;, \u0026#34;/user/login\u0026#34; ); } } 在这个方案中，他确实可以使用对应路径的拦截，同时刷新登录token令牌的存活时间，但是现在这个拦截器他只是拦截需要被拦截的路径，假设当前用户访问了一些不需要拦截的路径，那么这个拦截器就不会生效，所以此时令牌刷新的动作实际上就不会执行，所以这个方案他是存在问题的 2.8.2优化方案 既然之前的拦截器无法对不需要拦截的路径生效，那么我们可以添加一个拦截器，在第一个拦截器中拦截所有的路径，把第二个拦截器做的事情放入到第一个拦截器中，同时刷新令牌，因为第一个拦截器有了threadLocal的数据，所以此时第二个拦截器只需要判断拦截器中的user对象是否存在即可，完成整体刷新功能。 新建一个RefreshTokenInterceptor类，其业务逻辑与之前的LoginInterceptor基本一致，对就算遇到用户未登录，也全部放行，交给LoginInterceptor处理，使其不管访问什么资源都能触发登录刷新 由于这个对象是我们手动在WebConfig里创建的，所以这里不能用@AutoWired自动装配，只能声明一个私有的，到了WebConfig里再自动装配 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 public class RefreshTokenInterceptor implements HandlerInterceptor { @Resource private StringRedisTemplate stringRedisTemplate; public RefreshTokenInterceptor(StringRedisTemplate stringRedisTemplate) { this.stringRedisTemplate = stringRedisTemplate; } @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { //1.请求头中的token String token = request.getHeader(\u0026#34;authorization\u0026#34;); if (StrUtil.isEmpty(token)) { return true; }; //2.基于token获取redis中的用户 String key = RedisConstants.LOGIN_USER_KEY + token; Map\u0026lt;Object, Object\u0026gt; userMap = stringRedisTemplate.opsForHash().entries(key); //3.判断用户是否存在 if (userMap.isEmpty()) { return true; } //5.将查询到的hash数据准尉UserDTO对象 UserDTO userDTO = BeanUtil.fillBeanWithMap(userMap, new UserDTO(), false); //6.存在，保存用户信息到ThreadLocal log.info(\u0026#34;用户信息：{}\u0026#34;,userDTO); UserHolder.saveUser((UserDTO) userDTO); //7.刷新token有效期 stringRedisTemplate.expire(key,RedisConstants.LOGIN_USER_TTL, TimeUnit.SECONDS); //8.放行 return true; } @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { //移除用户 UserHolder.removeUser(); } } 修改我们之前的LoginInterceptor类，只需要判断用户是否存在，不存在，则拦截，存在则放行 1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class loginInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { //1.判断是否需要进行拦截（ThreadLocal中是否有用户） if (UserHolder.getUser() == null) { //没有，需要拦截，设置状态码 response.setStatus(401); //拦截 return false; } //有，则放行 return true; } } 修改WebConfig配置类，拦截器的执行顺序可以由order来指定(值越小，执行优先级越高) 使得拦截器执行逻辑为：先通过全部路径的拦截，触发redis的刷新登录逻辑，然后通过执行资源的逻辑拦截 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class MvcConfig implements WebMvcConfigurer { @Resource private StringRedisTemplate stringRedisTemplate; @Override public void addInterceptors(InterceptorRegistry registry) { //登录拦截器 registry.addInterceptor(new loginInterceptor()) .excludePathPatterns( \u0026#34;/shop-type/**\u0026#34;, \u0026#34;/shop/**\u0026#34;, \u0026#34;/voucher/**\u0026#34;, \u0026#34;/upload/**\u0026#34;, \u0026#34;/blog/hot\u0026#34;, \u0026#34;/user/code\u0026#34;, \u0026#34;/user/login\u0026#34; ).order(1); //token刷新拦截器（先执行） registry.addInterceptor(new RefreshTokenInterceptor(stringRedisTemplate)).addPathPatterns(\u0026#34;/**\u0026#34;).order(0); //.order(0)值越小越先执行 } } 2.9退出登录（补充） 这部分功能黑马的课程里没有实现 由于后期需要切换不同用户账户来测试功能 ，为了方便切换账户，我在这对这部分功能就行补充。 1 2 3 4 5 @PostMapping(\u0026#34;/logout\u0026#34;) public Result logout(){ // TODO 实现登出功能 return Result.fail(\u0026#34;功能未完成\u0026#34;); } 用户点击退出登录，我们需要清除ThreadLocal里存放的用户信息，这样前端发送的请求获取不到用户信息，登录拦截器从ThreadLocal中获取用户也为null，被拦截跳到登录界面。 还有一个问题 我们原来的token数据还没清除（redis中），那是否需要清除Redis中的token数据，这取决于你的系统设计和安全需求 ,下面是自己的一些考虑 安全性：如果用户已经退出登录，那么与之相关的token就不再有效。为了防止潜在的滥用（例如，攻击者尝试使用旧的token进行请求），从Redis中删除这些token是一个好的做法。 资源管理：Redis是一个内存数据库，存储的数据会占用内存空间。如果长时间保留不再使用的token，可能会导致内存资源的浪费。因此，从资源管理的角度来看，删除旧的token也是有益的 具体实现 1 2 3 4 5 6 7 8 9 10 11 12 /** * 登出功能 * @return 无 */ @PostMapping(\u0026#34;/logout\u0026#34;) public Result logout(HttpServletRequest request){ //先获取当前用户token String token = request.getHeader(\u0026#34;Authorization\u0026#34;); userService.logout(token); UserHolder.removeUser(); return Result.ok(); } 1 2 3 4 5 @Override public void logout(String token) { String tokenKey = LOGIN_USER_KEY + token; stringRedisTemplate.delete(tokenKey); } 3.商户查询缓存 3.1什么是缓存 什么是缓存？ 缓存就像自行车、越野车的避震器 举个例子 越野车、山地自行车都有避震器，防止车体加速之后因惯性，在U型地形上飞跃硬着陆导致损坏，像个弹簧意义 同样，在实际开发中，系统也需要避震器，防止过高的数据量猛冲系统，导致其操作线程无法及时处理信息而瘫痪 在实际开发中，对企业来讲，产品口碑、用户评价都是致命的，所以企业非常重视缓存技术 缓存(Cache)就是数据交换的缓冲区，俗称的缓存就是缓冲区内的数据，一般从数据库中获取，存储于本地 由于其被static修饰，所以随着类的加载而加载到内存之中，作为本地缓存，由于其又被final修饰，所以其引用之间的关系是固定的，不能改变，因此不用担心复制导致缓存失败 3.1.1为什么要使用缓存 言简意赅：速度快，好用 缓存数据存储于代码中，而代码运行在内存中，内存的读写性能远高于磁盘，缓存可以大大降低用户访问并发量带来的服务器读写压力 实际开发中，企业的数据量，少则几十万，多则几千万，这么大的数据量，如果没有缓存来作为避震器系统是几乎撑不住的，所以企业会大量运用缓存技术 但是缓存也会增加代码复杂度和运营成本 缓存的作用 1.降低后端负载 2.提高读写效率，降低响应时间 缓存的成本 1.数据一致性成本 2.代码维护成本 3.运维成本（一般采用服务器集群，需要多加机器，机器就是钱） 3.1.2如何使用缓存 实际开发中，会构筑多级缓存来时系统运行速度进一步提升，例如：本地缓存与Redis中的缓存并发使用 浏览器缓存：主要是存在于浏览器端的缓存 应用层缓存：可以分为tomcat本地缓存，例如之前提到的map或者是使用Redis作为缓存 数据库缓存：在数据库中有一片空间是buffer pool，增改查数据都会先加载到mysql的缓存中 CPU缓存：当代计算机最大的问题就是CPU性能提升了，但是内存读写速度没有跟上，所以为了适应当下的情况，增加了CPU的L1，L2，L3级的缓存 3.2添加商户缓存 3.2.1缓存模型与思路 我们先启动前端和后端的项目，登陆之后随便访问一个商户，查看浏览器发送的请求 请求网址: http://localhost:8080/api/shop/10\n请求方法: GET\n在我们查询商户信息时，我们是直接操作从数据库中去进行查询的，大致逻辑是这样，直接查询数据库肯定慢 所以我们可以在客户端与数据库之间加上一个Redis缓存，先从Redis中查询，如果没有查到，再去MySQL中查询，同时查询完毕之后，将查询到的数据也存入Redis，这样当下一个用户来进行查询的时候，就可以直接从Redis中获取到数据 3.2.2代码实现 代码思路：如果Redis缓存里有数据，那么直接返回，如果缓存中没有，则去查询数据库，然后存入Redis 1 2 3 4 5 6 7 8 9 /** * 根据id查询商铺信息 * @param id 商铺id * @return 商铺详情数据 */ @GetMapping(\u0026#34;/{id}\u0026#34;) public Result queryShopById(@PathVariable(\u0026#34;id\u0026#34;) Long id) { return shopService.queryById(id); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 @Service public class ShopServiceImpl extends ServiceImpl\u0026lt;ShopMapper, Shop\u0026gt; implements IShopService { @Resource private RedisTemplate redisTemplate; @Autowired private StringRedisTemplate stringRedisTemplate; @Override public Result queryById(Long id) { String key = CACHE_SHOP_KEY + id; //1.从redis查询商户缓存,这里的常量值是固定的前缀 + 店铺id String shopJson = stringRedisTemplate.opsForValue().get(key); //2.判断是否存在 if (StrUtil.isNotBlank(shopJson)) { //3.存在，则转为Shop类型直接返回 Shop shop = JSONUtil.toBean(shopJson, Shop.class); return Result.ok(shop); } //4.不存在，根据id查询数据库 Shop shop = getById(id); //5.数据库不存在，返回错误或者返回空都可以 if (shop == null) { return Result.fail(\u0026#34;店铺不存在\u0026#34;); } //6.查到了，将数据转为json字符串写入redis stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(shop)); //7.最终把查询到的商户信息返回给前端 return Result.ok(shop); } } 3.2.3趁热打铁实现商户类型缓存 Controller逻辑的实现：\n1 2 3 4 @GetMapping(\u0026#34;list\u0026#34;) public Result queryTypeList() { return typeService.queryList(); } queryList()方法的实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 @Autowired private StringRedisTemplate stringRedisTemplate; @Override public Result queryList() { // 整体代码都是类似的，前面只需要将单个店铺信息从JSON和Bean之间相互转换 // 这里只不过是将查询到的多个店铺类型信息从JSON和Bean之间相互转换，只是多了一个foreach循环 //先从Redis中查，这里的常量值是固定前缀 + 店铺id List\u0026lt;String\u0026gt; shopTypes = stringRedisTemplate.opsForList().range(CACHE_SHOP_TYPE_KEY, 0, -1); //如果不为空（查询到了），则转为ShopType类型直接返回 if(!shopTypes.isEmpty()){ List\u0026lt;ShopType\u0026gt; arr = new ArrayList\u0026lt;\u0026gt;(); for(String type : shopTypes){ ShopType shopType = JSONUtil.toBean(type, ShopType.class); arr.add(shopType); } return Result.ok(arr); } //否则去数据库中查 List\u0026lt;ShopType\u0026gt; tmp = query().orderByAsc(\u0026#34;sort\u0026#34;).list(); if(tmp.isEmpty()){ return Result.fail(\u0026#34;店铺类型不存在！\u0026#34;); } //查到了转为json字符串，存入redis for (ShopType shopType : tmp) { String jsonStr = JSONUtil.toJsonStr(shopType); shopTypes.add(jsonStr); } stringRedisTemplate.opsForList().leftPushAll(CACHE_SHOP_TYPE_KEY,shopTypes); //最终把查询到的商户分类信息返回给前端 return Result.ok(tmp); } 3.3缓存更新策略 缓存更新是Redis为了节约内存而设计出来的一个东西，主要是因为内存数据宝贵，当我们想Redis插入太多数据，此时就可能会导致缓存中数据过多，所以Redis会对部分数据进行更新，或者把它成为淘汰更合适 内存淘汰：Redis自动进行，当Redis内存大道我们设定的max-memery时，会自动触发淘汰机制，淘汰掉一些不重要的数据（可以自己设置策略方式） 超时剔除：当我们给Redis设置了过期时间TTL之后，Redis会将超时的数据进行删除，方便我们继续使用缓存 主动更新：我们可以手动调用方法把缓存删除掉，通常用于解决缓存和数据库不一致问题 说明 内存淘汰 超时剔除 主动更新 介绍 不用自己维护， 利用Redis的内存淘汰机制，当内存不足时自动淘汰部分数据。 下次查询时更新缓存。 给缓存数据添加TTL时间，到期后自动删除缓存。下次查询时更新缓存。 编写业务逻辑，在修改数据库的同时，更新缓存。 一致性 差 一般 好 维护成本 无 低 高 业务场景 低一致性需求：使用内存淘汰机制，例如店铺类型的查询缓存（因为这个很长一段时间都不需要更新） 高一致性需求：主动更新，并以超时剔除作为兜底方案，例如店铺详情查询的缓存 3.3.1数据库和缓存不一致解决方案 由于我们的缓存数据源来自数据库，而数据库的数据是会发生变化的，因此，如果当数据库中数据发生变化，而缓存却没有同步，此时就会有一致性问题存在，其后果是 用户使用缓存中的过时数据，就会产生类似多线程数据安全问题，从而影响业务，产品口碑等 那么如何解决这个问题呢？有如下三种方式 1.Cache Aside Pattern 人工编码方式：缓存调用者在更新完数据库之后再去更新缓存，也称之为双写方案 2.Read/Write Through Pattern：缓存与数据库整合为一个服务，由服务来维护一致性。调用者调用该服务，无需关心缓存一致性问题。但是维护这样一个服务很复杂，市面上也不容易找到这样的一个现成的服务，开发成本高 3.Write Behind Caching Pattern：调用者只操作缓存，其他线程去异步处理数据库，最终实现一致性。但是维护这样的一个异步的任务很复杂，需要实时监控缓存中的数据更新，其他线程去异步更新数据库也可能不太及时，而且缓存服务器如果宕机，那么缓存的数据也就丢失了 3.3.2数据库和缓存不一致采用什么方案 综上所述，在企业的实际应用中，还是方案一最可靠，但是方案一的调用者该如何处理呢？ 如果采用方案一，假设我们每次操作完数据库之后，都去更新一下缓存，但是如果中间并没有人查询数据，那么这个更新动作只有最后一次是有效的，中间的更新动作意义不大，所以我们可以把缓存直接删除，等到有人再次查询时，再将缓存中的数据加载出来 对比删除缓存与更新缓存 更新缓存：每次更新数据库都需要更新缓存，无效写操作较多 删除缓存：更新数据库时让缓存失效，再次查询时更新缓存 如何保证缓存与数据库的操作同时成功/同时失败 (原子性) 单体系统：将缓存与数据库操作放在同一个事务 分布式系统：利用TCC等分布式事务方案 先操作缓存还是先操作数据库？我们来仔细分析一下这两种方式的线程安全问题 先删除缓存，再操作数据库 异常情况：删除缓存的操作很快，但是更新数据库的操作相对较慢，如果此时有一个线程2刚好进来查询缓存，由于我们刚刚才删除缓存，所以线程2需要查询数据库，并写入缓存，但是我们更新数据库的操作还未完成，所以线程2查询到的数据是脏数据，出现线程安全问题 先操作数据库，再删除缓存 异常情况：线程1在查询缓存的时候，缓存TTL刚好失效，需要查询数据库并写入缓存，这个操作耗时相对较短（相比较于上图来说），但是就在这么短的时间内，线程2进来了，更新数据库，删除缓存，但是线程1虽然查询完了数据（更新前的旧数据），但是还没来得及写入缓存，所以线程2的更新数据库与删除缓存，并没有影响到线程1的查询旧数据，写入缓存，造成线程安全问题 虽然这二者都存在线程安全问题，但是相对来说，后者出现线程安全问题的概率相对较低，所以我们最终采用后者先操作数据库，再删除缓存的方案 3.4实现商铺缓存与数据库双写一致 核心思路如下 修改ShopController中的业务逻辑，满足以下要求 1.根据id查询店铺时，如果缓存未命中，则查询数据库，并将数据库结果写入缓存，并设置TTL 2.根据id修改店铺时，先修改数据库，再删除缓存 修改ShopService的queryById方法，写入缓存时设置一下TTL 1 stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(shop),CACHE_SHOP_TTL, TimeUnit.MINUTES); 修改update方法\n1 2 3 4 5 6 7 8 9 10 /** * 更新商铺信息 * @param shop 商铺数据 * @return 无 */ @PutMapping public Result updateShop(@RequestBody Shop shop) { // 写入数据库 return shopService.update(shop); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 @Override @Transactional public Result update(Shop shop) { Long id =shop.getId(); if (id == null) { return Result.fail(\u0026#34;店铺id不能为空\u0026#34;); } String key = CACHE_SHOP_KEY + id; //1.更新数据库 updateById(shop); //2.删除缓存 stringRedisTemplate.delete(key); return Result.ok(); } 测试 修改完毕之后我们重启服务器进行测试，首先随便挑一个顺眼的数据，我这里就是拿餐厅数据做测试，，我们先访问该餐厅，将该餐厅的数据缓存到Redis中，之后使用POSTMAN发送PUT请求，请求路径http://localhost:8081/api/shop/ ，携带JSON数据如下 1 2 3 4 5 6 7 8 9 10 11 12 { \u0026#34;area\u0026#34;: \u0026#34;大关\u0026#34;, \u0026#34;openHours\u0026#34;: \u0026#34;10:00-22:00\u0026#34;, \u0026#34;sold\u0026#34;: 4215, \u0026#34;address\u0026#34;: \u0026#34;金华路锦昌文华苑29号\u0026#34;, \u0026#34;comments\u0026#34;: 3035, \u0026#34;avgPrice\u0026#34;: 80, \u0026#34;score\u0026#34;: 37, \u0026#34;name\u0026#34;: \u0026#34;476茶餐厅\u0026#34;, \u0026#34;typeId\u0026#34;: 1, \u0026#34;id\u0026#34;: 1 } 之后再Redis图形化页面刷新数据，发现该餐厅的数据确实不在Redis中了，之后我们刷新网页，餐厅名会被改为476茶餐厅，然后我们再去Redis中刷新，发现新数据已经被缓存了 那么现在功能就实现完毕了，只有当我们刷新页面的时候，才会重新查询数据库，并将数据缓存到Redis，中途无论修改多少次，只要不刷新页面访问，Redis中都不会更新数据 3.5缓存穿透问题的解决思路 缓存穿透：缓存穿透是指客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远都不会生效（只有数据库查到了，才会让redis缓存，但现在的问题是查不到），会频繁的去访问数据库。 常见的结局方案有两种 缓存空对象 优点：实现简单，维护方便 缺点：额外的内存消耗，可能造成短期的不一致 布隆过滤 优点：内存占用少，没有多余的key 缺点：实现复杂，可能存在误判 缓存空对象思路分析： 当我们客户端访问不存在的数据时，会先请求redis，但是此时redis中也没有数据，就会直接访问数据库，但是数据库里也没有数据，那么这个数据就穿透了缓存，直击数据库。但是数据库能承载的并发不如redis这么高，所以如果大量的请求同时都来访问这个不存在的数据，那么这些请求就会访问到数据库，简单的解决方案就是哪怕这个数据在数据库里不存在，我们也把这个这个数据存在redis中去（这就是为啥说会有额外的内存消耗），这样下次用户过来访问这个不存在的数据时，redis缓存中也能找到这个数据，不用去查数据库。可能造成的短期不一致是指在空对象的存活期间，我们更新了数据库，把这个空对象变成了正常的可以访问的数据，但由于空对象的TTL还没过，所以当用户来查询的时候，查询到的还是空对象，等TTL过了之后，才能访问到正确的数据，不过这种情况很少见罢了 布隆过滤思路分析： 布隆过滤器其实采用的是哈希思想来解决这个问题，通过一个庞大的二进制数组，根据哈希思想去判断当前这个要查询的数据是否存在，如果布隆过滤器判断存在，则放行，这个请求会去访问redis，哪怕此时redis中的数据过期了，但是数据库里一定会存在这个数据，从数据库中查询到数据之后，再将其放到redis中。如果布隆过滤器判断这个数据不存在，则直接返回。这种思想的优点在于节约内存空间，但存在误判，误判的原因在于：布隆过滤器使用的是哈希思想，只要是哈希思想，都可能存在哈希冲突。 3.6编码解决商品查询的缓存穿透问题 缓存空对象方法 核心思路如下: 在原来的逻辑中，我们如果发现这个数据在MySQL中不存在，就直接返回一个错误信息了，但是这样存在缓存穿透问题 现在的逻辑是：如果这个数据不存在，将这个数据写入到Redis中，并且将value设置为空字符串，然后设置一个较短的TTL，返回错误信息。当再次发起查询时，先去Redis中判断value是否为空字符串，如果是空字符串，则说明是刚刚我们存的不存在的数据，直接返回错误信息 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 @Override public Result queryById(Long id) { String key = CACHE_SHOP_KEY + id; //1.从redis查询商户缓存,这里的常量值是固定的前缀 + 店铺id String shopJson = stringRedisTemplate.opsForValue().get(key); //2.判断是否存在 if (StrUtil.isNotBlank(shopJson)) { //3.存在，则转为Shop类型直接返回 Shop shop = JSONUtil.toBean(shopJson, Shop.class); return Result.ok(shop); } //判断命中是否是空值 if(shopJson != null){ ////返回错误信息 return Result.fail(\u0026#34;店铺不存在\u0026#34;); } //4.不存在，根据id查询数据库 Shop shop = getById(id); //5.数据库不存在，返回错误或者返回空都可以 if (shop == null) { //将控制写入redis stringRedisTemplate.opsForValue().set(key, \u0026#34;\u0026#34;,CACHE_NULL_TTL, TimeUnit.MINUTES); //返回错误信息 return Result.fail(\u0026#34;店铺不存在\u0026#34;); } //6.查到了，将数据转为json字符串写入redis stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(shop),CACHE_SHOP_TTL, TimeUnit.MINUTES); //7.最终把查询到的商户信息返回给前端 return Result.ok(shop); } 小结： 缓存穿透产生的原因是什么？ 用户请求的数据在缓存中和在数据库中都不存在，不断发起这样的请求，会给数据库带来巨大压力 缓存穿透的解决方案有哪些？ 缓存null值 布隆过滤 增强id复杂度，避免被猜测id规律（可以采用雪花算法） 做好数据的基础格式校验 加强用户权限校验 做好热点参数的限流 3.7缓存雪崩问题及解决思路 缓存雪崩是指在同一时间段，大量缓存的key同时失效，或者Redis服务宕机，导致大量请求到达数据库，带来巨大压力 解决方案 给不同的Key的TTL添加随机值，让其在不同时间段分批失效 利用Redis集群提高服务的可用性（使用一个或者多个哨兵(Sentinel)实例组成的系统，对redis节点进行监控，在主节点出现故障的情况下，能将从节点中的一个升级为主节点，进行故障转义，保证系统的可用性。 ） 给缓存业务添加降级限流策略 给业务添加多级缓存（浏览器访问静态资源时，优先读取浏览器本地缓存；访问非静态资源（ajax查询数据）时，访问服务端；请求到达Nginx后，优先读取Nginx本地缓存；如果Nginx本地缓存未命中，则去直接查询Redis（不经过Tomcat）；如果Redis查询未命中，则查询Tomcat；请求进入Tomcat后，优先查询JVM进程缓存；如果JVM进程缓存未命中，则查询数据库） 3.8缓存击穿问题及解决思路 缓存击穿也叫热点Key问题，就是一个被高并发访问并且缓存重建业务较复杂的key突然失效了，那么无数请求访问就会在瞬间给数据库带来巨大的冲击 举个不太恰当的例子：一件秒杀中的商品的key突然失效了，大家都在疯狂抢购，那么这个瞬间就会有无数的请求访问去直接抵达数据库，从而造成缓存击穿 常见的解决方案有两种 1.互斥锁 2.逻辑过期 逻辑分析：假设线程1在查询缓存之后未命中，本来应该去查询数据库，重建缓存数据，完成这些之后，其他线程也就能从缓存中加载这些数据了。但是在线程1还未执行完毕时，又进来了线程2、3、4同时来访问当前方法，那么这些线程都不能从缓存中查询到数据，那么他们就会在同一时刻访问数据库，执行SQL语句查询，对数据库访问压力过大 解决方案一：互斥锁 利用锁的互斥性，假设线程过来，只能一个人一个人的访问数据库，从而避免对数据库频繁访问产生过大压力，但这也会影响查询的性能，将查询的性能从并行变成了串行，我们可以采用tryLock方法+double check来解决这个问题 线程1在操作的时候，拿着锁把房门锁上了，那么线程2、3、4就不能都进来操作数据库，只有1操作完了，把房门打开了，此时缓存数据也重建好了，线程2、3、4直接从redis中就可以查询到数据。 解决方案二：逻辑过期方案 方案分析：我们之所以会出现缓存击穿问题，主要原因是在于我们对key设置了TTL，如果我们不设置TTL，那么就不会有缓存击穿问题，但是不设置TTL，数据又会一直占用我们的内存，所以我们可以采用逻辑过期方案 我们之前是TTL设置在redis的value中，注意：这个过期时间并不会直接作用于Redis，而是我们后续通过逻辑去处理。假设线程1去查询缓存，然后从value中判断当前数据已经过期了，此时线程1去获得互斥锁，那么其他线程会进行阻塞，获得了锁的进程他会开启一个新线程去进行之前的重建缓存数据的逻辑，直到新开的线程完成者逻辑之后，才会释放锁，而线程1直接进行返回，假设现在线程3过来访问，由于线程2拿着锁，所以线程3无法获得锁，线程3也直接返回数据（但只能返回旧数据，牺牲了数据一致性，换取性能上的提高），只有等待线程2重建缓存数据之后，其他线程才能返回正确的数据 这种方案巧妙在于，异步构建缓存数据，缺点是在重建完缓存数据之前，返回的都是脏数据 3.8.1利用互斥锁解决缓存击穿问题 核心思路：相较于原来从缓存中查询不到数据后直接查询数据库而言，现在的方案是，进行查询之后，如果没有从缓存中查询到数据，则进行互斥锁的获取，获取互斥锁之后，判断是否获取到了锁，如果没获取到，则休眠一段时间，过一会儿再去尝试，直到获取到锁为止，才能进行查询 如果获取到了锁的线程，则进行查询，将查询到的数据写入Redis，再释放锁，返回数据，利用互斥锁就能保证只有一个线程去执行数据库的逻辑，防止缓存击穿 操作锁的代码 核心思路就是利用redis的setnx方法来表示获取锁，如果redis没有这个key，则插入成功，返回1，如果已经存在这个key，则插入失败，返回0。在StringRedisTemplate中返回true/false，我们可以根据返回值来判断是否有线程成功获取到了锁 在shopServiceImpl里定义两个方法 3.8.2利用互斥锁解决缓存击穿问题 在shopServiceImpl里定义加锁和删除锁的方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 /** * 获取锁 * @param key * @return */ private boolean tryLock(String key){ Boolean flag = stringRedisTemplate.opsForValue().setIfAbsent(key, \u0026#34;1\u0026#34;, 10, TimeUnit.SECONDS); return BooleanUtil.isTrue(flag); } /** * 删除锁 * @param key */ private void unLock(String key){ stringRedisTemplate.delete(key); } 然后这里先把我们之前写的缓存穿透代码修改一下，提取成一个独立的方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 /** * 缓存穿透代码封装 * @param id * @return */ public Shop queryWithPassThrough(Long id) { String key = CACHE_SHOP_KEY + id; //1.从redis查询商户缓存,这里的常量值是固定的前缀 + 店铺id String shopJson = stringRedisTemplate.opsForValue().get(key); //2.判断是否存在 if (StrUtil.isNotBlank(shopJson)) { //3.存在，则转为Shop类型直接返回 return JSONUtil.toBean(shopJson, Shop.class); } //判断命中是否是空值 if(shopJson != null){ ////返回错误信息 return null; } //4.不存在，根据id查询数据库 Shop shop = getById(id); //5.数据库不存在，返回错误或者返回空都可以 if (shop == null) { //将控制写入redis stringRedisTemplate.opsForValue().set(key, \u0026#34;\u0026#34;,CACHE_NULL_TTL, TimeUnit.MINUTES); //返回错误信息 return null; } //6.查到了，将数据转为json字符串写入redis stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(shop),CACHE_SHOP_TTL, TimeUnit.MINUTES); //7.最终把查询到的商户信息返回给前端 return shop; } 缓存穿透代码上修改实现互斥锁解决缓存击穿代码封装 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 /** * 互斥锁解决缓存击穿代码封装 * @param id * @return */ public Shop queryWithMutex(Long id) { String key = CACHE_SHOP_KEY + id; //1.从redis查询商户缓存,这里的常量值是固定的前缀 + 店铺id String shopJson = stringRedisTemplate.opsForValue().get(key); //2.判断是否存在 if (StrUtil.isNotBlank(shopJson)) { //3.存在，则转为Shop类型直接返回 return JSONUtil.toBean(shopJson, Shop.class); } //判断命中是否是空值 if(shopJson != null){ ////返回错误信息 return null; } //4.实现缓存重建 //4.1获取互斥锁 String lockKey = LOCK_SHOP_KEY+id; Shop shop = null; try { boolean isLock = tryLock(lockKey); //4.2判断是否成功 if(!isLock){ //4.3失败，休眠后重试 Thread.sleep(50); return queryWithMutex(id); } //4.4成功，根据id查询数据库 shop = getById(id); // //模拟重建时间 // Thread.sleep(200); //5.数据库不存在，返回错误或者返回空都可以 if (shop == null) { //将控制写入redis stringRedisTemplate.opsForValue().set(key, \u0026#34;\u0026#34;,CACHE_NULL_TTL, TimeUnit.MINUTES); //返回错误信息 return null; } //6.查到了，将数据转为json字符串写入redis stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(shop),CACHE_SHOP_TTL, TimeUnit.MINUTES); } catch (InterruptedException e) { throw new RuntimeException(e); }finally { //7.释放互斥锁 unLock(lockKey); } //8.最终把查询到的商户信息返回给前端 return shop; } 再调用封装好的缓存击穿代码 1 2 3 4 5 6 7 8 9 10 11 @Override public Result queryById(Long id) { //缓存穿透 //Shop shop = queryWithPassThrough(id); //互斥锁解决缓存击穿 Shop shop = queryWithMutex(id); if (shop == null) { return Result.fail(\u0026#34;店铺不存在\u0026#34;); } return Result.ok(shop); } 测试（使用Jmeter进行压测） 我们先来模拟一下缓存击穿的情景，缓存击穿是指在某时刻，一个热点数据的TTL到期了，此时用户不能从Redis中获取热点商品数据，然后就都得去数据库里查询，造成数据库压力过大。 那么我们首先将Redis中的热点商品数据删除，模拟TTL到期，然后用Jmeter进行压力测试，开100个线程来访问这个没有缓存的热点数据 3.8.3利用逻辑过期解决缓存击穿问题 需求：根据id查询商铺的业务，基于逻辑过期方式来解决缓存击穿问题 思路分析：当用户开始查询redis时，判断是否命中 如果没有命中则直接返回空数据，不查询数据库 如果命中，则将value取出，判断value中的过期时间是否满足 如果没有过期，则直接返回redis中的数据 如果过期，则在开启独立线程后，直接返回之前的数据，独立线程去重构数据，重构完成后再释放互斥锁 封装数据：因为现在redis中存储的数据的value需要带上过期时间，此时要么你去修改原来的实体类，要么新建一个类包含原有的数据和过期时间 步骤一：这里我们选择新建一个实体类，包含原有数据(用万能的Object)和过期时间，这样对原有的代码没有侵入性 1 2 3 4 5 @Data public class RedisData { private LocalDateTime expireTime; private Object data; } 步骤二:在ShopServiceImpl中新增方法，进行单元测试，看看能否写入数据 1 2 3 4 5 6 7 8 9 10 public void saveShop2Redis(Long id,Long expireSeconds){ //1.查询店铺信息 Shop shop = getById(id); //2.封装逻辑过期时间 RedisData redisData = new RedisData(); redisData.setData(shop); redisData.setExpireTime(LocalDateTime.now().plusSeconds(expireSeconds)); //3.写入redis stringRedisTemplate.opsForValue().set(CACHE_SHOP_KEY+id,JSONUtil.toJsonStr(redisData)); } 编写测试方法 运行测试方法，去Redis图形化页面看到存入的value，确实包含了data和expireTime1 步骤三：正式代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 //这里需要声明一个线程池，因为下面我们需要新建一个现成来完成重构缓存 private static final ExecutorService CACHE_REBILD_EXECUTOR = Executors.newFixedThreadPool(10); /** * 逻辑过期解决缓存击穿 * @param id * @return */ public Shop queryWithLogicalExpire(Long id) { String key = CACHE_SHOP_KEY + id; //1.从redis查询商户缓存,这里的常量值是固定的前缀 + 店铺id String shopJson = stringRedisTemplate.opsForValue().get(key); //2.判断是否存在 if (StrUtil.isBlank(shopJson)) { //3.未命中，则返回 return null; } //4.命中，需要先把jeon反序列化为对象 RedisData redisData = JSONUtil.toBean(shopJson, RedisData.class); Shop shop = JSONUtil.toBean((JSONObject)redisData.getData(), Shop.class); LocalDateTime expireTime = redisData.getExpireTime(); //5.判断是否过期 if (expireTime.isBefore(LocalDateTime.now())) { //5.1未过期，直接返回店铺信息 return shop; } //5.1已过期，需要缓存重建 //6.缓存重建 //6.1获取互斥锁 String lockKey = LOCK_SHOP_KEY+id; boolean isLock = tryLock(lockKey); //6.2判断是否获取互斥锁成功 if(isLock){ //6.3成功，开启独立线程，实现缓存重建 CACHE_REBILD_EXECUTOR.submit(() -\u0026gt; { try { //重建缓存 this.saveShop2Redis(id,30L); } catch (Exception e) { throw new RuntimeException(e); } finally { //释放锁 unLock(lockKey); } }); } //6.4失败，返回过期的商铺信息 return shop; } 使用Jmeter进行测试 先来复现一遍场景，当某个用户去Redis中访问缓存的数据时，发现该数据已经过期了，于是新开一个线程去重构缓存数据，但在重构完成之前，用户得到的数据都是脏数据，重构完成之后，才是新数据 之后去数据库把这个数据修改一下，这样逻辑过期前和逻辑过期后的数据就不一致，当用户来访问数据的时候，需要花时间来进行重构缓存数据，但是在重构完成之前，都只能获得脏数据（也就是我们修改前的数据），只有当重构完毕之后，才能获得新数据（我们修改后的数据） 测试结果如下，同样是开了100个线程去访问逻辑过期数据，前面的用户只能看到脏数据，后面的用户看到的才是新数据 3.9封装Redis工具类 基于StringRedisTemplate封装一个缓存工具类，需满足下列要求 方法1：将任意Java对象序列化为JSON，并存储到String类型的Key中，并可以设置TTL过期时间 1 2 3 4 5 6 7 8 9 10 /** * 将任意Java对象序列化为JSON，并存储到String类型的Key中，并可以设置TTL过期时间 * @param key * @param value * @param time * @param timeUnit */ public void set(String key, Object value, Long time, TimeUnit timeUnit) { stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(value),time,timeUnit); } 方法2：将任意Java对象序列化为JSON，并存储在String类型的Key中，并可以设置逻辑过期时间，用于处理缓存击穿问题 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 /** * 将任意Java对象序列化为JSON，并存储在String类型的Key中，并可以设置逻辑过期时间，用于处理缓存击穿问题 * @param key * @param value * @param time * @param timeUnit */ public void setWithLogicalExpire(String key, Object value, Long time, TimeUnit timeUnit) { //设置逻辑过期 RedisData redisData = new RedisData(); redisData.setData(value); redisData.setExpireTime(LocalDateTime.now().plusSeconds(timeUnit.toSeconds(time))); //写入redis stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(redisData)); } 方法3：根据指定的Key查询缓存，并反序列化为指定类型，利用缓存空值的方式解决缓存穿透问题 改为通用方法，那么返回值就需要进行修改，不能返回Shop了，那我们直接设置一个泛型，同时ID的类型，也不一定都是Long类型，所以我们也采用泛型。 Key的前缀也会随着业务需求的不同而修改，所以参数列表里还需要加入Key的前缀 通过id去数据库查询的具体业务需求我们也不清楚，所以我们也要在参数列表中加入一个查询数据库逻辑的函数 最后再加上设置TTL需要的两个参数 那么综上所述，我们的参数列表需要 key前缀 id（类型泛型） 返回值类型（泛型） 查询的函数 TTL需要的两个参数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 /** * 缓存穿透代码封装 * @param id * @return */ public \u0026lt;R,ID\u0026gt; R queryWithPassThrough(String keyPrefix, ID id, Class\u0026lt;R\u0026gt; type, Function\u0026lt;ID,R\u0026gt; dbFallback,Long time, TimeUnit timeUnit) { String key = keyPrefix + id; //1.从redis查询商户缓存,这里的常量值是固定的前缀 + 店铺id String json = stringRedisTemplate.opsForValue().get(key); //2.判断是否存在 if (StrUtil.isNotBlank(json)) { //3.存在，则转为Shop类型直接返回 return JSONUtil.toBean(json, type); } //判断命中是否是空值 if(json != null){ ////返回错误信息 return null; } //4.不存在，根据id查询数据库 R r = dbFallback.apply(id); //5.数据库不存在，返回错误或者返回空都可以 if (r == null) { //将控制写入redis stringRedisTemplate.opsForValue().set(key, \u0026#34;\u0026#34;,CACHE_NULL_TTL, TimeUnit.MINUTES); //返回错误信息 return null; } //6.查到了，将数据转为json字符串写入redis this.set(key, r, time, timeUnit); //7.最终把查询到的商户信息返回给前端 return r; } 方法4：根据指定的Key查询缓存，并反序列化为指定类型，需要利用逻辑过期解决缓存击穿问题 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 /** * 逻辑过期解决缓存击穿 * @param id * @return */ public \u0026lt;R,ID\u0026gt; R queryWithLogicalExpire(String keyPrefix,ID id,Class\u0026lt;R\u0026gt; type,Function\u0026lt;ID,R\u0026gt; dbFallback,Long time, TimeUnit timeUnit) { String key = keyPrefix + id; //1.从redis查询商户缓存,这里的常量值是固定的前缀 + 店铺id String shopJson = stringRedisTemplate.opsForValue().get(key); //2.判断是否存在 if (StrUtil.isBlank(shopJson)) { //3.未命中，则返回 return null; } //4.命中，需要先把jeon反序列化为对象 RedisData redisData = JSONUtil.toBean(shopJson, RedisData.class); R r = JSONUtil.toBean((JSONObject)redisData.getData(), type); LocalDateTime expireTime = redisData.getExpireTime(); //5.判断是否过期 if (expireTime.isBefore(LocalDateTime.now())) { //5.1未过期，直接返回店铺信息 return r; } //5.1已过期，需要缓存重建 //6.缓存重建 //6.1获取互斥锁 String lockKey = LOCK_SHOP_KEY+id; boolean isLock = tryLock(lockKey); //6.2判断是否获取互斥锁成功 if(isLock){ //6.3成功，开启独立线程，实现缓存重建 CACHE_REBILD_EXECUTOR.submit(() -\u0026gt; { try { //查数据库 R r1 = dbFallback.apply(id); //重建缓存 this.setWithLogicalExpire(key,r1,time,timeUnit); } catch (Exception e) { throw new RuntimeException(e); } finally { //释放锁 unLock(lockKey); } }); } //6.4失败，返回过期的商铺信息 return r; } /** * 获取锁 * @param key * @return */ private boolean tryLock(String key){ Boolean flag = stringRedisTemplate.opsForValue().setIfAbsent(key, \u0026#34;1\u0026#34;, 10, TimeUnit.SECONDS); return BooleanUtil.isTrue(flag); } /** * 删除锁 * @param key */ private void unLock(String key){ stringRedisTemplate.delete(key); } 4.优惠券秒杀 4.1Redis实现全局唯一ID 在各类购物App中，都会遇到商家发放的优惠券 当用户抢购商品时，生成的订单会保存到tb_voucher_order表中，而订单表如果使用数据库自增ID就会存在一些问题 1.id规律性太明显 2.受单表数据量的限制 如果我们的订单id有太明显的规律，那么对于用户或者竞争对手，就很容易猜测出我们的一些敏感信息，例如商城一天之内能卖出多少单，这明显不合适 随着我们商城的规模越来越大，MySQL的单表容量不宜超过500W，数据量过大之后，我们就要进行拆库拆表，拆分表了之后，他们从逻辑上讲，是同一张表，所以他们的id不能重复，于是乎我们就要保证id的唯一性 那么这就引出我们的全局ID生成器了 全局ID生成器是一种在分布式系统下用来生成全局唯一ID的工具，一般要满足一下特性 唯一性 高可用 高性能 递增性 安全性 为了增加ID的安全性，我们可以不直接使用Redis自增的数值，而是拼接一些其他信息 ID组成部分 符号位：1bit，永远为0 时间戳：31bit，以秒为单位，可以使用69年（2^31秒约等于69年） 序列号：32bit，秒内的计数器，支持每秒传输2^32个不同ID 那我们就根据我们分析的ID生成策略，来编写代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 @Component public class RedisIdWorker { //设置起始时间，我这里设定的是2022.01.01 00:00:00 private static final long BEGIN_TIMESTAMP=1640995200L; //序列号长度 public static final Long COUNT_BIT = 32L; @Autowired private StringRedisTemplate stringRedisTemplate; /** * 生成全局唯一id * @param keyPrefix * @return */ public long nextId(String keyPrefix) { //1.生成时间戳 LocalDateTime now = LocalDateTime.now(); long nowSecond = now.toEpochSecond(ZoneOffset.UTC); long timestamp = nowSecond - BEGIN_TIMESTAMP; //2.生成序列号 //2.1获取当前日，精确到天 String date = now.format(DateTimeFormatter.ofPattern(\u0026#34;yyyy:MM:dd\u0026#34;)); //2.2自增长 Long count = stringRedisTemplate.opsForValue().increment(\u0026#34;icr\u0026#34; + keyPrefix + \u0026#34;:\u0026#34; + date); //3.拼接并返回,简单位运算 return timestamp \u0026lt;\u0026lt; COUNT_BIT | count; } } 4.2添加优惠券 每个店铺度可以发布优惠券，分为平价券和特价券，平价券可以任意购买，而特价券需要秒杀抢购 tb_voucher：优惠券的基本信息，优惠金额、使用规则等 tb_seckill_voucher：优惠券的库存、开始抢购时间，结束抢购时间。特价优惠券才需要填写这些信息 平价券由于优惠力度并不是很大，所以是可以任意领取 而代金券由于优惠力度大，所以像第二种券，就得限制数量，从表结构上也能看出，特价券除了具有优惠券的基本信息以外，还具有库存，抢购时间，结束时间等等字段 添加优惠券的代码已经提供好了 1 2 3 4 5 6 7 8 9 10 /** * 新增秒杀券 * @param voucher 优惠券信息，包含秒杀信息 * @return 优惠券id */ @PostMapping(\u0026#34;seckill\u0026#34;) public Result addSeckillVoucher(@RequestBody Voucher voucher) { voucherService.addSeckillVoucher(voucher); return Result.ok(voucher.getId()); } 1 2 3 4 5 6 7 8 9 /** * 查询店铺的优惠券列表 * @param shopId 店铺id * @return 优惠券列表 */ @GetMapping(\u0026#34;/list/{shopId}\u0026#34;) public Result queryVoucherOfShop(@PathVariable(\u0026#34;shopId\u0026#34;) Long shopId) { return voucherService.queryVoucherOfShop(shopId); } 1 2 3 4 5 6 7 8 9 10 11 12 13 @Override @Transactional public void addSeckillVoucher(Voucher voucher) { // 保存优惠券 save(voucher); // 保存秒杀信息 SeckillVoucher seckillVoucher = new SeckillVoucher(); seckillVoucher.setVoucherId(voucher.getId()); seckillVoucher.setStock(voucher.getStock()); seckillVoucher.setBeginTime(voucher.getBeginTime()); seckillVoucher.setEndTime(voucher.getEndTime()); seckillVoucherService.save(seckillVoucher); } 由于这里并没有后台管理页面，所以我们只能用POSTMAN模拟发送请求来新增秒杀券，请求路径http://localhost:8080/voucher/seckill， 请求方式POST，JSON数据如下，注意优惠券的截止日期设置，若优惠券过期，则不会在页面上显示。 1 2 3 4 5 6 7 8 9 10 11 12 { \u0026#34;shopId\u0026#34;:1, \u0026#34;title\u0026#34;:\u0026#34;100元代金券\u0026#34;, \u0026#34;subTitle\u0026#34;:\u0026#34;周一至周五可用\u0026#34;, \u0026#34;rules\u0026#34;:\u0026#34;全场通用\\\\n无需预约\\\\n可无限叠加\u0026#34;, \u0026#34;payValue\u0026#34;:8000, \u0026#34;actualValue\u0026#34;:10000, \u0026#34;type\u0026#34;:1, \u0026#34;stock\u0026#34;:100, \u0026#34;beginTime\u0026#34;:\u0026#34;2022-01-01T00:00:00\u0026#34;, \u0026#34;endTime\u0026#34;:\u0026#34;2024-10-31T23:59:59\u0026#34; } 4.3实现秒杀下单 我们点击限时抢购，然后查看发送的请求 请求网址: http://localhost:8080/api/voucher-order/seckill/7\n请求方法: POST\n那我们现在来分析一下怎么抢优惠券 首先提交优惠券id，然后查询优惠券信息 之后判断秒杀时间是否开始 开始了，则判断是否有剩余库存 有库存，那么删减一个库存 然后创建订单 无库存，则返回一个错误信息 没开始，则返回一个错误信息 代码实现 1 2 3 4 5 6 7 8 9 10 11 @RestController @RequestMapping(\u0026#34;/voucher-order\u0026#34;) public class VoucherOrderController { @Autowired private IVoucherOrderService voucherOrderService; @PostMapping(\u0026#34;seckill/{id}\u0026#34;) public Result seckillVoucher(@PathVariable(\u0026#34;id\u0026#34;) Long voucherId) { return voucherOrderService.seckillVoucher(voucherId); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 @Service public class VoucherOrderServiceImpl extends ServiceImpl\u0026lt;VoucherOrderMapper, VoucherOrder\u0026gt; implements IVoucherOrderService { @Autowired private ISeckillVoucherService seckillVoucherService; @Autowired private RedisIdWorker redisIdWorker; @Override @Transactional public Result seckillVoucher(Long voucherId) { //1.查询优惠卷 SeckillVoucher vouchar = seckillVoucherService.getById(voucherId); //2.判断秒杀时间是否开始 if (vouchar.getBeginTime().isAfter(LocalDateTime.now())) { //尚未开始 return Result.fail(\u0026#34;秒杀尚未开始\u0026#34;); } //3.判断秒杀时间是否已经结束 if (vouchar.getEndTime().isBefore(LocalDateTime.now())) { //已经结束 return Result.fail(\u0026#34;秒杀已经结束\u0026#34;); } //4.判断库存是否充足 if (vouchar.getStock()\u0026lt;1) { //库存不足 return Result.fail(\u0026#34;库存不足\u0026#34;); } //5.扣减库存 boolean success = seckillVoucherService.update() .setSql(\u0026#34;stock=stock-1\u0026#34;) .eq(\u0026#34;voucher_id\u0026#34;,voucherId).update(); if (!success) { //扣减库存失败 return Result.fail(\u0026#34;库存不足\u0026#34;); } //6.创建订单 VoucherOrder voucherOrder = new VoucherOrder(); //6.1订单id long orderId = redisIdWorker.nextId(\u0026#34;order\u0026#34;); voucherOrder.setId(orderId); //6.2用户订单 Long userId = UserHolder.getUser().getId(); voucherOrder.setUserId(userId); //6.3代金券订单 voucherOrder.setVoucherId(voucherId); save(voucherOrder); //7.返回订单id return Result.ok(orderId); } } 4.4超卖问题 我们之前的代码其实是有问题的，当遇到高并发场景时，会出现超卖现象，我们可以用Jmeter开200个线程来模拟抢优惠券的场景，URL为 localhost:8081/voucher-order/seckill/12，请求方式为POST 测试完毕之后，查看数据库中的订单表，我们明明只设置了100张优惠券，却有200条数据，去优惠券表查看，库存为-100，超卖了100张 那么如何解决这个问题呢？先来看看我们的代码中是怎么写的 1 2 3 4 5 6 7 8 9 10 11 12 13 //4.判断库存是否充足 if (vouchar.getStock()\u0026lt;1) { //库存不足 return Result.fail(\u0026#34;库存不足\u0026#34;); } //5.扣减库存 boolean success = seckillVoucherService.update() .setSql(\u0026#34;stock=stock-1\u0026#34;) .eq(\u0026#34;voucher_id\u0026#34;,voucherId).update(); if (!success) { //扣减库存失败 return Result.fail(\u0026#34;库存不足\u0026#34;); } 假设现在只剩下一张优惠券，线程1过来查询库存，判断库存数大于1，但还没来得及去扣减库存，此时库线程2也过来查询库存，发现库存数也大于1，那么这两个线程都会进行扣减库存操作，最终相当于是多个线程都进行了扣减库存，那么此时就会出现超卖问题 超卖问题是典型的多线程安全问题，针对这一问题的常见解决方案就是加锁：而对于加锁，我们通常有两种解决方案 1.悲观锁 悲观锁认为线程安全问题一定会发生，因此在操作数据之前先获取锁，确保线程串行执行 例如Synchronized、Lock等，都是悲观锁 2.乐观锁 乐观锁认为线程安全问题不一定会发生，因此不加锁，只是在更新数据的时候再去判断有没有其他线程对数据进行了修改 如果没有修改，则认为自己是安全的，自己才可以更新数据 如果已经被其他线程修改，则说明发生了安全问题，此时可以重试或者异常 悲观锁：悲观锁可以实现对于数据的串行化执行，比如syn，和lock都是悲观锁的代表，同时，悲观锁中又可以再细分为公平锁，非公平锁，可重入锁等等 乐观锁：乐观锁会有一个版本号，每次操作数据会对版本号+1，再提交回数据时，会去校验是否比之前的版本大1 ，如果大1 ，则进行操作成功，这套机制的核心逻辑在于，如果在操作过程中，版本号只比原来大1 ，那么就意味着操作过程中没有人对他进行过修改，他的操作就是安全的，如果不大1，则数据被修改过，当然乐观锁还有一些变种的处理方式比如CAS 乐观锁的典型代表：就是CAS(Compare-And-Swap)，利用CAS进行无锁化机制加锁，var5 是操作前读取的内存值，while中的var1+var2 是预估值，如果预估值 == 内存值，则代表中间没有被人修改过，此时就将新值去替换 内存值 在该项目当中并不需要使用一个额外的版本号作为数据库字段 可以使用优惠券表中的stock字段充当版本号，在扣减库存时，比较查询到的优惠券库存和实际数据库中优惠券库存是否相同 1 2 3 4 5 6 //5. 扣减库存 boolean success = iSeckillVoucherService.update() .setSql(\u0026#34;stock = stock - 1\u0026#34;) .eq(\u0026#34;voucher_id\u0026#34;,voucherId) + .eq(\u0026#34;stock\u0026#34;,seckillVoucher.getStock()) .update(); 以上逻辑的核心含义是：只要我扣减库存时的库存和之前我查询到的库存是一样的，就意味着没有人在中间修改过库存，那么此时就是安全的，但是以上这种方式通过测试发现会有很多失败的情况，失败的原因在于：在使用乐观锁过程中假设100个线程同时都拿到了100的库存，然后大家一起去进行扣减，但是100个人中只有1个人能扣减成功，其他的人在处理时，他们在扣减时，库存已经被修改过了，所以此时其他线程都会失败 那么我们继续完善代码，修改我们的逻辑，在这种场景，我们可以只判断是否有剩余优惠券，即只要数据库中的库存大于0，都能顺利完成扣减库存操作 1 2 3 4 5 6 7 8 //5. 扣减库存 boolean success = iSeckillVoucherService.update() .setSql(\u0026#34;stock = stock - 1\u0026#34;) .eq(\u0026#34;voucher_id\u0026#34;,voucherId) -\t.eq(\u0026#34;stock\u0026#34;,seckillVoucher.getStock()) + //mp语法 判断某个属性是否大于value + .gt(\u0026#34;stock\u0026#34;,0) .update(); 再用Jmeter测一下 就能发现优惠券不会出现超卖！ 4.5一人一单 需求：修改秒杀业务，要求同一个优惠券，一个用户只能抢一张 具体操作逻辑如下：我们在判断库存是否充足之后，根据我们保存的订单数据，判断用户订单是否已存在 如果已存在，则不能下单，返回错误信息 如果不存在，则继续下单，获取优惠券 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 //4.判断库存是否充足 if (vouchar.getStock()\u0026lt;1) { //库存不足 return Result.fail(\u0026#34;库存不足\u0026#34;); } //5.一人一单 + Long userId = UserHolder.getUser().getId(); + //5.1查询订单 + int count = query().eq(\u0026#34;user_id\u0026#34;, userId).eq(\u0026#34;voucher_id\u0026#34;, voucherId).count(); + //5.2判断是否存在 + if (count \u0026gt; 0) { + //用户已经购买过了 + return Result.fail(\u0026#34;您已经购买过此优惠卷\u0026#34;); + } //6.扣减库存 boolean success = seckillVoucherService.update() .setSql(\u0026#34;stock=stock-1\u0026#34;)//set stock=stock-1 .eq(\u0026#34;voucher_id\u0026#34;,voucherId).gt(\u0026#34;stock\u0026#34;,0)//where id=?and stock=? .update(); if (!success) { //扣减库存失败 return Result.fail(\u0026#34;库存不足\u0026#34;); } 存在问题：还是和之前一样，如果这个用户故意开多线程抢优惠券，那么在判断库存充足之后，执行一人一单逻辑之前，在这个区间如果进来了多个线程，还是可以抢多张优惠券的，那我们这里使用悲观锁来解决这个问题 初步代码，我们把一人一单逻辑之后的代码都提取到一个createVoucherOrder方法中，然后给这个方法加锁 不管哪一个线程（例如线程A），运行到这个方法时，都要检查有没有其它线程B（或者C、 D等）正在用这个方法(或者该类的其他同步方法)，有的话要等正在使用synchronized方法的线程B（或者C 、D）运行完这个方法后再运行此线程A，没有的话，锁定调用者，然后直接运行 首先不建议把锁加在方法上，因为任何一个用户来了都要加这把锁，而且是同一把锁，方法之间变成串行执行，性能很差。 因此可以把锁加在用户id上，只有当id相同时才会对锁形成竞争关系。但是因为toString的内部是new了一个String字符串，每调一次toString都是生成一个全新的字符串对象，锁对象会变。 所以可以调用intern()方法，intern()方法会优先去字符串常量池里查找与目标字符串值相同的引用返回（只要字符串一样能保证返回的结果一样）。 但是因为事务是在函数执行结束之后由Spring进行提交，如果把锁加在createVoucherOrder内部其实有点小——因为如果解锁之后，其它线程可以进入，而此时事务尚未提交，仍然会导致安全性问题。 因此最终方案是把synchronized加在createVoucherOrder的方法外部，锁住的是用户id。 关于代理对象事务的问题： 通常情况下，当一个使用了@Transactional注解的方法被调用时，Spring会从上下文中获取一个代理对象来管理事务。 但是如果加@Transactional方法是被同一个类中的另一个方法调用时，Spring不会使用代理对象，而是直接调用该方法，导致事务注解失效。 为避免这种情况，可以使用AopContext.currentProxy方法获取当前的代理对象，然后通过代理对象调用被@Transactional注解修饰的方法，确保事务生效。 在VoucherOrderServiceImpl中进行如下修改（注意：ctrl+alt+m可以把含有return的代码段进行提取）： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 @Service public class VoucherOrderServiceImpl extends ServiceImpl\u0026lt;VoucherOrderMapper, VoucherOrder\u0026gt; implements IVoucherOrderService { @Autowired private ISeckillVoucherService seckillVoucherService; @Autowired private RedisIdWorker redisIdWorker; @Override public Result seckillVoucher(Long voucherId) { //1.查询优惠卷 SeckillVoucher vouchar = seckillVoucherService.getById(voucherId); //2.判断秒杀时间是否开始 if (vouchar.getBeginTime().isAfter(LocalDateTime.now())) { //尚未开始 return Result.fail(\u0026#34;秒杀尚未开始\u0026#34;); } //3.判断秒杀时间是否已经结束 if (vouchar.getEndTime().isBefore(LocalDateTime.now())) { //已经结束 return Result.fail(\u0026#34;秒杀已经结束\u0026#34;); } //4.判断库存是否充足 if (vouchar.getStock() \u0026lt; 1) { //库存不足 return Result.fail(\u0026#34;库存不足\u0026#34;); } Long userId = UserHolder.getUser().getId(); synchronized (userId.toString().intern()) { //获取代理对象 IVoucherOrderService proxy = (IVoucherOrderService)AopContext.currentProxy(); return proxy.createVoucherOrder(voucherId); } } @Transactional public Result createVoucherOrder (Long voucherId){ //5.一人一单 Long userId = UserHolder.getUser().getId(); //5.1查询订单 int count = query().eq(\u0026#34;user_id\u0026#34;, userId).eq(\u0026#34;voucher_id\u0026#34;, voucherId).count(); //5.2判断是否存在 if (count \u0026gt; 0) { //用户已经购买过了 return Result.fail(\u0026#34;您已经购买过此优惠卷\u0026#34;); } //6.扣减库存 boolean success = seckillVoucherService.update() .setSql(\u0026#34;stock=stock-1\u0026#34;)//set stock=stock-1 .eq(\u0026#34;voucher_id\u0026#34;, voucherId).gt(\u0026#34;stock\u0026#34;, 0)//where id=?and stock=? .update(); if (!success) { //扣减库存失败 return Result.fail(\u0026#34;库存不足\u0026#34;); } //7.创建订单 VoucherOrder voucherOrder = new VoucherOrder(); //7.1订单id long orderId = redisIdWorker.nextId(\u0026#34;order\u0026#34;); voucherOrder.setId(orderId); //7.2用户订单 voucherOrder.setUserId(userId); //7.3代金券订单 voucherOrder.setVoucherId(voucherId); save(voucherOrder); //8.返回订单id return Result.ok(orderId); } } 在IVoucherOrderService接口中加入下面这个方法： 1 Result createVoucherOrder(Long voucherId); 在pom.xml中引入如下的依赖 1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.aspectj\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;aspectjweaver\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 在启动类HmDianPingApplication上加如下注解：\n1 @EnableAspectJAutoProxy(exposeProxy = true) 测试 重启服务器，再次使用Jmeter测试，200个线程并发，但是只能抢到一张优惠券，目的达成 4.6集群环境下的并发问题 通过加锁可以解决在单机情况下的一人一单安全问题，但是在集群模式下就不行了 1.我们将服务启动两份，端口分别为8081和8082 2.然后修改nginx的config目录下的nginx.conf文件，配置反向代理和负载均衡（默认轮询就行） 原始配置 1 2 3 4 5 6 7 proxy_pass http://127.0.0.1:8081; #proxy_pass http://backend; upstream backend { server 127.0.0.1:8081 max_fails=5 fail_timeout=10s weight=1; #server 127.0.0.1:8082 max_fails=5 fail_timeout=10s weight=1; } - 修改后 1 2 3 4 5 6 7 #proxy_pass http://127.0.0.1:8081; proxy_pass http://backend; upstream backend { server 127.0.0.1:8081 max_fails=5 fail_timeout=10s weight=1; server 127.0.0.1:8082 max_fails=5 fail_timeout=10s weight=1; } 具体操作，我们使用POSTMAN发送两次请求，header携带同一用户的token，尝试用同一账号抢两张优惠券，发现是可行的。 失败原因分析：由于我们部署了多个Tomcat，每个Tomcat都有一个属于自己的jvm，那么假设在服务器A的Tomcat内部，有两个线程，即线程1和线程2，这两个线程使用的是同一份代码，那么他们的锁对象是同一个，是可以实现互斥的。但是如果在Tomcat的内部，又有两个线程，但是他们的锁对象虽然写的和服务器A一样，但是锁对象却不是同一个，所以线程3和线程4可以实现互斥，但是却无法和线程1和线程2互斥 这就是集群环境下，syn锁失效的原因，在这种情况下，我们需要使用分布式锁来解决这个问题，让锁不存在于每个jvm的内部，而是让所有jvm公用外部的一把锁（Redis） 5.分布式锁 5.1基本原理 分布式锁：满足分布式系统或集群模式下多线程可见并且可以互斥的锁 分布式锁的核心思想就是让大家共用同一把锁，那么我们就能锁住线程，不让线程进行，让程序串行执行，这就是分布式锁的核心思路 那么分布式锁应该满足一些什么条件呢？ 可见性：多个线程都能看到相同的结果。 注意：这里说的可见性并不是并发编程中指的内存可见性，只是说多个进程之间都能感知到变化的意思 互斥：互斥是分布式锁的最基本条件，使得程序串行执行 高可用：程序不易崩溃，时时刻刻都保证较高的可用性 高性能：由于加锁本身就让性能降低，所以对于分布式锁需要他较高的加锁性能和释放锁性能 安全性：安全也是程序中必不可少的一环 常见的分布式锁有三种 MySQL：MySQL本身就带有锁机制，但是由于MySQL的性能一般，所以采用分布式锁的情况下，使用MySQL作为分布式锁比较少见 Redis：Redis作为分布式锁是非常常见的一种使用方式，现在企业级开发中基本都是用Redis或者Zookeeper作为分布式锁，利用SETNX这个方法，如果插入Key成功，则表示获得到了锁，如果有人插入成功，那么其他人就回插入失败，无法获取到锁，利用这套逻辑完成互斥，从而实现分布式锁 Zookeeper：Zookeeper也是企业级开发中较好的一种实现分布式锁的方案，但本文是学Redis的，所以这里就不过多阐述了 MySQL Redis Zookeeper 互斥 利用mysql本身的互斥锁机制 利用setnx这样的互斥命令 利用节点的唯一性和有序性实现互斥 高可用 好 好 好 高性能 一般 好 一般 安全性 断开连接，自动释放锁 利用锁超时时间，到期释放 临时节点，断开连接自动释放 5.2Redis分布式锁的实现核心思路 实现分布式锁时需要实现两个基本方法 获取锁 互斥：确保只能有一个线程获取锁 非阻塞：尝试一次，成功返回true，失败返回false 释放锁 手动释放 超时释放：获取锁的时候添加一个超时时间 核心思路 我们利用redis的SETNX方法，当有多个线程进入时，我们就利用该方法来获取锁。第一个线程进入时，redis 中就有这个key了，返回了1，如果结果是1，则表示他抢到了锁，那么他去执行业务，然后再删除锁，退出锁逻辑，没有抢到锁（返回了0）的线程，等待一定时间之后重试 5.3实现分布式锁 锁的基本接口 1 2 3 4 5 6 7 8 9 10 11 12 13 14 public interface ILock { /** * 尝试获取锁 * * @param timeoutSec 锁持有的超时时间，过期自动释放 * @return true表示获取锁成功，false表示获取锁失败 */ boolean tryLock(long timeoutSec); /** * 释放锁 */ void unlock(); } 然后创建一个SimpleRedisLock类实现接口 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 public class SimpleRedisLock implements ILock{ //锁的前缀 private static final String KEY_PREFIX = \u0026#34;lock:\u0026#34;; //具体业务名称，将前缀和业务名拼接之后当做Key private String name; private StringRedisTemplate stringRedisTemplate; public SimpleRedisLock(String name, StringRedisTemplate stringRedisTemplate) { this.name = name; this.stringRedisTemplate = stringRedisTemplate; } @Override public boolean tryLock(long timeoutSec) { //获取线程标识 long threadId = Thread.currentThread().getId(); //获取锁，使用SETNX方法进行加锁，同时设置过期时间，防止死锁 Boolean success = stringRedisTemplate.opsForValue().setIfAbsent(KEY_PREFIX + name, threadId + \u0026#34;\u0026#34;, timeoutSec, TimeUnit.SECONDS); //自动拆箱可能会出现null，这样写更稳妥 return Boolean.TRUE.equals(success); } @Override public void unlock() { //通过DEL来删除锁 stringRedisTemplate.delete(KEY_PREFIX + name); } } 修改业务代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 @Override public Result seckillVoucher(Long voucherId) { //1.查询优惠卷 SeckillVoucher vouchar = seckillVoucherService.getById(voucherId); //2.判断秒杀时间是否开始 if (vouchar.getBeginTime().isAfter(LocalDateTime.now())) { //尚未开始 return Result.fail(\u0026#34;秒杀尚未开始\u0026#34;); } //3.判断秒杀时间是否已经结束 if (vouchar.getEndTime().isBefore(LocalDateTime.now())) { //已经结束 return Result.fail(\u0026#34;秒杀已经结束\u0026#34;); } //4.判断库存是否充足 if (vouchar.getStock() \u0026lt; 1) { //库存不足 return Result.fail(\u0026#34;库存不足\u0026#34;); } Long userId = UserHolder.getUser().getId(); //创建锁对象 SimpleRedisLock lock = new SimpleRedisLock(\u0026#34;order:\u0026#34; + userId, stringredisTemplate); //获取锁 boolean isLock = lock.tryLock(500); if (!isLock) { //获取锁失败，返回错误信息，或者重试 return Result.fail(\u0026#34;不允许重复下单\u0026#34;); } try { //获取代理对象 IVoucherOrderService proxy = (IVoucherOrderService)AopContext.currentProxy(); return proxy.createVoucherOrder(voucherId); }finally { //释放锁 lock.unlock(); } } 使用Jmeter进行压力测试，请求头中携带登录用户的token，最终只能抢到一张优惠券 5.4Redis分布式锁误删情况 5.4.1Redis分布式锁误删情况说明 逻辑说明 持有锁的线程1在锁的内部出现了阻塞，导致他的锁TTL到期，自动释放 此时线程2也来尝试获取锁，由于线程1已经释放了锁，所以线程2可以拿到 但是现在线程1阻塞完了，继续往下执行，要开始释放锁了 那么此时就会将属于线程2的锁释放，这就是误删别人锁的情况 解决方案 解决方案就是在每个线程释放锁的时候，都判断一下这个锁是不是自己的，如果不属于自己，则不进行删除操作。 假设还是上面的情况，线程1阻塞，锁自动释放，线程2进入到锁的内部执行逻辑，此时线程1阻塞完了，继续往下执行，开始删除锁，但是线程1发现这把锁不是自己的，所以不进行删除锁的逻辑，当线程2执行到删除锁的逻辑时，如果TTL还未到期，则判断当前这把锁是自己的，于是删除这把锁 5.4.2解决Redis分布式锁误删问题 需求：修改之前的分布式锁实现 满足：在获取锁的时候存入线程标识（用UUID标识，在一个JVM中，ThreadId一般不会重复，但是我们现在是集群模式，有多个JVM，多个JVM之间可能会出现ThreadId重复的情况），在释放锁的时候先获取锁的线程标识，判断是否与当前线程标识一致 如果一致则释放锁 如果不一致则不释放锁 核心逻辑：在存入锁的时候，放入自己的线程标识，在删除锁的时候，判断当前这把锁是不是自己存入的 如果是，则进行删除 如果不是，则不进行删除 具体实现代码如下 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 //用UUID 来标识不同的JVM 避免不同的JVM 出现相同threadId的情况导致锁误删 private static final String ID_PREFIX = UUID.randomUUID().toString(true)+\u0026#34;-\u0026#34;; @Override public boolean tryLock(long timeoutSec) { //获取线程标识 String threadId = ID_PREFIX+Thread.currentThread().getId(); //获取锁，使用SETNX方法进行加锁，同时设置过期时间，防止死锁 Boolean success = stringRedisTemplate.opsForValue().setIfAbsent(KEY_PREFIX + name, threadId, timeoutSec, TimeUnit.SECONDS); //自动拆箱可能会出现null，这样写更稳妥 return Boolean.TRUE.equals(success); } @Override public void unlock() { //获取线程标识 String threadId = ID_PREFIX+Thread.currentThread().getId(); //获取锁中的标识 String id = stringRedisTemplate.opsForValue().get(KEY_PREFIX + threadId); if (threadId.equals(id)) { //释放锁 stringRedisTemplate.delete(KEY_PREFIX + name); } } 5.5分布式锁的原子性问题 5.5.1问题说明 更为极端的误删逻辑说明 假设线程1已经获取了锁，在判断标识一致之后，准备释放锁的时候，又出现了阻塞（例如JVM垃圾回收机制） 于是锁的TTL到期了，自动释放了 那么现在线程2趁虚而入，拿到了一把锁 但是线程1的逻辑还没执行完，那么线程1就会执行删除锁的逻辑 但是在阻塞前线程1已经判断了标识一致，所以现在线程1把线程2的锁给删了 那么就相当于判断标识那行代码没有起到作用 这就是删锁时的原子性问题 因为线程1的拿锁，判断标识，删锁，不是原子操作(两个动作)，所以我们要防止刚刚的情况 5.5.2Lua脚本解决多条命令原子性问题 Redis提供了Lua脚本功能，在一个脚本中编写多条Redis命令，确保多条命令执行时的原子性。 Lua是一种编程语言，它的基本语法可以上菜鸟教程看看，点击链接 这里重点介绍Redis提供的调用函数，我们可以使用Lua去操作Redis，而且还能保证它的原子性，这样就可以实现拿锁，判断标识，删锁是一个原子性动作了 Redis提供的调用函数语法如下： 1 redis.call(\u0026#39;命令名称\u0026#39;,\u0026#39;key\u0026#39;,\u0026#39;其他参数\u0026#39;, ...) 例如我们要执行set name Kyle，则脚本是这样 1 redis.call(\u0026#39;set\u0026#39;,\u0026#39;name\u0026#39;,\u0026#39;Kyle\u0026#39;) 例如我我们要执行set name David，在执行get name，则脚本如下 1 2 3 4 5 6 ## 先执行set name David redis.call(\u0026#39;set\u0026#39;, \u0026#39;name\u0026#39;, \u0026#39;David\u0026#39;) ## 再执行get name local name = redis.call(\u0026#39;get\u0026#39;, \u0026#39;name\u0026#39;) ## 返回 return name 写好脚本以后，需要用Redis命令来调用脚本，调用脚本的常见命令如下 1 EVAL script numkeys key [key ...] arg [arg ...] 例如，我们要调用redis.call(‘set’, ‘name’, ‘Kyle’) 0这个脚本，语法如下 1 EVAL \u0026#34;return redis.call(\u0026#39;set\u0026#39;, \u0026#39;name\u0026#39;, \u0026#39;Kyle\u0026#39;)\u0026#34; 0 如果脚本中的key和value不想写死，可以作为参数传递，key类型参数会放入KEYS数组，其他参数会放入ARGV数组，在脚本中可以从KEYS和ARGV数组中获取这些参数 注意：在Lua中，数组下标从1开始\n1 EVAL \u0026#34;return redis.call(\u0026#39;set\u0026#39;, KEYS[1], ARGV[1])\u0026#34; 1 name Lucy 那现在我们来使用Lua脚本来代替我们释放锁的逻辑 复杂代码 1 2 3 4 5 6 7 8 9 10 11 12 -- 线程标识 local threadId = \u0026#34;UUID-31\u0026#34; -- 锁的key local key = \u0026#34;lock:order:userId\u0026#34; -- 获取锁中线程标识 local id = redis.call(\u0026#39;get\u0026#39;, key) -- 比较线程标识与锁的标识是否一致 if (threadId == id) then -- 一致则释放锁 del key return redis.call(\u0026#39;del\u0026#39;, key) end return 0 简单代码 1 2 3 4 5 6 7 8 -- 这里的KEYS[1]就是传入锁的key -- 这里的ARGV[1]就是线程标识 -- 比较redis锁中的线程标识与JVM线程标识是否一致 if (redis.call(\u0026#39;get\u0026#39;, KEYS[1]) == ARGV[1]) then -- 一致则释放锁 return redis.call(\u0026#39;del\u0026#39;, KEYS[1]) end return 0 5.5.3利用Java代码调用Lua脚本改造分布式锁 在resource目录下新建unlock.lua文件 复制上面脚本 在RedisTemplate中，可以利用execute方法去执行lua脚本 实现代码 1 2 3 4 5 6 7 8 9 10 11 12 13 private static final DefaultRedisScript\u0026lt;Long\u0026gt; UNLOCK_SCRIPT; static { UNLOCK_SCRIPT=new DefaultRedisScript\u0026lt;\u0026gt;(); UNLOCK_SCRIPT.setLocation((Resource) new ClassPathResource(\u0026#34;unlock.lua\u0026#34;));//读文件 方便后期维护 UNLOCK_SCRIPT.setResultType(Long.class); } @Override public void unlock() { //调用lua脚本 stringRedisTemplate.execute(UNLOCK_SCRIPT, Collections.singletonList(KEY_PREFIX + name), ID_PREFIX+Thread.currentThread().getId()); } 但是现在的分布式锁还存在一个问题：锁不住 那什么是锁不住呢？ 如果锁的TTL快到期的时候，我们可以给它续期一下，比如续个30s，就好像是网吧上网，快没网费了的时候，让网管再给你续50块钱的，然后该玩玩，程序也继续往下执行 那么续期问题怎么解决呢，可以依赖于我们接下来要学习redission了 5.6总结 基于redis的分布式锁的实现思路： 利用ser nx ex 获取锁，并设置TTL，保存线程标识； 释放锁时先判断线程标识是否和自己保存一致，一致则删除锁 特性: 利用set nx 满足互斥性 利用set ex 保证故障时锁依然能释放，避免死锁，提高安全性 利用redis集群保证高可用和高并发性 6.分布式锁-Redisson 前言 基于SETNX实现的分布式锁存在以下问题： 1.不可重入 重入问题是指获取锁的线程，可以再次进入到相同的锁的代码块中，可重入锁的意义在于防止死锁，例如在HashTable这样的代码中，它的方法都是使用synchronized修饰的，加入它在一个方法内调用另一个方法，如果此时是不可重入的，那就死锁了。所以可重入锁的主要意义是防止死锁，我们的synchronized和Lock锁都是可重入的 2.不可重试 我们编写的分布式锁只能尝试一次，失败了就返回false，没有重试机制。但合理的情况应该是：当线程获取锁失败后，他应该能再次尝试获取锁 3.超时释放 我们在加锁的时候增加了TTL，这样我们可以防止死锁，但是如果卡顿(阻塞)时间太长，也会导致锁的释放。虽然我们采用Lua脚本来防止删锁的时候，误删别人的锁，但现在的新问题是没锁住，也有安全隐患 4.主从一致性 如果Redis提供了主从集群，那么当我们向集群写数据时，主机需要异步的将数据同步给从机，万一在同步之前，主机宕机了(主从同步存在延迟，虽然时间很短，但还是发生了)，那么又会出现死锁问题 那么什么是Redisson呢 Redisson是一个在Redis的基础上实现的Java驻内存数据网格(In-Memory Data Grid)。它不仅提供了一系列的分布式Java常用对象，还提供了许多分布式服务，其中就包含了各种分布式锁的实现 Redis提供了分布式锁的多种多样功能 1.可重入锁(Reentrant Lock) 2.公平锁(Fair Lock) 3.联锁(MultiLock) 4.红锁(RedLock) 5.读写锁(ReadWriteLock) 6.信号量(Semaphore) 7.可过期性信号量(PermitExpirableSemaphore) 8.闭锁(CountDownLatch) 6.1Redisson入门 1.依赖导入 1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.redisson\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;redisson\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.13.6\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 2.配置Redisson客户端，在config包下新建RedissonConfig类 1 2 3 4 5 6 7 8 9 10 @Configuration public class RedissonConfig { @Bean public RedissonClient redissonClient() { Config config = new Config(); config.useSingleServer() .setAddress(\u0026#34;redis://localhost:6380\u0026#34;).setPassword(\u0026#34;123456\u0026#34;); return Redisson.create(config); } } 3.使用Redisson的分布式锁 // 4.替换之前写的分布式锁 tip:注入RedissonClient 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 @Override public Result seckillVoucher(Long voucherId) { //1.查询优惠卷 SeckillVoucher vouchar = seckillVoucherService.getById(voucherId); //2.判断秒杀时间是否开始 if (vouchar.getBeginTime().isAfter(LocalDateTime.now())) { //尚未开始 return Result.fail(\u0026#34;秒杀尚未开始\u0026#34;); } //3.判断秒杀时间是否已经结束 if (vouchar.getEndTime().isBefore(LocalDateTime.now())) { //已经结束 return Result.fail(\u0026#34;秒杀已经结束\u0026#34;); } //4.判断库存是否充足 if (vouchar.getStock() \u0026lt; 1) { //库存不足 return Result.fail(\u0026#34;库存不足\u0026#34;); } Long userId = UserHolder.getUser().getId(); //创建锁对象 - //SimpleRedisLock lock = new SimpleRedisLock(\u0026#34;order:\u0026#34; + userId, stringredisTemplate); + RLock lock = redissonClient.getLock(\u0026#34;lock:order:\u0026#34; + userId); //获取锁 boolean isLock = lock.tryLock(); if (!isLock) { //获取锁失败，返回错误信息，或者重试 return Result.fail(\u0026#34;不允许重复下单\u0026#34;); } try { //获取代理对象 IVoucherOrderService proxy = (IVoucherOrderService)AopContext.currentProxy(); return proxy.createVoucherOrder(voucherId); }finally { //释放锁 lock.unlock(); } } 成功实现 6.2Redisson可重入锁原理 在Lock锁中，他是借助于等曾的一个voaltile的一个state变量来记录重入的状态的 如果当前没有人持有这把锁，那么state = 0 如果有人持有这把锁，那么state = 1 如果持有者把锁的人(同一线程下)再次持有这把锁，那么state会+1 如果对于synchronize而言，他在c语言代码中会有一个count 原理与state类似，也是重入一次就+1，释放一次就-1，直至减到0，表示这把锁没有被人持有 在redisson中，我们也支持可重入锁 在分布式锁中，它采用hash结构来存储锁，其中外层key表示这把锁是否存在，内层key则记录当前这把锁被哪个线程持有 method1在方法内部调用method2，method1和method2出于同一个线程，那么method1已经拿到一把锁了，想进入method2中拿另外一把锁，必然是拿不到的，于是就出现了死锁（按照之前我们采用SETNX EX 方法实现分布式锁的情况） 所以我们需要额外判断，method1和method2是否处于同一线程，如果是同一个线程，则可以拿到锁，但是state会+1，之后执行method2中的方法，释放锁，释放锁的时候也只是将state进行-1，只有减至0，才会真正释放锁 由于我们需要额外存储一个state，所以用字符串型SET NX EX是不行的，需要用到Hash结构，但是Hash结构又没有NX这种方法，所以我们需要将原有的逻辑拆开，进行手动判断（expire） 看这个流程图 是不是很复杂（很多的判锁 删锁操作） 为了保证原子性——流程图中的业务逻辑也是需要我们用Lua来实现 获取锁的逻辑 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 local key = KEYS[1]; -- 锁的key local threadId = ARGV[1]; -- 线程唯一标识 local releaseTime = ARGV[2]; -- 锁的自动释放时间 -- 锁不存在 if (redis.call(\u0026#39;exists\u0026#39;, key) == 0) then -- 获取锁并添加线程标识，state设为1 redis.call(\u0026#39;hset\u0026#39;, key, threadId, \u0026#39;1\u0026#39;); -- 设置锁有效期 redis.call(\u0026#39;expire\u0026#39;, key, releaseTime); return 1; -- 返回结果 end; -- 锁存在，判断threadId是否为自己 if (redis.call(\u0026#39;hexists\u0026#39;, key, threadId) == 1) then -- 锁存在，重入次数 +1，这里用的是hash结构的incrby增长 redis.call(\u0026#39;hincrby\u0026#39;, key, thread, 1); -- 设置锁的有效期 redis.call(\u0026#39;expire\u0026#39;, key, releaseTime); return 1; -- 返回结果 end; return 0; -- 代码走到这里，说明获取锁的不是自己，获取锁失败 获取锁的逻辑 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 local key = KEYS[1]; local threadId = ARGV[1]; local releaseTime = ARGV[2]; -- 如果锁不是自己的 if (redis.call(\u0026#39;HEXISTS\u0026#39;, key, threadId) == 0) then return nil; -- 直接返回 end; -- 锁是自己的，锁计数-1，还是用hincrby，不过自增长的值为-1 local count = redis.call(\u0026#39;hincrby\u0026#39;, key, threadId, -1); -- 判断重入次数为多少 if (count \u0026gt; 0) then -- 大于0，重置有效期 redis.call(\u0026#39;expire\u0026#39;, key, releaseTime); return nil; else -- 否则直接释放锁 redis.call(\u0026#39;del\u0026#39;, key); return nil; end; 获取锁源码 查看源码 ，和我们实现的方式几乎一致 1 2 3 4 \u0026lt;T\u0026gt; RFuture\u0026lt;T\u0026gt; tryLockInnerAsync(long waitTime, long leaseTime, TimeUnit unit, long threadId, RedisStrictCommand\u0026lt;T\u0026gt; command) { this.internalLockLeaseTime = unit.toMillis(leaseTime); return this.evalWriteAsync(this.getName(), LongCodec.INSTANCE, command, \u0026#34;if (redis.call(\u0026#39;exists\u0026#39;, KEYS[1]) == 0) then redis.call(\u0026#39;hincrby\u0026#39;, KEYS[1], ARGV[2], 1); redis.call(\u0026#39;pexpire\u0026#39;, KEYS[1], ARGV[1]); return nil; end; if (redis.call(\u0026#39;hexists\u0026#39;, KEYS[1], ARGV[2]) == 1) then redis.call(\u0026#39;hincrby\u0026#39;, KEYS[1], ARGV[2], 1); redis.call(\u0026#39;pexpire\u0026#39;, KEYS[1], ARGV[1]); return nil; end; return redis.call(\u0026#39;pttl\u0026#39;, KEYS[1]);\u0026#34;, Collections.singletonList(this.getName()), this.internalLockLeaseTime, this.getLockName(threadId)); } 释放锁源码 1 2 3 protected RFuture\u0026lt;Boolean\u0026gt; unlockInnerAsync(long threadId) { return this.evalWriteAsync(this.getName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN, \u0026#34;if (redis.call(\u0026#39;hexists\u0026#39;, KEYS[1], ARGV[3]) == 0) then return nil;end; local counter = redis.call(\u0026#39;hincrby\u0026#39;, KEYS[1], ARGV[3], -1); if (counter \u0026gt; 0) then redis.call(\u0026#39;pexpire\u0026#39;, KEYS[1], ARGV[2]); return 0; else redis.call(\u0026#39;del\u0026#39;, KEYS[1]); redis.call(\u0026#39;publish\u0026#39;, KEYS[2], ARGV[1]); return 1; end; return nil;\u0026#34;, Arrays.asList(this.getName(), this.getChannelName()), LockPubSub.UNLOCK_MESSAGE, this.internalLockLeaseTime, this.getLockName(threadId)); } 6.3Redisson锁重试和WatchDog机制 tips：源码部分比较难理解（我是小菜鸡），建议多看几遍 前面我们分析的是空参的tryLock方法，现在我们来分析一下这个带参数的 1 2 3 4 \u0026lt;T\u0026gt; RFuture\u0026lt;T\u0026gt; tryLockInnerAsync(long waitTime, long leaseTime, TimeUnit unit, long threadId, RedisStrictCommand\u0026lt;T\u0026gt; command) { this.internalLockLeaseTime = unit.toMillis(leaseTime); return this.evalWriteAsync(this.getName(), LongCodec.INSTANCE, command, \u0026#34;if (redis.call(\u0026#39;exists\u0026#39;, KEYS[1]) == 0) then redis.call(\u0026#39;hincrby\u0026#39;, KEYS[1], ARGV[2], 1); redis.call(\u0026#39;pexpire\u0026#39;, KEYS[1], ARGV[1]); return nil; end; if (redis.call(\u0026#39;hexists\u0026#39;, KEYS[1], ARGV[2]) == 1) then redis.call(\u0026#39;hincrby\u0026#39;, KEYS[1], ARGV[2], 1); redis.call(\u0026#39;pexpire\u0026#39;, KEYS[1], ARGV[1]); return nil; end; return redis.call(\u0026#39;pttl\u0026#39;, KEYS[1]);\u0026#34;, Collections.singletonList(this.getName()), this.internalLockLeaseTime, this.getLockName(threadId)); } 源码分析 tryAcquireAsync 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 private \u0026lt;T\u0026gt; RFuture\u0026lt;Long\u0026gt; tryAcquireAsync(long waitTime, long leaseTime, TimeUnit unit, long threadId) { if (leaseTime != -1L) { return this.tryLockInnerAsync(waitTime, leaseTime, unit, threadId, RedisCommands.EVAL_LONG); } else { // 如果没有指定释放时间时间，默认值为-1，则指定默认释放时间为getLockWatchdogTimeout，底层源码显示是30*1000ms，也就是30秒 RFuture\u0026lt;Long\u0026gt; ttlRemainingFuture = this.tryLockInnerAsync(waitTime, this.commandExecutor.getConnectionManager().getCfg().getLockWatchdogTimeout(), TimeUnit.MILLISECONDS, threadId, RedisCommands.EVAL_LONG); ttlRemainingFuture.onComplete((ttlRemaining, e) -\u0026gt; { if (e == null) { if (ttlRemaining == null) { this.scheduleExpirationRenewal(threadId); } } }); return ttlRemainingFuture; } tryLock 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 public boolean tryLock(long waitTime, long leaseTime, TimeUnit unit) throws InterruptedException { long time = unit.toMillis(waitTime); long current = System.currentTimeMillis(); long threadId = Thread.currentThread().getId(); Long ttl = this.tryAcquire(waitTime, leaseTime, unit, threadId); //判断ttl是否为null if (ttl == null) { return true; } else { //计算当前时间与获取锁时间的差值，让等待时间减去这个值 time -= System.currentTimeMillis() - current; //如果消耗时间太长了，直接返回false，获取锁失败 if (time \u0026lt;= 0L) { this.acquireFailed(waitTime, unit, threadId); return false; } else { //等待时间还有剩余，再次获取当前时间 current = System.currentTimeMillis(); //订阅别人释放锁的信号 RFuture\u0026lt;RedissonLockEntry\u0026gt; subscribeFuture = this.subscribe(threadId); //在剩余时间内，等待这个信号 if (!subscribeFuture.await(time, TimeUnit.MILLISECONDS)) { if (!subscribeFuture.cancel(false)) { subscribeFuture.onComplete((res, e) -\u0026gt; { if (e == null) { //取消订阅 this.unsubscribe(subscribeFuture, threadId); } }); } //剩余时间内没等到，返回false this.acquireFailed(waitTime, unit, threadId); return false; } else { try { //如果剩余时间内等到了别人释放锁的信号，再次计算当前剩余最大等待时间 time -= System.currentTimeMillis() - current; if (time \u0026lt;= 0L) { //如果剩余时间为负数，则直接返回false this.acquireFailed(waitTime, unit, threadId); boolean var20 = false; return var20; } else { boolean var16; do { //如果剩余时间等到了，dowhile循环重试获取锁 long currentTime = System.currentTimeMillis(); ttl = this.tryAcquire(waitTime, leaseTime, unit, threadId); if (ttl == null) { var16 = true; return var16; } time -= System.currentTimeMillis() - currentTime; if (time \u0026lt;= 0L) { this.acquireFailed(waitTime, unit, threadId); var16 = false; return var16; } currentTime = System.currentTimeMillis(); if (ttl \u0026gt;= 0L \u0026amp;\u0026amp; ttl \u0026lt; time) { ((RedissonLockEntry)subscribeFuture.getNow()).getLatch().tryAcquire(ttl, TimeUnit.MILLISECONDS); } else { ((RedissonLockEntry)subscribeFuture.getNow()).getLatch().tryAcquire(time, TimeUnit.MILLISECONDS); } time -= System.currentTimeMillis() - currentTime; } while(time \u0026gt; 0L); this.acquireFailed(waitTime, unit, threadId); var16 = false; return var16; } } finally { this.unsubscribe(subscribeFuture, threadId); } } } } } scheduleExpirationRenewal 1 2 3 4 5 6 7 8 9 10 11 12 private void scheduleExpirationRenewal(long threadId) { ExpirationEntry entry = new ExpirationEntry(); //不存在，才put，表明是第一次进入，不是重入 ExpirationEntry oldEntry = (ExpirationEntry)EXPIRATION_RENEWAL_MAP.putIfAbsent(this.getEntryName(), entry); if (oldEntry != null) { oldEntry.addThreadId(threadId); } else { //如果是第一次进入，则更新有效期 entry.addThreadId(threadId); this.renewExpiration(); } } renewExpiration 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 private void renewExpiration() { ExpirationEntry ee = (ExpirationEntry)EXPIRATION_RENEWAL_MAP.get(this.getEntryName()); if (ee != null) { //Timeout是一个定时任务 Timeout task = this.commandExecutor.getConnectionManager().newTimeout(new TimerTask() { public void run(Timeout timeout) throws Exception { ExpirationEntry ent = (ExpirationEntry)RedissonLock.EXPIRATION_RENEWAL_MAP.get(RedissonLock.this.getEntryName()); if (ent != null) { Long threadId = ent.getFirstThreadId(); if (threadId != null) { //重置有效期 RFuture\u0026lt;Boolean\u0026gt; future = RedissonLock.this.renewExpirationAsync(threadId); future.onComplete((res, e) -\u0026gt; { if (e != null) { RedissonLock.log.error(\u0026#34;Can\u0026#39;t update lock \u0026#34; + RedissonLock.this.getName() + \u0026#34; expiration\u0026#34;, e); } else { if (res) { //然后调用自己，递归重置有效期 RedissonLock.this.renewExpiration(); } } }); } } } //internalLockLeaseTime是之前WatchDog默认有效期30秒，那这里就是 30 / 3 = 10秒之后，才会执行 }, this.internalLockLeaseTime / 3L, TimeUnit.MILLISECONDS); ee.setTimeout(task); } } renewExpirationAsync 重点看lua脚本，先判断锁是不是自己的，然后更新有效时间 那么之前的重置有效期的行为该怎么终止呢？当然是释放锁的时候会终止 1 2 3 protected RFuture\u0026lt;Boolean\u0026gt; renewExpirationAsync(long threadId) { return this.evalWriteAsync(this.getName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN, \u0026#34;if (redis.call(\u0026#39;hexists\u0026#39;, KEYS[1], ARGV[2]) == 1) then redis.call(\u0026#39;pexpire\u0026#39;, KEYS[1], ARGV[1]); return 1; end; return 0;\u0026#34;, Collections.singletonList(this.getName()), this.internalLockLeaseTime, this.getLockName(threadId)); } cancelExpirationRenewal 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 void cancelExpirationRenewal(Long threadId) { //将之前的线程终止掉 ExpirationEntry task = (ExpirationEntry)EXPIRATION_RENEWAL_MAP.get(this.getEntryName()); if (task != null) { if (threadId != null) { task.removeThreadId(threadId); } if (threadId == null || task.hasNoThreads()) { //获取之前的定时任务 Timeout timeout = task.getTimeout(); if (timeout != null) { //取消 timeout.cancel(); } //移除线程 EXPIRATION_RENEWAL_MAP.remove(this.getEntryName()); } } } 6.4Redisson锁的MutiLock原理 为了提高Redis的可用性，我们会搭建集群或者主从，现在以主从为例 此时我们去写命令，写在主机上，主机会将数据同步给从机，但是假设主机还没来得及把数据写入到从机去的时候，主机宕机了 哨兵会发现主机宕机了，于是选举一个slave(从机)变成master(主机)，而此时新的master(主机)上并没有锁的信息(锁失效)，那么其他线程就可以获取锁，又会引发安全问题 为了解决这个问题。Redisson提出来了MutiLock锁，使用这把锁的话，那我们就不用主从了，每个节点的地位都是一- 样的，都可以当做是主机，那我们就需要将加锁的逻辑写入到每一个主从节点上，只有所有的服务器都写入成功，此时才是加锁成功，假设现在某个节点挂了，那么他去获取锁的时候，只要有一个节点拿不到，都不能算是加锁成功，就保证了加锁的可靠性 我们先使用虚拟机额外搭建两个Redis节点 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 @Bean public RedissonClient redissonClient() { Config config = new Config(); config.useSingleServer() .setAddress(\u0026#34;redis://localhost:6380\u0026#34;).setPassword(\u0026#34;123456\u0026#34;); return Redisson.create(config); } @Bean public RedissonClient redissonClient1() { Config config = new Config(); config.useSingleServer() .setAddress(\u0026#34;redis://localhost:6381\u0026#34;).setPassword(\u0026#34;123456\u0026#34;); return Redisson.create(config); } @Bean public RedissonClient redissonClient2() { Config config = new Config(); config.useSingleServer() .setAddress(\u0026#34;redis://localhost:6382\u0026#34;).setPassword(\u0026#34;123456\u0026#34;); return Redisson.create(config); } 6.5小结 1.不可重入Redis分布式锁 原理：利用SETNX的互斥性；利用EX避免死锁；释放锁时判断线程标识 缺陷：不可重入、无法重试、锁超时失效 2.可重入Redis分布式锁 原理：利用Hash结构，记录线程标识与重入次数；利用WatchDog延续锁时间；利用信号量控制锁重试等待 缺陷：Redis宕机引起锁失效问题 3.Redisson的multiLock 原理：多个独立的Redis节点，必须在所有节点都获取重入锁，才算获取锁成功 缺陷：运维成本高 7.秒杀优化 7.1异步秒杀思路 我们先来回顾一下下单流程 当用户发起请求，此时会先请求Nginx，Nginx反向代理到Tomcat，而Tomcat中的程序，会进行串行操作，分为如下几个步骤 1.查询优惠券 2.判断秒杀库存是否足够 3.查询订单 4.校验是否一人一单 5.扣减库存 6.创建订单 在这六个步骤中，有很多操作都是要去操作数据库的，而且还是一个线程串行执行，这样就会导致我们的程序执行很慢，所以我们需要异步程序执行，那么如何加速呢？ 优化方案：我们将耗时较短的逻辑判断放到Redis中，例如：库存是否充足，是否一人一单这样的操作，只要满足这两条操作，那我们是一定可以下单成功的，不用等数据真的写进数据库，我们直接告诉用户下单成功就好了。然后后台再开一个线程，后台线程再去慢慢执行队列里的消息，这样我们就能很快的完成下单业务。 两个难点 如何在redis中完成一人一单，还有库存判断 我们校验一人一单和将下单数据写入数据库，这是两个线程，怎么知道下单是否完成。 我们需要将一些信息返回给前端，同时也将这些信息丢到异步queue中去，后续操作中，可以通过这个id来查询下单逻辑是否完成 我们现在来看整体思路：当用户下单之后，判断库存是否充足，只需要取Redis中根据key找对应的value是否大于0即可，如果不充足，则直接结束。如果充足，则在Redis中判断用户是否可以下单，如果set集合中没有该用户的下单数据，则可以下单，并将userId和优惠券存入到Redis中，并且返回0，整个过程需要保证是原子性的，所以我们要用Lua来操作，同时由于我们需要在Redis中查询优惠券信息，所以在我们新增秒杀优惠券的同时，需要将优惠券信息保存到Redis中 完成以上逻辑判断时，我们只需要判断当前Redis中的返回值是否为0，如果是0，则表示可以下单，将信息保存到queue中去，然后返回，开一个线程来异步下单，其阿奴单可以通过返回订单的id来判断是否下单成功 7.2Redis完成秒杀资格判断 需求： 1.新增秒杀优惠券的同时，将优惠券信息保存到Redis中 2.基于Lua脚本，判断秒杀库存、一人一单，决定用户是否秒杀成功 步骤一：修改保存优惠券相关代码 别忘记加注解 1 2 @Autowired private StringRedisTemplate stringRedisTemplate; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @Override @Transactional public void addSeckillVoucher(Voucher voucher) { // 保存优惠券 save(voucher); // 保存秒杀信息 SeckillVoucher seckillVoucher = new SeckillVoucher(); seckillVoucher.setVoucherId(voucher.getId()); seckillVoucher.setStock(voucher.getStock()); seckillVoucher.setBeginTime(voucher.getBeginTime()); seckillVoucher.setEndTime(voucher.getEndTime()); seckillVoucherService.save(seckillVoucher); //保存秒杀库存到redis stringRedisTemplate.opsForValue().set(SECKILL_STOCK_KEY+voucher.getId(),voucher.getStock().toString()); } 使用PostMan发送请求，添加优惠券 请求路径：http://localhost:8080/api/voucher/seckill\n请求方式：POST\n1 2 3 4 5 6 7 8 9 10 11 12 { \u0026#34;shopId\u0026#34;:1, \u0026#34;title\u0026#34;:\u0026#34;999元代金券\u0026#34;, \u0026#34;subTitle\u0026#34;:\u0026#34;365*24小时可用\u0026#34;, \u0026#34;rules\u0026#34;:\u0026#34;全场通用\\\\nApex猎杀无需预约\u0026#34;, \u0026#34;payValue\u0026#34;:1000, \u0026#34;actualValue\u0026#34;:999900, \u0026#34;type\u0026#34;:1, \u0026#34;stock\u0026#34;:200, \u0026#34;beginTime\u0026#34;:\u0026#34;2024-01-01T00:00:00\u0026#34;, \u0026#34;endTime\u0026#34;:\u0026#34;2024-12-31T23:59:59\u0026#34; } 添加成功后，数据库和redis中都能看到优惠券信息 步骤二：编写Lua脚本 lua的字符串拼接使用…，字符串转数字是tonumber() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 -- 订单id local voucherId = ARGV[1] -- 用户id local userId = ARGV[2] -- 优惠券key local stockKey = \u0026#39;seckill:stock:\u0026#39; .. voucherId -- 订单key local orderKey = \u0026#39;seckill:order:\u0026#39; .. voucherId -- 判断库存是否充足 if (tonumber(redis.call(\u0026#39;get\u0026#39;, stockKey)) \u0026lt;= 0) then return 1 end -- 判断用户是否下单 if (redis.call(\u0026#39;sismember\u0026#39;, orderKey, userId) == 1) then return 2 end -- 扣减库存 redis.call(\u0026#39;incrby\u0026#39;, stockKey, -1) -- 将userId存入当前优惠券的set集合 redis.call(\u0026#39;sadd\u0026#39;, orderKey, userId) return 0 修改业务逻辑 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 private static final DefaultRedisScript\u0026lt;Long\u0026gt; SECKILL_SCRIPT; static { SECKILL_SCRIPT=new DefaultRedisScript\u0026lt;\u0026gt;(); SECKILL_SCRIPT.setLocation((org.springframework.core.io.Resource) new ClassPathResource(\u0026#34;seckill.lua\u0026#34;));//读文件 方便后期维护 SECKILL_SCRIPT.setResultType(Long.class); } @Override public Result seckillVoucher(Long voucherId) { //1. 执行lua脚本 Long result = stringRedisTemplate.execute(SECKILL_SCRIPT, Collections.emptyList(), voucherId.toString(), UserHolder.getUser().getId().toString()); //2. 判断返回值，并返回错误信息 if (result.intValue() != 0) { return Result.fail(result.intValue() == 1 ? \u0026#34;库存不足\u0026#34; : \u0026#34;不能重复下单\u0026#34;); } long orderId = redisIdWorker.nextId(\u0026#34;order\u0026#34;); //TODO 保存阻塞队列 //3. 返回订单id return Result.ok(orderId); } 现在我们使用PostMan发送请求，redis中的数据会变动，而且不能重复下单，但是数据库中的数据并没有变化 7.3基于阻塞队列实现秒杀优化 修改下单的操作，我们在下单时，是通过Lua表达式去原子执行判断逻辑，如果判断结果不为0，返回错误信息，如果判断结果为0，则将下单的逻辑保存到队列中去，然后异步执行 需求 1.如果秒杀成功，则将优惠券id和用户id封装后存入阻塞队列 2.开启线程任务，不断从阻塞队列中获取信息，实现异步下单功能 步骤一：创建阻塞队列 阻塞队列有一个特点：当一个线程尝试从阻塞队列里获取元素的时候，如果没有元素，那么该线程就会被阻塞，直到队列中有元素，才会被唤醒，并去获取元素 阻塞队列的创建需要指定一个大小 1 private final BlockingQueue\u0026lt;VoucherOrder\u0026gt; orderTasks = new ArrayBlockingQueue\u0026lt;\u0026gt;(1024 * 1024); 那么把优惠券id和用户id封装后存入阻塞队列 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 private final BlockingQueue\u0026lt;VoucherOrder\u0026gt; orderTasks = new ArrayBlockingQueue\u0026lt;\u0026gt;(1024 * 1024);//阻塞队列 @Override public Result seckillVoucher(Long voucherId) { //1. 执行lua脚本 Long result = stringRedisTemplate.execute(SECKILL_SCRIPT, Collections.emptyList(), voucherId.toString(), UserHolder.getUser().getId().toString()); //2. 判断返回值，并返回错误信息 if (result.intValue() != 0) { //2.1不为0，代表没有购买资格 return Result.fail(result.intValue() == 1 ? \u0026#34;库存不足\u0026#34; : \u0026#34;不能重复下单\u0026#34;); } //2.2.为0,有购买资格,把下单信息保存到阻塞队列 VoucherOrder voucherOrder = new VoucherOrder(); long orderId = redisIdWorker.nextId(\u0026#34;order\u0026#34;); voucherOrder.setId(orderId);//2.2.订单id voucherOrder.setUserId(UserHolder.getUser().getId());//2.3用户id voucherOrder.setVoucherId(voucherId);//2.4代金券id //保存阻塞队列 orderTasks.add(voucherOrder); return Result.ok(orderId); } 步骤二：实现异步下单功能 1.先创建一个线程池 1 private static final ExecutorService SECKILL_ORDER_EXECUTOR = Executors.newSingleThreadExecutor(); 创建线程任务，秒杀业务需要在类初始化之后，就立即执行，所以这里需要用到@PostConstruct注解 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 @PostConstruct private void init() { SECKILL_ORDER_EXECUTOR.submit(new VoucherOrderHandler()); } private class VoucherOrderHandler implements Runnable { @Override public void run() { while (true) { try { //1. 获取队列中的订单信息 VoucherOrder voucherOrder = orderTasks.take(); //2. 创建订单 handleVoucherOrder(voucherOrder); } catch (Exception e) { log.error(\u0026#34;订单处理异常\u0026#34;, e); } } } 查看AopContext源码，它的获取代理对象也是通过ThreadLocal进行获取的，由于我们这里是异步下单，和主线程不是一个线程，所以不能获取成功 1 private static final ThreadLocal\u0026lt;Object\u0026gt; currentProxy = new NamedThreadLocal(\u0026#34;Current AOP proxy\u0026#34;); 但是我们可以将proxy放在成员变量的位置，然后在主线程中获取代理对象 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 private IVoucherOrderService proxy; @Override public Result seckillVoucher(Long voucherId) { //1. 执行lua脚本 Long result = stringRedisTemplate.execute(SECKILL_SCRIPT, Collections.emptyList(), voucherId.toString(), UserHolder.getUser().getId().toString()); //2. 判断返回值，并返回错误信息 if (result.intValue() != 0) { //2.1不为0，代表没有购买资格 return Result.fail(result.intValue() == 1 ? \u0026#34;库存不足\u0026#34; : \u0026#34;不能重复下单\u0026#34;); } //2.2.为0,有购买资格,把下单信息保存到阻塞队列 VoucherOrder voucherOrder = new VoucherOrder(); long orderId = redisIdWorker.nextId(\u0026#34;order\u0026#34;); voucherOrder.setId(orderId);//2.2.订单id voucherOrder.setUserId(UserHolder.getUser().getId());//2.3用户id voucherOrder.setVoucherId(voucherId);//2.4代金券id //保存阻塞队列 orderTasks.add(voucherOrder); //获取代理对象 proxy = (IVoucherOrderService)AopContext.currentProxy(); return Result.ok(orderId); } 完整代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 package com.hmdp.service.impl; import org.springframework.core.io.ClassPathResource; import com.hmdp.dto.Result; import com.hmdp.entity.SeckillVoucher; import com.hmdp.entity.VoucherOrder; import com.hmdp.mapper.VoucherOrderMapper; import com.hmdp.service.ISeckillVoucherService; import com.hmdp.service.IVoucherOrderService; import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl; import com.hmdp.utils.RedisIdWorker; import com.hmdp.utils.SimpleRedisLock; import com.hmdp.utils.UserHolder; import org.redisson.api.RLock; import org.redisson.api.RedissonClient; import org.springframework.aop.framework.AopContext; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.core.io.ResourceLoader; import org.springframework.data.redis.core.RedisTemplate; import org.springframework.data.redis.core.StringRedisTemplate; import org.springframework.data.redis.core.script.DefaultRedisScript; import org.springframework.stereotype.Service; import org.springframework.transaction.annotation.Transactional; import javax.annotation.PostConstruct; import javax.annotation.Resource; import java.time.LocalDateTime; import java.util.Collections; import java.util.concurrent.*; /** * \u0026lt;p\u0026gt; * 服务实现类 * \u0026lt;/p\u0026gt; * * @author 虎哥 * @since 2021-12-22 */ @Service public class VoucherOrderServiceImpl extends ServiceImpl\u0026lt;VoucherOrderMapper, VoucherOrder\u0026gt; implements IVoucherOrderService { @Autowired private ISeckillVoucherService seckillVoucherService; @Autowired private RedisIdWorker redisIdWorker; @Resource private StringRedisTemplate stringRedisTemplate; @Resource private RedissonClient redissonClient; private static final DefaultRedisScript\u0026lt;Long\u0026gt; SECKILL_SCRIPT; static { SECKILL_SCRIPT=new DefaultRedisScript\u0026lt;\u0026gt;(); SECKILL_SCRIPT.setLocation(new ClassPathResource(\u0026#34;seckill.lua\u0026#34;));//读文件 方便后期维护 SECKILL_SCRIPT.setResultType(Long.class); } private final BlockingQueue\u0026lt;VoucherOrder\u0026gt; orderTasks = new ArrayBlockingQueue\u0026lt;\u0026gt;(1024 * 1024);//阻塞队列 private static final ExecutorService SECKILL_ORDER_EXECUTOR = Executors.newSingleThreadExecutor(); @PostConstruct private void init() { SECKILL_ORDER_EXECUTOR.submit(new VoucherOrderHandler()); } private class VoucherOrderHandler implements Runnable { @Override public void run() { while (true) { try { //1. 获取队列中的订单信息 VoucherOrder voucherOrder = orderTasks.take(); //2. 创建订单 handleVoucherOrder(voucherOrder); } catch (Exception e) { log.error(\u0026#34;订单处理异常\u0026#34;, e); } } } private void handleVoucherOrder(VoucherOrder voucherOrder) { //1.获取用户 Long userId = voucherOrder.getUserId(); //2.创建锁对象 //SimpleRedisLock lock = new SimpleRedisLock(\u0026#34;order:\u0026#34; + userId, stringredisTemplate); RLock lock = redissonClient.getLock(\u0026#34;lock:order:\u0026#34; + userId); //3.获取锁 boolean isLock = lock.tryLock(); if (!isLock) { //获取锁失败，返回错误信息，或者重试 log.error(\u0026#34;不允许重复下单\u0026#34;); return; } try { proxy.createVoucherOrder(voucherOrder); }finally { //释放锁 lock.unlock(); } } } private IVoucherOrderService proxy; @Override public Result seckillVoucher(Long voucherId) { //1. 执行lua脚本 Long result = stringRedisTemplate.execute(SECKILL_SCRIPT, Collections.emptyList(), voucherId.toString(), UserHolder.getUser().getId().toString()); //2. 判断返回值，并返回错误信息 if (result.intValue() != 0) { //2.1不为0，代表没有购买资格 return Result.fail(result.intValue() == 1 ? \u0026#34;库存不足\u0026#34; : \u0026#34;不能重复下单\u0026#34;); } //2.2.为0,有购买资格,把下单信息保存到阻塞队列 VoucherOrder voucherOrder = new VoucherOrder(); long orderId = redisIdWorker.nextId(\u0026#34;order\u0026#34;); voucherOrder.setId(orderId);//2.2.订单id voucherOrder.setUserId(UserHolder.getUser().getId());//2.3用户id voucherOrder.setVoucherId(voucherId);//2.4代金券id //保存阻塞队列 orderTasks.add(voucherOrder); //获取代理对象 proxy = (IVoucherOrderService)AopContext.currentProxy(); return Result.ok(orderId); } /* @Override public Result seckillVoucher(Long voucherId) { //1.查询优惠卷 SeckillVoucher vouchar = seckillVoucherService.getById(voucherId); //2.判断秒杀时间是否开始 if (vouchar.getBeginTime().isAfter(LocalDateTime.now())) { //尚未开始 return Result.fail(\u0026#34;秒杀尚未开始\u0026#34;); } //3.判断秒杀时间是否已经结束 if (vouchar.getEndTime().isBefore(LocalDateTime.now())) { //已经结束 return Result.fail(\u0026#34;秒杀已经结束\u0026#34;); } //4.判断库存是否充足 if (vouchar.getStock() \u0026lt; 1) { //库存不足 return Result.fail(\u0026#34;库存不足\u0026#34;); } Long userId = UserHolder.getUser().getId(); //创建锁对象 //SimpleRedisLock lock = new SimpleRedisLock(\u0026#34;order:\u0026#34; + userId, stringredisTemplate); RLock lock = redissonClient.getLock(\u0026#34;lock:order:\u0026#34; + userId); //获取锁 boolean isLock = lock.tryLock(); if (!isLock) { //获取锁失败，返回错误信息，或者重试 return Result.fail(\u0026#34;不允许重复下单\u0026#34;); } try { //获取代理对象 IVoucherOrderService proxy = (IVoucherOrderService)AopContext.currentProxy(); return proxy.createVoucherOrder(voucherId); }finally { //释放锁 lock.unlock(); } } */ @Transactional public void createVoucherOrder (VoucherOrder voucherOrder){ //5.一人一单 Long userId = voucherOrder.getUserId(); //5.1查询订单 int count = query().eq(\u0026#34;user_id\u0026#34;, userId).eq(\u0026#34;voucher_id\u0026#34;, voucherOrder).count(); //5.2判断是否存在 if (count \u0026gt; 0) { //用户已经购买过了 log.error(\u0026#34;用户已经购买过此优惠卷\u0026#34;); return; } //6.扣减库存 boolean success = seckillVoucherService.update() .setSql(\u0026#34;stock=stock-1\u0026#34;)//set stock=stock-1 .eq(\u0026#34;voucher_id\u0026#34;, voucherOrder).gt(\u0026#34;stock\u0026#34;, 0)//where id=?and stock=? .update(); if (!success) { //扣减库存失败 log.error(\u0026#34;库存不足\u0026#34;); return ; } //7.创建订单 save(voucherOrder); } } 7.4小结 秒杀业务的优化思路是什么？——同步下单变异步下单 1.先利用Redis完成库存容量、一人一单的判断，完成抢单业务 2.再将下单业务放入阻塞队列，利用独立线程异步下单 基于阻塞队列的异步秒杀存在哪些问题？ 1.内存限制问题： 我们现在使用的是JDK里的阻塞队列，它使用的是JVM的内存，如果在高并发的条件下，无数的订单都会放在阻塞队列里，可能就会造成内存溢出，所以我们在创建阻塞队列时，设置了一个长度，但是如果真的存满了，再有新的订单来往里塞，那就塞不进去了，存在内存限制问题 2.数据安全问题： 经典服务器宕机了，用户明明下单了，但是数据库里没看到 8.Redis消息队列 8.1认识消息队列 什么是消息队列？字面意思就是存放消息的队列，最简单的消息队列模型包括3个角色 1.消息队列：存储和管理消息，也被称为消息代理（Message Broker） 2.生产者：发送消息到消息队列 3.消费者：从消息队列获取消息并处理消息 使用队列的好处在于解耦：举个例子，快递员(生产者)把快递放到驿站/快递柜里去(Message Queue)去，我们(消费者)从快递柜/驿站去拿快递，这就是一个异步，如果耦合，那么快递员必须亲自上楼把快递递到你手里，服务当然好，但是万一我不在家，快递员就得一直等我，浪费了快递员的时间。所以解耦还是非常有必要的 那么在这种场景下我们的秒杀就变成了：在我们下单之后，利用Redis去进行校验下单的结果，然后在通过队列把消息发送出去，然后在启动一个线程去拿到这个消息，完成解耦，同时也加快我们的响应速度 这里我们可以直接使用一些现成的(MQ)消息队列，如kafka，rabbitmq等，但是如果没有安装MQ，我们也可以使用Redis提供的MQ方案 8.2基于List实现消息队列 基于List结构模拟消息队列 消息队列(Message Queue)，字面意思就是存放消息的队列，而Redis的list数据结构是一个双向链表，很容易模拟出队列的效果 队列的入口和出口不在同一边，所以我们可以利用：LPUSH结合RPOP或者RPUSH结合LPOP来实现消息队列。 不过需要注意的是，当队列中没有消息时，RPOP和LPOP操作会返回NULL，而不像JVM阻塞队列那样会阻塞，并等待消息，所以我们这里应该使用BRPOP或者BLPOP来实现阻塞效果 基于List的消息队列有哪些优缺点？ 优点 1.利用Redis存储，不受限于JVM内存上限 2.基于Redis的持久化机制，数据安全性有保障 3.可以满足消息有序性 （先进先出） 缺点 1.无法避免消息丢失(经典服务器宕机) 2.只支持单消费者(一个消费者把消息拿走了，其他消费者就看不到这条消息了) 8.3基于PubSub的消息队列 PubSub(发布订阅)是Redis2.0版本引入的消息传递模型。顾名思义，消费和可以订阅一个或多个channel，生产者向对应channel发送消息后，所有订阅者都能收到相关消息 SUBSCRIBE channel [channel]：订阅一个或多个频道 PUBLISH channel msg：向一个频道发送消息 PSUBSCRIBE pattern [pattern]：订阅与pattern格式匹配的所有频道 Subscribes the client to the given patterns. Supported glob-style patterns:\nh?flo subscribes to hello, hallo and hxllo h*llo subscribes to hllo and heeeello h[ae]llo subscribes to hello and hallo, but not hillo Use \\ to escape special characters if you want to match them verbatim. 基于PubSub的消息队列有哪些优缺点 优点： 采用发布订阅模型，支持多生产，多消费 缺点： 1.不支持数据持久化 2.无法避免消息丢失（如果向频道发送了消息，却没有人订阅该频道，那发送的这条消息就丢失了） 3.消息堆积有上限，空间有限超出时数据丢失（消费者拿到数据的时候处理的太慢，而发送消息发的太快） 8.4基于Stream的消息队列 Stream是Redis 5.0引入的一种新数据类型，可以时间一个功能非常完善的消息队列 要注意，如果想使用Stream消息队列必须把Redis的版本上升到5.0之后。 8.4.1Stream的单消费模式 STREAM类型消息队列的XREAD命令特点： 1.消息可回溯。 2.一个消息可以被多个消费者读取。 3.可以阻塞读取。 4.有消息漏读风险。 8.4.2Stream的消费组模式 消费者组（Consumer Group）：将多个消费者划分到一个组中，监听同一个队列。消费者之间是竞争关系。 1.消息分流：队列中的消息会分流给组内不同消费者，而不是重复消费，从而加快消息处理的速度。 2.消息标示：消费者组会维护一个标示（类似于标签，记录读到哪里了），记录最后一个被处理的消息，哪怕消费者宕机重启，还会从标示之后读取消息，确保每一个消息都会被消费。 3.消息确认（解决消息丢失问题）：消费者获取消息后，消息处于pending状态，并存入一个pending-list。当处理完成后需要通过XACK来确认消息，标记消息为已处理，才会从pending-list移除。 STREAM类型消息队列的XREADGROUP命令的特点 1.消息可回溯 2.可以多消费者争抢消息，加快消费速度 避免出现消息堆积 3.可以阻塞读取 4.没有消息漏读风险 5.有消息确认机制，保证消息至少被消费一次 ack List PubSub Stream 消息持久化 支持 不支持 支持 阻塞读取 支持 支持 支持 消息堆积处理 受限于内存空间，可以利用多消费者加快处理 受限于消费者缓冲区 受限于队列长度，可以利用消费者组提高消费速度，减少堆积 消息确认机制 不支持 不支持 支持 消息回溯 不支持 不支持 支持 8.5基于Stream消息队列实现异步秒杀 需求： 1.创建一个Stream类型的消息队列，名为stream.orders 2.修改之前的秒杀下单Lua脚本，在认定有抢购资格后，直接向stream.orders中添加消息，内容包含voucherId、userId、orderId 3.项目启动时，开启一个线程任务，尝试获取stream.orders中的消息，完成下单 步骤一：创建一个Stream类型的消息队列，名为stream.orders 1 XGROUP CREATE stream.orders g1 0 MKSTREAM 步骤二：修改Lua脚本，新增orderId参数，并将订单信息加入到消息队列中 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 --1.参数列表 local voucherId = ARGV[1] -- 优惠券ID local userId = ARGV[2] -- 用户ID local orderId = ARGV[3] -- 订单ID --2.数据key local stockKey = \u0026#39;seckill:stock:\u0026#39; .. voucherId -- 库存key local orderKey = \u0026#39;seckill:order:\u0026#39; .. voucherId -- 订单key --3.脚本业务 --3.1.判断库存是否充足 get stockKey local stock = redis.call(\u0026#39;get\u0026#39;, stockKey) if not stock or tonumber(stock) \u0026lt;= 0 then return 1 -- 库存不足 end --3.2.判断用户是否下单 SISMEMBER orderKey userId if redis.call(\u0026#39;sismember\u0026#39;, orderKey, userId) == 1 then return 2 -- 重复下单 end --3.3.扣库存 incrby stockKey -1 redis.call(\u0026#39;incrby\u0026#39;, stockKey, -1) --3.4.下单 sadd orderKey userId redis.call(\u0026#39;sadd\u0026#39;, orderKey, userId) --3.5.发送消息到队列中 XADD stream.orders * k1 v1 k2 v2 redis.call(\u0026#39;xadd\u0026#39;, \u0026#39;stream.orders\u0026#39;, \u0026#39;*\u0026#39;, \u0026#39;userId\u0026#39;, userId, \u0026#39;voucherId\u0026#39;, voucherId, \u0026#39;orderId\u0026#39;, orderId) return 0 -- 成功 步骤三：修改秒杀逻辑 由于将下单数据加入到消息队列的功能，我们在Lua脚本中实现了，所以这里就不需要将下单数据加入到JVM的阻塞队列中去了，同时Lua脚本中我们新增了一个参数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 private IVoucherOrderService proxy; @Override public Result seckillVoucher(Long voucherId) { //获取用户 Long userId = UserHolder.getUser().getId(); long orderId = redisIdWorker.nextId(\u0026#34;order\u0026#34;);//订单id //1. 执行lua脚本 Long result = stringRedisTemplate.execute(SECKILL_SCRIPT, Collections.emptyList(), voucherId.toString(), userId.toString(),String.valueOf(orderId)); //2. 判断返回值，并返回错误信息 if (result.intValue() != 0) { //2.1不为0，代表没有购买资格 return Result.fail(result.intValue() == 1 ? \u0026#34;库存不足\u0026#34; : \u0026#34;不能重复下单\u0026#34;); } //获取代理对象 proxy = (IVoucherOrderService)AopContext.currentProxy(); return Result.ok(orderId); } 根据上面思路来修改我们的VoucherOrderHandler 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 private class VoucherOrderHandler implements Runnable { String queueName=\u0026#34;stream.orders\u0026#34;; @Override public void run() { while (true) { try { //1. 获取消息队列中的订单信息，READGROUP GROUP g1 c1 COUNT 1 BLOCK 2000 STREAMS stream.orders 0 List\u0026lt;MapRecord\u0026lt;String, Object, Object\u0026gt;\u0026gt; list = stringRedisTemplate.opsForStream().read( Consumer.from(\u0026#34;g1\u0026#34;, \u0026#34;c1\u0026#34;), StreamReadOptions.empty().count(1).block(Duration.ofSeconds(2)), //ReadOffset.lastConsumed()底层就是 \u0026#39;\u0026gt;\u0026#39; StreamOffset.create(queueName, ReadOffset.lastConsumed())); //2. 判断消息获取是否成功 if (list==null||list.isEmpty()) { //如果获取失败，说明没有消息，继续下一次循环 continue; } //3. 解析消息中的订单信息 MapRecord\u0026lt;String, Object, Object\u0026gt; record = list.get(0); Map\u0026lt;Object, Object\u0026gt; values = record.getValue(); VoucherOrder voucherOrder = BeanUtil.fillBeanWithMap(values, new VoucherOrder(), true); //4.成功获取到订单则，可以下单 handleVoucherOrder(voucherOrder); //5.ACK确认，SACK stream g1 c1 stringRedisTemplate.opsForStream().acknowledge(queueName,\u0026#34;g1\u0026#34;,record.getId()); } catch (Exception e) { log.error(\u0026#34;订单处理异常\u0026#34;, e); handlePendlinglist(); } } } private void handlePendlinglist() { while (true) { try { //1. 获取消息队列中的订单信息，READGROUP GROUP g1 c1 COUNT 1 BLOCK 2000 STREAMS stream.orders 0 List\u0026lt;MapRecord\u0026lt;String, Object, Object\u0026gt;\u0026gt; list = stringRedisTemplate.opsForStream().read( Consumer.from(\u0026#34;g1\u0026#34;, \u0026#34;c1\u0026#34;), StreamReadOptions.empty().count(1).block(Duration.ofSeconds(2)), //ReadOffset.lastConsumed()底层就是 \u0026#39;\u0026gt;\u0026#39; StreamOffset.create(queueName, ReadOffset.from(\u0026#34;0\u0026#34;))); //2. 判断消息获取是否成功 if (list==null||list.isEmpty()) { //如果获取失败，说明Pendling-list没有消息，结束循环 break; } //3. 解析消息中的订单信息 MapRecord\u0026lt;String, Object, Object\u0026gt; record = list.get(0); Map\u0026lt;Object, Object\u0026gt; values = record.getValue(); VoucherOrder voucherOrder = BeanUtil.fillBeanWithMap(values, new VoucherOrder(), true); //4.成功获取到订单则，可以下单 handleVoucherOrder(voucherOrder); //5.ACK确认，SACK stream g1 c1 stringRedisTemplate.opsForStream().acknowledge(queueName,\u0026#34;g1\u0026#34;,record.getId()); } catch (Exception e) { log.error(\u0026#34;处理Pendling-list异常\u0026#34;, e); try { Thread.sleep(20); } catch (InterruptedException ex) { throw new RuntimeException(ex); } } } } } 8.6可以通过RabbitMQ实现消息队列 9.达人探店 9.1发布探店笔记 数据库表这里就不展示了哈 大家自己去看看有哪些字段就好了 对应的实体类，数据表中并没有用户头像和用户昵称，但是对应的实体类里却有，这是因为使用了@TableField(exist = false) 用来解决实体类中有的属性但是数据表中没有的字段 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 @Data @EqualsAndHashCode(callSuper = false) @Accessors(chain = true) @TableName(\u0026#34;tb_blog\u0026#34;) public class Blog implements Serializable { private static final long serialVersionUID = 1L; /** * 主键 */ @TableId(value = \u0026#34;id\u0026#34;, type = IdType.AUTO) private Long id; /** * 商户id */ private Long shopId; /** * 用户id */ private Long userId; /** * 用户图标 */ @TableField(exist = false) private String icon; /** * 用户姓名 */ @TableField(exist = false) private String name; /** * 是否点赞过了 */ @TableField(exist = false) private Boolean isLike; /** * 标题 */ private String title; /** * 探店的照片，最多9张，多张以\u0026#34;,\u0026#34;隔开 */ private String images; /** * 探店的文字描述 */ private String content; /** * 点赞数量 */ private Integer liked; /** * 评论数量 */ private Integer comments; /** * 创建时间 */ private LocalDateTime createTime; /** * 更新时间 */ private LocalDateTime updateTime; } 上传相关代码： 1 2 3 4 5 6 7 8 9 10 @PostMapping public Result saveBlog(@RequestBody Blog blog) { // 获取登录用户 UserDTO user = UserHolder.getUser(); blog.setUserId(user.getId()); // 保存探店博文 blogService.save(blog); // 返回id return Result.ok(blog.getId()); } 上传图片代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 @PostMapping(\u0026#34;blog\u0026#34;) public Result uploadImage(@RequestParam(\u0026#34;file\u0026#34;) MultipartFile image) { try { // 获取原始文件名称 String originalFilename = image.getOriginalFilename(); // 生成新文件名 String fileName = createNewFileName(originalFilename); // 保存文件 image.transferTo(new File(SystemConstants.IMAGE_UPLOAD_DIR, fileName)); // 返回结果 log.debug(\u0026#34;文件上传成功，{}\u0026#34;, fileName); return Result.ok(fileName); } catch (IOException e) { throw new RuntimeException(\u0026#34;文件上传失败\u0026#34;, e); } } 注意：这里我们需要修改SystemConstants.IMAGE_UPLOAD_DIR 为自己图片所在的地址，在实际开发中图片一般会放在nginx上或者是云存储上。\n9.2查看探店笔记 需求：点击首页的探店笔记，会进入详情页面，我们现在需要实现页面的查询接口 随便点击一张图片，查看发送的请求 请求网址: http://localhost:8080/api/blog/6\n请求方法: GET\n看样子是BlogController下的方法，请求方式为GET，那我们直接来编写对应的方法 1 2 3 4 @GetMapping(\u0026#34;/{id}\u0026#34;) public Result queryById(@PathVariable Integer id){ return blogService.queryById(id); } 在Service类中创建对应方法之后，在Impl类中实现，我们查看用户探店笔记的时候，需要额外设置用户名和其头像，由于设置用户信息这个操作比较通用，所以这里封装成了一个方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 @Override public Result queryBlogById(Long id) { //1.查询blog Blog blog = getById(id); if (blog == null) { return Result.fail(\u0026#34;笔记不存在\u0026#34;); } //2.查询blog相关用户 queryBlogUser(blog); return Result.ok(blog); } private void queryBlogUser(Blog blog) { Long userId = blog.getUserId(); User user = userService.getById(userId); blog.setName(user.getNickName()); blog.setIcon(user.getIcon()); } 我们将queryHotBlog也修改一下，原始代码将业务逻辑写到了Controller中，修改后的完整代码如下 1 2 3 4 @GetMapping(\u0026#34;/hot\u0026#34;) public Result queryHotBlog(@RequestParam(value = \u0026#34;current\u0026#34;, defaultValue = \u0026#34;1\u0026#34;) Integer current) { return blogService.queryHotBlog(current); } 在Service类中创建相关业务逻辑对应方法之后，在Impl类中实现 1 2 3 4 5 6 7 8 9 10 11 12 @Override public Result queryHotBlog(Integer current) { // 根据用户查询 Page\u0026lt;Blog\u0026gt; page = query() .orderByDesc(\u0026#34;liked\u0026#34;) .page(new Page\u0026lt;\u0026gt;(current, SystemConstants.MAX_PAGE_SIZE)); // 获取当前页数据 List\u0026lt;Blog\u0026gt; records = page.getRecords(); // 查询用户 records.forEach(this::queryBlogUser); return Result.ok(records); } 9.3点赞功能 点击点赞按钮，查看发送的请求 请求网址: http://localhost:8080/api/blog/like/4\n请求方法: PUT\nBlogController中的like方法 1 2 3 4 5 6 7 @PutMapping(\u0026#34;/like/{id}\u0026#34;) public Result likeBlog(@PathVariable(\u0026#34;id\u0026#34;) Long id) { // 修改点赞数量 blogService.update() .setSql(\u0026#34;liked = liked + 1\u0026#34;).eq(\u0026#34;id\u0026#34;, id).update(); return Result.ok(); } 问题分析：这种方式会导致一个用户无限点赞，明显是不合理的 造成这个问题的原因是，我们现在的逻辑，发起请求只是给数据库+1，所以才会出现这个问题 需求 1.同一个用户只能对同一篇笔记点赞一次，再次点击则取消点赞 2.如果当前用户已经点赞，则点赞按钮高亮显示（前端已实现，判断字段Blog类的isLike属性） 实现步骤 1.修改点赞功能，利用Redis中的set集合来判断是否点赞过，未点赞则点赞数+1，已点赞则点赞数-1 2.修改根据id查询的业务，判断当前登录用户是否点赞过，赋值给isLike字段 3.修改分页查询Blog业务，判断当前登录用户是否点赞过，赋值给isLike字段 具体实现 Controller 1 2 3 4 @PutMapping(\u0026#34;/like/{id}\u0026#34;) public Result likeBlog(@PathVariable(\u0026#34;id\u0026#34;) Long id) { return blogService.likeBlog(id); } Service 修改查询Blog业务，判断Blog是否被当前用户点赞过 判断本用户是否点赞这条blog 1 2 3 4 5 6 7 8 9 10 11 12 /** * 判断本用户是否点赞这条blog * @param blog */ private void isBlogLiked(Blog blog) { //1. 获取当前用户信息 Long userId = UserHolder.getUser().getId(); //2. 如果当前用户未点赞，则点赞数 +1，同时将用户加入set集合 String key = BLOG_LIKED_KEY + blog.getId(); Boolean isMember = stringRedisTemplate.opsForSet().isMember(key, userId.toString()); blog.setIsLike(BooleanUtil.isTrue(isMember)); } 点赞逻辑以及取消点赞逻辑 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 /** * 实现点赞逻辑以及取消点赞逻辑 * @param id * @return */ @Override public Result likeBlog(Long id) { //1. 获取当前用户信息 Long userId = UserHolder.getUser().getId(); //2. 如果当前用户未点赞，则点赞数 +1，同时将用户加入set集合 String key = BLOG_LIKED_KEY + id; Boolean isLiked = stringRedisTemplate.opsForSet().isMember(key, userId.toString()); if (BooleanUtil.isFalse(isLiked)) { //点赞数 +1 boolean success = update().setSql(\u0026#34;liked = liked + 1\u0026#34;).eq(\u0026#34;id\u0026#34;, id).update(); //将用户加入set集合 if (success) { stringRedisTemplate.opsForSet().add(key, userId.toString()); } //3. 如果当前用户已点赞，则取消点赞，将用户从set集合中移除 }else { //点赞数 -1 boolean success = update().setSql(\u0026#34;liked = liked - 1\u0026#34;).eq(\u0026#34;id\u0026#34;, id).update(); if (success){ //从set集合移除 stringRedisTemplate.opsForSet().remove(key, userId.toString()); } } return Result.ok(); } 点赞逻辑以及取消点赞逻辑 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 /** * 实现显示博客信息以及点赞信息 * @param current * @return */ @Override public Result queryHotBlog(Integer current) { // 根据用户查询 Page\u0026lt;Blog\u0026gt; page = query() .orderByDesc(\u0026#34;liked\u0026#34;) .page(new Page\u0026lt;\u0026gt;(current, SystemConstants.MAX_PAGE_SIZE)); // 获取当前页数据 List\u0026lt;Blog\u0026gt; records = page.getRecords(); // 查询用户 + records.forEach(blog -\u0026gt; { + this.queryBlogUser(blog); + this.isBlogLiked(blog); + }); return Result.ok(records); } 9.4点赞排行榜 当我们点击探店笔记详情页面时，应该按点赞顺序展示点赞用户，比如显示最早点赞的TOP5，形成点赞排行榜，就跟QQ空间发的说说一样，可以看到有哪些人点了赞 之前的点赞是放到Set集合中，但是Set集合又不能排序，所以这个时候，我们就可以改用SortedSet(Zset) 修改BlogServiceImpl 由于ZSet没有isMember方法，所以这里只能通过查询score来判断集合中是否有该元素，如果有该元素，则返回值是对应的score，如果没有该元素，则返回值为null 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 /** * 实现点赞逻辑以及取消点赞逻辑 * @param id * @return */ @Override public Result likeBlog(Long id) { //1. 获取当前用户信息 Long userId = UserHolder.getUser().getId(); //2. 如果当前用户未点赞，则点赞数 +1，同时将用户加入set集合 String key = BLOG_LIKED_KEY + id; Double score = stringRedisTemplate.opsForZSet().score(key, userId.toString()); if (score == null) { //点赞数 +1 boolean success = update().setSql(\u0026#34;liked = liked + 1\u0026#34;).eq(\u0026#34;id\u0026#34;, id).update(); //将用户加入set集合 if (success) { stringRedisTemplate.opsForZSet().add(key, userId.toString(),System.currentTimeMillis()); } //3. 如果当前用户已点赞，则取消点赞，将用户从set集合中移除 }else { //点赞数 -1 boolean success = update().setSql(\u0026#34;liked = liked - 1\u0026#34;).eq(\u0026#34;id\u0026#34;, id).update(); if (success){ //从set集合移除 stringRedisTemplate.opsForZSet().remove(key, userId.toString()); } } return Result.ok(); } 同时修改isBlogLiked方法，在原有逻辑上，判断用户是否已登录，登录状态下才会继续判断用户是否点赞 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 /** * 判断本用户是否点赞这条blog * @param blog */ private void isBlogLiked(Blog blog) { //1. 获取当前用户信息 UserDTO userDTO = UserHolder.getUser(); //当用户未登录时，就不判断了，直接return结束逻辑 if (userDTO == null) { return; } //2. 判断当前用户是否点赞 String key = BLOG_LIKED_KEY + blog.getId(); Double score = stringRedisTemplate.opsForZSet().score(key, userDTO.getId().toString()); blog.setIsLike(score != null); } 继续来完善显示点赞列表功能，查看浏览器请求，这个请求目前应该是404的，因为我们还没有写，他需要一个list返回值，显示top5点赞的用户 请求网址: http://localhost:8080/api/blog/likes/4\n请求方法: GET\n在Controller层中编写对应的方法，点赞查询列表 1 2 3 4 @GetMapping(\u0026#34;/likes/{id}\u0026#34;) public Result queryBlogLikes(@PathVariable(\u0026#34;id\u0026#34;)Long id) { return blogService.queryBlogLikes(id); } 具体逻辑写到BlogServiceImpl中 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 /** * 实现查询点赞top5的用户 * @param id * @return */ @Override public Result queryBlogLikes(Long id) { String key = BLOG_LIKED_KEY + id; //1.zrange key 0 4 查询zset中前5个元素 Set\u0026lt;String\u0026gt; top5 = stringRedisTemplate.opsForZSet().range(key, 0, 4); //如果是空的(可能没人点赞)，直接返回一个空集合 if (top5 == null || top5.isEmpty()) { return Result.ok(Collections.emptyList()); } List\u0026lt;Long\u0026gt; ids = top5.stream().map(Long::valueOf).collect(Collectors.toList()); //将ids使用`,`拼接，SQL语句查询出来的结果并不是按照我们期望的方式进行排 //所以我们需要用order by field来指定排序方式，期望的排序方式就是按照查询出来的id进行排序 String idsStr = StrUtil.join(\u0026#34;,\u0026#34;, ids); //select * from tb_user where id in (ids[0], ids[1] ...) order by field(id, ids[0], ids[1] ...) List\u0026lt;UserDTO\u0026gt; userDTOS = userService.query().in(\u0026#34;id\u0026#34;, ids) .last(\u0026#34;order by field(id,\u0026#34; + idsStr + \u0026#34;)\u0026#34;) .list().stream() .map(user -\u0026gt; BeanUtil.copyProperties(user, UserDTO.class)) .collect(Collectors.toList()); return Result.ok(userDTOS); } 10好友关注 10.1关注和取消关注 当我们进入到笔记详情页面时，会发送一个请求，判断当前登录用户是否关注了笔记博主 请求网址: http://localhost:8080/api/follow/or/not/2\n请求方法: GET\n当我们点击关注按钮时，会发送一个请求，实现关注/取关 请求网址: http://localhost:8080/api/follow/2/true\n请求方法: PUT\n同样的数据库表和user实体类 这里就不放了 大家自己去看下吧 我们直接来实现代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 @RestController @RequestMapping(\u0026#34;/follow\u0026#34;) public class FollowController { @Resource private IFollowService followService; //判断当前用户是否关注了该博主 @GetMapping(\u0026#34;/or/not/{id}\u0026#34;) public Result isFollow(@PathVariable(\u0026#34;id\u0026#34;) Long followUserId) { return followService.isFollow(followUserId); } //实现取关/关注 @PutMapping(\u0026#34;/{id}/{isFollow}\u0026#34;) public Result follow(@PathVariable(\u0026#34;id\u0026#34;) Long followUserId, @PathVariable(\u0026#34;isFollow\u0026#34;) Boolean isFellow) { return followService.follow(followUserId,isFellow); } } 再实现相关方法 isFollow 1 2 3 4 5 6 7 8 9 10 11 12 13 14 /** * 判断是关注还是取消关注 * @param followUserId * @return */ @Override public Result isFollow(Long followUserId) { //获取登录用户 Long userId = UserHolder.getUser().getId(); //查询是否关注 Integer count = query().eq(\u0026#34;user_id\u0026#34;, userId).eq(\u0026#34;follow_user_id\u0026#34;, followUserId).count(); //判断并返回 return Result.ok(count\u0026gt;0); } follow 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 /** * 实现关注取关逻辑 * @param followUserId * @param isFellow * @return */ @Override public Result follow(Long followUserId, Boolean isFellow) { //获取当前用户id Long userId = UserHolder.getUser().getId(); //判断是否关注 if (isFellow) { //关注，则将信息保存到数据库 Follow follow = new Follow(); follow.setUserId(userId); follow.setFollowUserId(followUserId); save(follow); } else { //取关，则将数据从数据库中移除 remove(new QueryWrapper\u0026lt;Follow\u0026gt;() .eq(\u0026#34;user_id\u0026#34;, userId).eq(\u0026#34;follow_user_id\u0026#34;, followUserId)); } return Result.ok(); } 10.2共同关注 点击用户头像，进入到用户详情页，可以查看用户发布的笔记，和共同关注列表 但现在我们还没写具体的业务逻辑，所以现在暂时看不到数据 网络选项卡，查看发送的请求 查询用户信息 请求网址: http://localhost:8080/api/user/2\n请求方法: GET\n查看共同关注 请求网址: http://localhost:8080/api/follow/common/undefined\n请求方法: GET\n编写查询用户信息方法UserController 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 /** * 查看用户详情 * @param userId * @return */ @GetMapping(\u0026#34;/{id}\u0026#34;) public Result queryById(@PathVariable(\u0026#34;id\u0026#34;) Long userId) { // 查询详情 User user = userService.getById(userId); if (user == null) { // 没有详情，应该是第一次查看详情 return Result.ok(); } UserDTO userDTO = BeanUtil.copyProperties(user, UserDTO.class); // 返回 return Result.ok(userDTO); } 编写查询用户笔记方法BlogController 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 /** * 根据id查询博主的探店笔记 * @param current * @param id * @return */ @GetMapping(\u0026#34;/of/user\u0026#34;) public Result queryBlogByUserId( @RequestParam(value = \u0026#34;current\u0026#34;, defaultValue = \u0026#34;1\u0026#34;) Integer current, @RequestParam(\u0026#34;id\u0026#34;) Long id) { // 根据用户查询 Page\u0026lt;Blog\u0026gt; page = blogService.query() .eq(\u0026#34;user_id\u0026#34;, id).page(new Page\u0026lt;\u0026gt;(current, SystemConstants.MAX_PAGE_SIZE)); // 获取当前页数据 List\u0026lt;Blog\u0026gt; records = page.getRecords(); return Result.ok(records); } 如何实现共同关注 需求：利用Redis中恰当的数据结构，实现共同关注功能，在博主个人页面展示出当前用户与博主的共同关注\n实现方式当然是我们之前学过的set集合，在set集合中，有交集并集补集的api，可以把二者关注的人放入到set集合中，然后通过api查询两个set集合的交集 那我们就得先修改我们之前的关注逻辑，在关注博主的同时，需要将数据放到set集合中，方便后期我们实现共同关注，当取消关注时，也需要将数据从set集合中删除 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 /** * 实现关注取关逻辑 * @param followUserId * @param isFellow * @return */ @Override public Result follow(Long followUserId, Boolean isFellow) { //获取当前用户id Long userId = UserHolder.getUser().getId(); String key = \u0026#34;follows:\u0026#34; + userId; //判断是否关注 if (isFellow) { //关注，则将信息保存到数据库 Follow follow = new Follow(); follow.setUserId(userId); follow.setFollowUserId(followUserId); boolean isSuccess = save(follow); if (isSuccess) { //把关注用户的id放入redis的set几个 stringRedisTemplate.opsForSet().add(key,followUserId.toString()); } } else { //取关，则将数据从数据库中移除 boolean isSuccess = remove(new QueryWrapper\u0026lt;Follow\u0026gt;() .eq(\u0026#34;user_id\u0026#34;, userId).eq(\u0026#34;follow_user_id\u0026#34;, followUserId)); if (isSuccess) { //把关注用户的id从redis集合中移除 stringRedisTemplate.opsForSet().remove(key, followUserId.toString()); } } return Result.ok(); } 那么接下来，我们实现共同关注代码 FollowController 1 2 3 4 5 //实现共同关注代码 @GetMapping(\u0026#34;/common/{id}\u0026#34;) public Result followCommons(@PathVariable Long id){ return followService.followCommons(id); } FollowController 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 /** * 查询得到共同关注 * @param id * @return */ @Override public Result followCommons(Long id) { //求的是目标用户和当前用户关注的交集 //1.获取key Long userId = UserHolder.getUser().getId(); String key1 = \u0026#34;follows:\u0026#34;+userId; String key2 = \u0026#34;follows:\u0026#34;+id; //2.求交集 Set\u0026lt;String\u0026gt; intersect = stringRedisTemplate.opsForSet().intersect(key1, key2); if(intersect==null||intersect.isEmpty()){ return Result.ok(Collections.emptyList()); } //3.解析id集合 List\u0026lt;Long\u0026gt; ids = intersect.stream().map(Long::valueOf).collect(Collectors.toList()); //4.查询用户 List\u0026lt;UserDTO\u0026gt; users = userService.listByIds(ids) .stream() .map(user -\u0026gt; BeanUtil.copyProperties(user, UserDTO.class)) .collect(Collectors.toList()); return Result.ok(users); } 10.3Feed流实现方案 10.3.1相关介绍 当我们关注了用户之后，这个用户发布了动态，那我们应该把这些数据推送给用户，这个需求，我们又称其为Feed流，关注推送也叫作Feed流，直译为投喂，为用户提供沉浸式体验，通过无限下拉刷新获取新的信息， 对于传统的模式内容检索：用户需要主动通过搜索引擎或者是其他方式去查找想看的内容 对于新型Feed流的效果：系统分析用户到底想看什么，然后直接把内容推送给用户，从而使用户能更加节约时间，不用去主动搜素 Feed流的实现有两种模式 1.Timeline：不做内容筛选，简单的按照内容发布时间排序，常用于好友或关注(B站关注的up，朋友圈等) 优点：信息全面，不会有缺失，并且实现也相对简单 缺点：信息噪音较多，用户不一定感兴趣，内容获取效率低 2.智能排序：利用智能算法屏蔽掉违规的、用户不感兴趣的内容，推送用户感兴趣的信息来吸引用户 优点：投喂用户感兴趣的信息，用户粘度很高，容易沉迷 缺点：如果算法不精准，可能会起到反作用（给你推的你都不爱看） 那我们这里针对好友的操作，采用的是Timeline方式，只需要拿到我们关注用户的信息，然后按照时间排序即可 采用Timeline模式，有三种具体的实现方案 拉模式 推模式 推拉结合 拉模式：也叫读扩散 该模式的核心含义是：当张三和李四、王五发了消息之后，都会保存到自己的发件箱中，如果赵六要读取消息，那么他会读取他自己的收件箱，此时系统会从他关注的人群中，将他关注人的信息全都进行拉取，然后进行排序 优点：比较节约空间，因为赵六在读取信息时，并没有重复读取，并且读取完之后，可以将他的收件箱清除 缺点：有延迟，当用户读取数据时，才会去关注的人的时发件箱中拉取信息，假设该用户关注了海量用户，那么此时就会拉取很多信息，对服务器压力巨大 推模式：也叫写扩散 推模式是没有写邮箱的，当张三写了一个内容，此时会主动把张三写的内容发送到它粉丝的收件箱中，假设此时李四再来读取，就不用再去临时拉取了 优点：时效快，不用临时拉取 缺点：内存压力大，假设一个大V发了一个动态，很多人关注他，那么就会写很多份数据到粉丝那边去 推拉结合：页脚读写混合，兼具推和拉两种模式的优点 推拉模式是一个折中的方案，站在发件人这一边，如果是普通人，那么我们采用写扩散的方式，直接把数据写入到他的粉丝收件箱中，因为普通人的粉丝数量较少，所以这样不会产生太大压力。但如果是大V，那么他是直接将数据写入一份到发件箱中去，在直接写一份到活跃粉丝的收件箱中，站在收件人这边来看，如果是活跃粉丝，那么大V和普通人发的都会写到自己的收件箱里，但如果是普通粉丝，由于上线不是很频繁，所以等他们上线的时候，再从发件箱中去拉取信息。 10.3.2推送到粉丝收件箱 需求： 1.修改新增探店笔记的业务，在保存blog到数据库的同时，推送到粉丝的收件箱 2.收件箱满足可以根据时间戳排序，必须使用Redis的数据结构实现 3.查询收件箱数据时，可实现分页查询 Feed流中的数据会不断更新，所以数据的角标也会不断变化，所以我们不能使用传统的分页模式 假设在t1时刻，我们取读取第一页，此时page = 1，size = 5，那么我们拿到的就是106这几条记录，假设t2时刻有发布了一条新纪录，那么在t3时刻，我们来读取第二页，此时page = 2，size = 5，那么此时读取的数据是从6开始的，读到的是62，那么我们就读到了重复的数据，所以我们要使用Feed流的分页，不能使用传统的分页 Feed流的滚动分页 我们需要记录每次操作的最后一条，然后从这个位置去开始读数据 举个例子：我们从t1时刻开始，拿到第一页数据，拿到了106，然后记录下当前最后一次读取的记录，就是6，t2时刻发布了新纪录，此时这个11在最上面，但不会影响我们之前拿到的6，此时t3时刻来读取第二页，第二页读数据的时候，从6-1=5开始读，这样就拿到了51的记录。我们在这个地方可以使用SortedSet来做，使用时间戳来充当表中的1~10 核心思路：我们保存完探店笔记后，获取当前用户的粉丝列表，然后将数据推送给粉丝 那现在我们就需要修改保存笔记的方法 BlogController 1 2 3 4 @PostMapping public Result saveBlog(@RequestBody Blog blog) { return blogService.saveBlog(blog); } BlogServiceImpl 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 /** * 保存探店笔记后推送给粉丝 * @param blog * @return */ @Override public Result saveBlog(Blog blog) { //1.获取登录用户 UserDTO user = UserHolder.getUser(); blog.setUserId(user.getId()); //2.保存探店笔记 boolean isSuccess = save(blog); if(!isSuccess){ return Result.fail(\u0026#34;新增笔记失败！\u0026#34;); } //3.查询笔记作业的所有粉丝 //select * from tb_follow where follow_user_id = ? List\u0026lt;Follow\u0026gt; follows = followService.query().eq(\u0026#34;follow_user_id\u0026#34;, user.getId()).list(); //4.推送笔记id给粉丝 for(Follow follow : follows){ //4.1.获取粉丝id Long userId = follow.getUserId(); //4.2.推送到粉丝收件箱是sortedSet String key = \u0026#34;feed::\u0026#34;+userId; stringRedisTemplate.opsForZSet().add(key,blog.getId().toString(),System.currentTimeMillis()); } //返回id return Result.ok(blog.getId()); } 10.3.3实现分页查询收件箱 需求：在个人主页的关注栏中，查询并展示推送的Blog信息 具体步骤如下 1.每次查询完成之后，我们要分析出查询出的最小时间戳，这个值会作为下一次的查询条件 2.我们需要找到与上一次查询相同的查询个数，并作为偏移量，下次查询的时候，跳过这些查询过的数据，拿到我们需要的数据（例如时间戳8 6 6 5 5 4，我们每次查询3个，第一次是8 6 6，此时最小时间戳是6，如果不设置偏移量，会从第一个6之后开始查询，那么查询到的就是6 5 5，而不是5 5 4，如果这里说的不清楚，那就看后续的代码） 综上：我们的请求参数中需要携带lastId和offset，即上一次查询时的最小时间戳和偏移量，这两个参数 编写一个通用的实体类，不一定只对blog进行分页查询，这里用泛型做一个通用的分页查询，list是封装返回的结果，minTime是记录的最小时间戳，offset是记录偏移量 1 2 3 4 5 6 @Data public class ScrollResult { private List\u0026lt;?\u0026gt; list; private Long minTime; private Integer offset; } 点击个人主页中的关注栏，查看发送的请求 请求网址: http://localhost:8080/api/blog/of/follow?\u0026amp;lastId=1667472294526\n请求方法: GET\n在BlogController中创建对应的方法，具体实现去ServiceImpl中完成 1 2 3 4 @GetMapping(\u0026#34;/of/follow\u0026#34;) public Result queryBlogOfFollow(@RequestParam(\u0026#34;lastId\u0026#34;) Long max, @RequestParam(value = \u0026#34;offset\u0026#34;,defaultValue = \u0026#34;0\u0026#34;) Integer offset) { return blogService.queryBlogOfFollow(max,offset); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 /** * 分页显示收件箱笔记 * @param max * @param offset * @return */ @Override public Result queryBlogOfFollow(Long max, Integer offset) { //1. 获取当前用户 Long userId = UserHolder.getUser().getId(); //2. 查询该用户收件箱（之前我们存的key是固定前缀 + 粉丝id），所以根据当前用户id就可以查询是否有关注的人发了笔记 String key = FEED_KEY + userId; Set\u0026lt;ZSetOperations.TypedTuple\u0026lt;String\u0026gt;\u0026gt; typeTuples = stringRedisTemplate.opsForZSet() .reverseRangeByScoreWithScores(key, 0, max, offset, 2); /**\\ * * `key`: Redis中ZSet的键名。 * * `0`: 查询的分数范围的最小值。 * * `max`: 查询的分数范围的最大值。 * * `offset`: 跳过指定数量的元素。这可以用于分页查询。 * * `2`: 查询结果的限制数量。这里表示最多返回2个元素。 * Set\u0026lt;ZSetOperations.TypedTuple\u0026lt;String\u0026gt;\u0026gt; typeTuples: * 这是一个Set集合，用于存储查询到的元素及其分数。每个元素都是一个TypedTuple\u0026lt;String\u0026gt;对象，包含了元素的值和分数。 */ //3. 非空判断 if (typeTuples == null || typeTuples.isEmpty()){ return Result.ok(Collections.emptyList()); } //4. 解析数据，blogId、minTime（时间戳）、offset，这里指定创建的list大小，可以略微提高效率，因为我们知道这个list就得是这么大 ArrayList\u0026lt;Object\u0026gt; ids = new ArrayList\u0026lt;\u0026gt;(typeTuples.size()); long minTime = 0; int os = 1;//offset 偏移量为1 for (ZSetOperations.TypedTuple\u0026lt;String\u0026gt; typeTuple : typeTuples) { //4.1 获取id String id = typeTuple.getValue(); ids.add(Long.valueOf(id)); //4.2 获取score（时间戳） long time = typeTuple.getScore().longValue(); if (time == minTime){ os++; }else { minTime = time; os = 1; } } //解决SQL的in不能排序问题，手动指定排序为传入的ids String idsStr = StrUtil.join(\u0026#34;,\u0026#34;,ids); //5. 根据id查询blog List\u0026lt;Blog\u0026gt; blogs = query().in(\u0026#34;id\u0026#34;, ids).last(\u0026#34;ORDER BY FIELD(id,\u0026#34; + idsStr + \u0026#34;)\u0026#34;).list(); for (Blog blog : blogs) { //5.1 查询发布该blog的用户信息 queryBlogUser(blog); //5.2 查询当前用户是否给该blog点过赞 isBlogLiked(blog); } //6. 封装结果并返回 ScrollResult scrollResult = new ScrollResult(); scrollResult.setList(blogs); scrollResult.setOffset(os); scrollResult.setMinTime(minTime); return Result.ok(scrollResult); } 11结语 再次感谢黑马程序员的精品课程！ 由于本课程是针对redis的实战项目课程，原视频中还有的功能（附近的商户、用户统计、UV签到）我这就没实现，有兴趣的小伙伴可以前往观看 收获最大的地方在于 通过这个项目让我更加深入理解了redis这个非关系型数据库的作用，以及在一些常见生产场景下会遇到的问题和解决措施，建议小伙伴们多次反复学习查询缓存、优惠券秒杀、分布式锁等章节，把项目吃透，掌握的本领才是自己的 本项目还有许多地方可以优化，初步想法是： 1.把短信验证登录模块，由后台发送验证码-\u0026gt;使用个人用户邮箱发送短信验证码-\u0026gt;（后续使用阿里云短信服务实现短信登录功能） 2.学习RabbitMQ消息队列实现高并发场景下的秒杀优化，减轻数据库压力 3.高并发的场景下使用令牌桶算法进行一定程度上的限流 ","date":"2025-03-21T00:00:00Z","image":"https://ayljzj520.github.io/p/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E5%AD%A6%E4%B9%A0/Amain_hu6245240136766360356.jpg","permalink":"https://ayljzj520.github.io/p/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E5%AD%A6%E4%B9%A0/","title":"黑马点评学习"},{"content":" “手机配置！”\n工欲善其事，必先利其器\n正如古语所言：“工欲善其事，必先利其器。”在手机重装系统后，迅速恢复工作环境并减少不必要的配置时间，是提升效率的关键。为了确保手机系统稳定、安全且便捷地运行，以下是一份基础软件清单，帮助你快速配置手机，提升日常使用体验。\n手机基础配置 关闭拓展内存 关闭广告 1、聊天软件 QQ：【下载链接】 微信：【下载链接】 飞书：【下载链接】 钉钉：【下载链接】 2、办公学习软件 文件处理 WPS：【下载链接】 远程工具 向日葵：【下载链接】 ToDesk：【下载链接】 3、常用软件 浏览器 Edge：【下载链接】 Chrome：【下载链接】 网盘 阿里云盘：【下载链接】 百度云盘：【下载链接】 123云盘：【下载链接】 夸克云盘：【下载链接】 视频软件 B站：【下载链接】 抖音：【下载链接】 密码管理 Keepass：【下载链接】 其他 Clash：【下载链接】 Hiddify：【下载链接】 5、游戏软件 游戏平台 Steam：【下载链接】 海岛奇兵 游戏基础运行安装 Hiddify：【下载链接】 Clash：【下载链接】 无界趣连：【下载链接】 相关脚本 查序列替换包：【下载链接】 国际服养号：【下载链接】 航母脚本：【下载链接】 卡首雕脚本：【下载链接】 梦想脚本：【下载链接】 梦想模拟雕像：【下载链接】 雪花断网：【下载链接】 其他 aaa ","date":"2025-02-04T00:00:00Z","image":"https://ayljzj520.github.io/p/%E6%96%B0%E6%89%8B%E6%9C%BA%E5%88%B0%E6%89%8B%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6/Amain_hu14191519669619636876.jpg","permalink":"https://ayljzj520.github.io/p/%E6%96%B0%E6%89%8B%E6%9C%BA%E5%88%B0%E6%89%8B%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6/","title":"新手机到手安装软件"},{"content":" “DIY PC！”\n前言 接下来将阐述我自己组装的电脑配件，以及相关配件当时的价格，以及后续配置升级的相关硬件的处理。\n电脑硬件配置 1、处理器 (CPU) 买入(i3 12100f)(i5 12400f) 支出：475.8+780=1255.8 卖出：(i3 12100f) 收入：475 总支出：780.5 2、主板 (Motherboard) 买入(微星B660迫击炮WIFI版) 总支出：979 3、内存 (RAM) 买入(金百达银爵32G*2 DDR4 3600) 总支出：315+308.8=623.8 4、显卡 (GPU) 买入(索泰2070S 8G)(映众760 2G)(讯景6750Gre海外版12G) 支出：1303+130+2099=3532 卖出：(索泰2070S 8G)(映众760 2G) 收入：1000+135=1135 总支出：2397 5、硬盘 固态硬盘 (SSD) 买入(致态TiPlus 5000 1TB)(幻影Hv2000 1TB) 支出：416.5+244.21=660.21 机械硬盘 (HDD) 买入(海康机械ST4X015垂直盘)(二手机械) 支出：399.18+16=415.18 还有一些其它的二手机械盘，送给同学了就不记录了 总支出：660.21+415.18=1075.39 6、电源 (PSU) 买入(海韵G12 GC850 金牌直出) 支出：547 总支出：547 7、散热器 (Cooler) 买入(利民PA120SE ARGB)(利民公包TL-C12C无灯)(积木风扇 三正三反) 支出：141.16+11.8*6+110=321.96 总支出：321.96 8、机箱 买入(先马朱雀air)(半岛铁盒F20 【已丢】)(积木风扇 三正三反) 支出：145.02+184.83+159=488.85 卖出：(先马朱雀air) 收入：50 和6把利民风扇一起打包便宜给同学了 总支出：438.85 外设 1、显示器 买入(翔野显示器【纯垃圾，坏了，已丢】)(泰坦军团) 支出：837.1+518.98=1356.28 总支出：1356.28 2、键鼠 买入(罗技GPW1代)(RK R75) 支出：339+163.98=402.98 总支出：402.98 最终总支出：780.5+979+623.8+2397+1075.39+547+\n321.96+438.85+1356.28+402.98=8922.76 写到最后才知道自己原本是想简单的装一台电脑，为了方便以后的升级，因此把主板与电源留了比较大的阈值，但是实际上到写这篇笔记的时候，装机已经完成了一年半左右，对于显卡与CPU的更换实际没有达到更高的地步。\n因此在装机的时候，一定要明确自己的需求，确定好配置，不然后期修改配置的话，费事费力又费钱，不过这台电脑全程是我自己装的。嘿嘿，人工费为0。\n对于这台电脑的安装我也是很高兴的，对于我来说他的价值足够了！！！\n","date":"2025-01-23T00:00:00Z","image":"https://ayljzj520.github.io/p/%E7%BB%84%E8%A3%85%E4%B8%AA%E4%BA%BA%E7%94%B5%E8%84%91/Amain_hu3851717235060608261.jpg","permalink":"https://ayljzj520.github.io/p/%E7%BB%84%E8%A3%85%E4%B8%AA%E4%BA%BA%E7%94%B5%E8%84%91/","title":"组装个人电脑"},{"content":" “云盘使用！” 个人压缩文件若使用的密码则均设置为：zxcvbnm\n引言 网盘是一种基于云存储的服务，允许用户上传、存储、管理和分享文件，方便用户随时随地访问自己的文件。\n在现代生活中，随着数据量的激增，传统的存储方式（如USB闪存、硬盘等）已经不能满足快速增长的需求，而网盘凭借着云存储的特点，成为了许多人的首选。\n而我使用网盘的有三大原因：\n及时备份重要文件，防止数据丢失。 多设备间同步文件，方便在不同设备间访问。 分享文件时更便捷，不必通过等传统方式。 同时，除了云盘我也介绍一下我使用的其它存储方式。\n1. 百度网盘 特点:\n百度网盘个人免费版基础容量2TB，容量很大，也有很多分享的资源，但是就是下载限速。 个人使用方式:\n存一些别人分享的资源，将自己备份文件存储一份。 2. 阿里云盘 特点:\n以“速度不限”为主打亮点，但是还是略有限速，不过比百度网盘来说还是好多了。 个人使用方式:\n存一些别人分享的资源，将自己备份文件存储一份。 3. iCloud 特点:\n苹果用户使用，但免费存储空间仅5GB，国内访问偶尔有延迟。 个人使用方式:\n存储一下就iPhone上的照片等。 4. OneDrive 特点:\n微软的云存储，个人版通过邀请后有5GB空间，与Windows深度集成，只要登陆账号就可在多设备共享，但是访问速度一般。 个人使用方式:\n存储一些日常上的文件，在两台电脑上的文件共享。 5. 坚果云 特点:\n主打办公文件同步，强调稳定和可靠性，支持多平台、WebDAV 协议，兼容多种第三方工具，数据加密传输，隐私保障较好。但是共享流量极少。 个人使用方式:\n存储keepass的密码文件。 6. 天翼云盘（已弃用） 特点:\n中国电信推出，针对国内用户，支持积分兑换存储空间。强调安全存储，部分资源可离线下载。提供较大的初始免费存储容量。 优点:\n国内网络访问速度快，上传下载流畅。适合存储个人照片、文档等文件。免费用户初始空间大，运营商联动优惠多。 缺点:\n功能较传统，分享体验一般。界面设计老旧，用户体验一般。第三方平台兼容性弱。\n看着挺好的，但是不适合我的使用。 7. 123云盘 特点:\n新兴云盘服务，主打无广告、无速度限制。上传、下载速度快，且免费用户也无速度限制。分享体验较好，可设置提取码或直接分享链接。但是现在每天下载流量有限制。 个人使用方式:\n将自己备份文件存储一份。 8. 蓝奏云盘 特点:\n主打轻量文件存储与分享，界面极简。免费用户无容量限制（单文件限制100MB）。不支持大文件上传，适合小型文件传输。分享的文件可以不用登陆直接下载（神中神）。 个人使用方式:\n存储一些自己的小文件，方便自己的下载与分享。 9. 垃圾机械盘 特点:\n自己买的几十块钱500G的垃圾二手机械盘，贼便宜，就是使用时间很久了，随时都有可能寄。 个人使用方式:\n存储一些临时的文件，充当下载盘。就算盘寄了也不心疼。 10. U盘 特点:\n便携式存储设备，适合小文件快速传输。插入电脑即可使用，兼容性强。小巧便携，随时传输数据。反复使用，经济耐用。 个人使用方式:\n用于本人两台电脑间，以及和其它电脑临时的数据共享。 ","date":"2025-01-21T00:00:00Z","image":"https://ayljzj520.github.io/p/%E4%B8%AA%E4%BA%BA%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/Amain_hu16818473676530701663.jpg","permalink":"https://ayljzj520.github.io/p/%E4%B8%AA%E4%BA%BA%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/","title":"个人数据存储"},{"content":" “电脑配置！”\n工欲善其事，必先利其器\n每次重装操作系统，我们都希望能迅速恢复工作环境，减少不必要的配置时间。正如古语所说：“工欲善其事，必先利其器”，只有准备好合适的工具，才能高效地完成任务。在电脑重装后的初期，我们需要下载并安装一系列基础软件，确保系统稳定、安全、便捷地运行。\n本文将为你提供一份基础软件清单，帮助你快速配置并提升个人电脑的工作效率。\n电脑基础配置 win11跳过激活： 1 ppbe\\bypassnro 关闭自动更新 关闭Windows Update服务 win+r输入services.msc,在弹出的服务窗口中，找到Windows Update选项并双击打开 在弹出的Windows Update的属性对话框中，将启动类型设置为禁用 然后再单击恢复，将第几次失败都设置为无操作，再单击应用和确定 本地组策略编辑器 win+r输入gpedit.msc 在弹出的本地组策略编辑中，依次单击“计算机配置” \u0026gt; “管理模板” \u0026gt; “Windows组件” \u0026gt; “Windows更新”，然后找到“配置自动更新”并双击打开它 在弹出的“配置自动更新”窗口中，选择“已禁用”，再单击“确定” 然后在“Windows更新”页面找到“删除使用所有Windows更新功能的访问权限”，并双击打开它 在弹出的窗口中，再勾选“已启用”，然后单击“确定” 任务计划程序 win+r输入taskschd.msc 在任务计划程序窗口中，跳转到该路径“任务计划程序库/Microsoft/Windows/WindowsUpdate” 然后，选中“Schedule Start”，并在“所选项”中单击“禁用” 必须关闭bitlocker 通过开始菜单的[设置]-[更新和安全]-[设备加密]，点击 [关闭]。\n或者\n通过控制面板或“这台电脑”找到要关闭加密的磁盘，右键点击 [管理 BitLocker]，选择 [关闭 BitLocker] 电脑必须检查删除McAfee软件 删除defender软件:【下载链接】\n分区助手：【下载链接】 微软常用运行库：【下载链接】 英伟达显卡驱动：【下载链接】 AMD显卡驱动：【下载链接】 联想驱动管理：【下载链接】 1、聊天软件 【必装】\nQQ：【下载链接】 微信：【下载链接】 企业微信：【下载链接】 TIM：【下载链接】 TIM绿色精简化版：【下载链接】 腾讯会议：【下载链接】 飞书：【下载链接】 钉钉：【下载链接】 2、办公学习软件 文件处理【必装】 WPS：【下载链接】 2019Office：【下载链接】 Acrobat（PDF编辑）：【下载请挂梯】 Visio：【下载链接】 远程工具【必装】 向日葵：【下载链接】 ToDesk：【下载链接】 学习软件 ChatGpt：【下载链接】 MathType：【下载链接】 Zotero：【下载链接】 3、常用软件 浏览器【必装】 浏览器必备IDM：【下载链接】 Edge：【下载链接】 Chrome：【下载链接】 火狐浏览器：【下载链接】 网盘【必装】 阿里云盘：【下载链接】 百度云盘：【下载链接】 百度云盘去广告精简版：【下载请挂梯】 123云盘：【下载链接】 夸克云盘：【下载链接】 蜗牛云盘：【下载请挂梯】 视频软件【必装】 OBS：【下载链接】 Potplayer：【下载链接】 剪映：【下载链接】 压缩工具【选一安装】 Bandzip：【下载链接】 WinRar：【下载链接】 7-zip：【下载链接】 卸载工具【必装】 geek：【下载链接】 Uninstall：【下载链接】 IObitUninstaller：【下载链接】 密码管理【必装】 Keepass：【下载链接】 其他 火绒：【下载链接】 Clash：【下载链接】 Hiddify：【下载链接】 v2RayN：【下载链接】 比特彗星：【下载链接】 4、开发工具 Git：【下载链接】 idea激活插件：【下载链接】 jetbrain激活插件：【下载链接】 visual Studio：【下载链接】 VS Code：【下载链接】 Obsidian：【下载请挂梯】 5、游戏软件 游戏平台 Epic：【下载链接】 Steam：【下载链接】 战网：【下载链接】 海岛奇兵 游戏基础运行安装 Hiddify：【下载链接】 7723：【下载链接】 Clash：【下载链接】 雷电模拟器9：【下载链接】 录音啦：【下载链接】 无界趣连：【下载链接】 MT管理器：【下载链接】 相关脚本 查序列替换包：【下载链接】 国际服养号：【下载链接】 航母脚本：【下载链接】 卡首雕脚本：【下载链接】 梦想脚本：【下载链接】 梦想模拟雕像：【下载链接】 雪花断网：【下载链接】 其他 城市天际线：【下载链接】 罗技驱动：【下载链接】 APEX宏文件：【下载链接】 ","date":"2025-01-19T00:00:00Z","image":"https://ayljzj520.github.io/p/%E7%94%B5%E8%84%91%E8%BD%AF%E4%BB%B6%E9%85%8D%E7%BD%AE/Amain_hu5941754247453116152.jpg","permalink":"https://ayljzj520.github.io/p/%E7%94%B5%E8%84%91%E8%BD%AF%E4%BB%B6%E9%85%8D%E7%BD%AE/","title":"电脑软件配置"},{"content":" “Hugo！”\n1、显示文章更新时间 (1) 在配置文件 hugo.yaml 中加入以下配置 1 2 3 4 5 6 7 8 # 更新时间：优先读取git时间 -\u0026gt; git时间不存在，就读取本地文件修改时间 frontmatter: lastmod: - :git - :fileModTime # 允许获取Git信息\tenableGitInfo: true (2) 修改github action文件.github/workflows/xxx.yaml，在运行 hugo -D 命令的step前加入以下配置 1 2 3 4 5 6 7 8 9 jobs: deploy: steps: - name: Git Configuration run: | git config --global core.quotePath false git config --global core.autocrlf false git config --global core.safecrlf true git config --global core.ignorecase false (3) 这样就提交代码时，就会去读取git时间，来更新文章的更新时间 (4) 若想在文章开头就显示更新时间，修改layouts/partials/article/components/detail.html，在指定位置引入以下代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;div class=\u0026#34;article-details\u0026#34;\u0026gt; ... \u0026lt;footer class=\u0026#34;article-time\u0026#34;\u0026gt; ... \u0026lt;!-- 更新时间 --\u0026gt; {{- if ne .Lastmod .Date -}} \u0026lt;div class=\u0026#34;article-lastmod\u0026#34;\u0026gt; {{ partial \u0026#34;helper/icon\u0026#34; \u0026#34;clock\u0026#34; }} \u0026lt;time\u0026gt; {{ .Lastmod.Format ( or .Site.Params.dateFormat.lastUpdated \u0026#34;Jan 02, 2006 15:04 MST\u0026#34; ) }} \u0026lt;/time\u0026gt; \u0026lt;/div\u0026gt; {{- end -}} .... \u0026lt;/footer\u0026gt; ... \u0026lt;/div\u0026gt; 这样就会文章开头显示修改时间\ntips: 更新时间的格式去 hugo.yaml 中的 params.dateFormat.lastUpdated 进行修改 2、友链、归档多列显示 修改assets/scss/custom.scss文件(不存在则自行创建)，引入以下css样式代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 @media (min-width: 1024px) { .article-list--compact { display: grid; // 目前是两列，如需三列，则后面再加一个1fr，以此类推 grid-template-columns: 1fr 1fr; background: none; box-shadow: none; gap: 1rem; article { background: var(--card-background); border: none; box-shadow: var(--shadow-l2); margin-bottom: 8px; margin-right: 8px; border-radius: 16px; } } } ","date":"2025-01-13T00:00:00Z","image":"https://ayljzj520.github.io/p/hugostack%E4%B8%BB%E9%A2%98%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BF%AE%E6%94%B9/Amain_hu4362935966078285323.jpg","permalink":"https://ayljzj520.github.io/p/hugostack%E4%B8%BB%E9%A2%98%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BF%AE%E6%94%B9/","title":"【hugo】Stack主题自定义修改"},{"content":" “Play！”\n1、环境准备 1.1 Git下载 前往【Git官网】，下载安装程序 一直点下一步，默认安装即可 1.2 Hugo下载 前往【Hugo Github Tags】，选择对应版本下载，下载后解压即可 Windows下载版本：hugo_extended_xxxxx_windows_amd64.zip 2、搭建博客 2.1 创建博客 （1）在hugo.exe所在文件夹的地址栏敲打cmd，然后Enter唤起命令行 （2）敲打命令hugo new site xxxx创建hugo文件 （3）敲打命名cd xxxx切换目录，并把hugo.exe复制到刚生成的文件夹中 （4）敲打命令hugo server -D启动服务，访问http://localhost:1313，Ctrl+C停止服务 （hugo默认是没有主题的，需要进行主题配置） 2.2 配置主题 （1）前往【Hugo Themes】，查找自己喜欢的主题，进行下载 （2）这边以【Stack主题】为例，将下载好的主题解压，放到/themes文件夹中 （3）将exampleSite样例数据中的 Content 和 hugo.yaml 复制到主文件夹中，并删掉hugo.toml和content/post/rich-content （4）修改 hugo.yaml 中的 theme，将他修改为跟主题文件夹同名 （5）再次启动hugo服务，查看主题，具体主题配置修改 hugo.yaml，这里不细说，感兴趣可自行查找相关文章 3、Github部署 3.1 常规部署 （1）前往【Github官网】，创建仓库 {github用户名}.github.io （2）前往Setting -\u0026gt; Pages -\u0026gt; Branch选择main分支，然后保存，会自动开启 https://{github用户名}.github.io 的地址，这地址也是以后访问博客的地址 （3）回到hugo文件中，执行命令hugo -D，会生成 public 静态资源文件夹 （4）在 public 执行以下命令上传到github仓库上，第一次上传可能需要输入账号密码 1 2 3 4 5 6 git init git add . git commit -m \u0026#34;first commit\u0026#34; git branch -M main git remote add origin {你的github仓库地址} git push -u origin main （5）上传成功后访问 https://{github用户名}.github.io，成功搭建属于自己的Hugo博客 3.2 Github Action自动部署 （1）Github创建一个新的仓库，用于存放Hugo的主文件 （2）前往Setttings -\u0026gt; Developer Settings -\u0026gt; Personal access tokens，创建一个token(classic) （3）token选择永不过期，并勾选 repo 和 workflow 选项 （4）为保证安全，将生成的token，保存的仓库的变量中，前往Settings -\u0026gt; Secrets and variables -\u0026gt; Actions中设置 （5）在hugo主文件创建一个.github/workflows/xxxx.yaml文件，将以下内容复制进去，想具体了解更多，可查看【Github Action文档】 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 name: deploy # 代码提交到main分支时触发github action on: push: branches: - main jobs: deploy: runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v4 with: fetch-depth: 0 - name: Setup Hugo uses: peaceiris/actions-hugo@v3 with: hugo-version: \u0026#34;latest\u0026#34; extended: true - name: Build Web run: hugo -D - name: Deploy Web uses: peaceiris/actions-gh-pages@v4 with: PERSONAL_TOKEN: ${{ secrets.你的token变量名 }} EXTERNAL_REPOSITORY: 你的github名/你的仓库名 PUBLISH_BRANCH: main PUBLISH_DIR: ./public commit_message: auto deploy （6）在hugo主文件创建.gitignore文件，来避免提交不必要的文件 1 2 3 4 5 6 7 # 自动生成的文件 public resources .hugo_build.lock # hugo命令 hugo.exe （7）将hugo的主文件上传到仓库，上传成功后会触发Github Action，来自动部署你的静态页面 1 2 3 4 5 6 git init git add . git commit -m \u0026#34;first commit\u0026#34; git branch -M main git remote add origin {你的github仓库地址} git push -u origin main ","date":"2025-01-12T00:00:00Z","image":"https://ayljzj520.github.io/p/hugo--github-%E5%85%8D%E8%B4%B9%E9%83%A8%E7%BD%B2%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/Amain_hu5036209731246305276.jpg","permalink":"https://ayljzj520.github.io/p/hugo--github-%E5%85%8D%E8%B4%B9%E9%83%A8%E7%BD%B2%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/","title":"Hugo + Github 免费部署自己的博客"},{"content":" “研究生！”\n085410 人工智能\n信息工程学院研究方向包括： 计算机视觉、语音信号处理与识别和自然语言处理。\n一、培养目标 本工程领域培养符合我国电子信息工程领域发展需求的应用型、复合型高层次工程技术和工程管理人才。经过培养达到以下具体要求：\n1．拥护中国共产党的领导，热爱祖国，遵纪守法，具有服务国家和人民的高度社会责任感、良好的职业道德与敬业精神、科学严谨的学习态度和求真务实的工作作风，身心健康。\n2．掌握从事电子、通信、控制、计算机、电气、软件、光电、仪器仪表等专业领域和网络空间安全、人工智能、虚拟现实、集成电路、大数据与云计算、物联网、生物信息、量子信息等新兴方向紧密关联的专业基础和前沿理论，熟悉电子信息专业领域的相关技术规范与标准，具有承担电子信息领域的技术开发与应用、工程设计与实施、技术攻关与改造、工程规划与管理等方面的专业技术工作的能力。\n3．熟练掌握一门外语，能够顺利阅读本专业领域的国内外科技文献资料，具有较好的外语写作能力和国际学术交流的能力，具备较开阔的国际视野。\n二、学习年限 学制3年,正常学习年限3年。全日制研究生学习年限最长不超过4年，非全日制研究生学习年限最长不超过5年。\n三、培养方式 1．硕士研究生培养应以职业需求为导向，以实践能力培养为重点，以产学结合为途径，加强实践基地建设，强化实践能力和创业能力培养；主要采取课程学习、专业实践、学位论文相结合的方式，重点培养研究生的职业素养与解决实际问题的能力；课程学习主要在校内完成，专业实践主要在实习单位完成。\n2．课程学习时间一般为1年，学位论文工作（课题研究和学位论文撰写）时间不少于1年。全日制专业学位硕士研究生专业实践时间累计不少于6个月。课程学习实行学分制，研究生应在学习年限内修满规定的学分，通过培养方案规定的课程学习和硕士学位论文答辩方能毕业，申请取得硕士学位。\n3．培养实行“双导师制”，由校内外双导师共同指导，以校内导师指导为主，校外导师参与实践过程、项目研究和论文等多个环节的指导工作。研究生导师（导师组）应全面关心和指导研究生的成长成才，指导研究生培养全过程。不仅负责制订研究生培养计划，指导开题、中期考核（筛选）、答辩、科学研究、科研实践和学位论文等工作，而且对研究生的学术素养、学术道德有引导、示范和监督的责任。\n4．学位论文选题应来源于专业实际或具有明确的专业技术背景。\n5．非全日制研究生培养方式可采取集中或分散学习方式进行，但培养质量和要求不能降低。可以采取灵活的课程授课方式，充分利用现代信息技术和教学手段，确保教学质量。\n四、课程设置与学分要求 课程设置略。\n研究生所修总学分不少于34学分。其中：课程学分不少于24学分（学位课学分不少于16学分，非学位课学分不少于8学分），必修环节10学分。研究生在导师指导下结合研究方向选择课程，制定培养计划。未完成课程学分和必修环节不予受理学位论文答辩申请。\n五、必修环节 1．创新创业教育和劳育（3学分）\n研究生创新创业教育活动旨在培养研究生创新实践能力，强化创业意识，引导研究生开展创新创业。创新创业教育累计共2学分。采取专题讲座、报告、经验交流会或参加各级各类竞赛等形式，开展研究生创新创业教育活动。主要采取以下几种方式审核学分：①听取创新创业类论坛、讲座或学术交流，研究生教学秘书审核签字，每6次计1学分；②取得以下创新创业业绩：省部级以上竞赛获奖1项、自主创设公司且取得营业执照或在省市级以上创新创业论坛上发表相应会议论文1篇，计2学分；③校级以上创新创业竞赛二等奖以上，计0.5学分/项。 劳育旨在激励和引导研究生树立崇尚劳动、热爱劳动的优秀品质，以劳树德、以劳增智、以劳促技、以劳强体、以劳育美、以劳创新，树立正确的劳动价值观。劳育共计1学分，主要以志愿者服务和劳动实践教育活动为主，由学院或学科点组织，学院备案，每学年累计满10小时及以上，计1学分。\n2．学术报告（1学分）\n要求研究生在读期间以主讲人身份在校内外学术会议上的学术报告，具体由学院或学科点统一组织和考核，安排应相对集中。\n3．开题报告（1学分）\n开题报告是研究生培养中最为关键的环节之一，它直接地关系到学位论文工作的进展和质量。要在论文选题上充分发挥导师的主导作用，应在研究生入学报到后尽早明确拟从事的方向及选题范围，制订学位论文工作计划，以便使研究生尽早进入科研实践。\n4．专业实践（5学分）\n专业学位研究生在学期间，必须保证不少于半年的专业实践，可采用集中实践与分段实践相结合的方式；应届本科毕业生的专业实践时间原则上不少于1年。在制订个人培养计划的同时，需制订专业学位研究生专业实践计划，明确实践学习的时间、地点及实践学习主题；每完成一次专业实践训练，研究生要撰写实践学习总结报告；专业实践的种类有：一是参加导师科研项目课题研究，提交研究报告，由导师审核、评分并签字，记1学分；二是参加校外企业单位、连续时间不少于3个月的实习实践，提交实习报告，由企业单位指导实习的负责人审核、评分、签字并加盖企业实习主管部门公章，记4学分。\n六、学位论文与答辩要求 1．在论文选题及研究方向范围内至少阅读文献30篇，其中外文文献不少于10篇，在学位论文参考文献中列出并在论文正文中标出。学位论文要求概念清楚、立论正确、论述严谨、计算正确、数据可靠，且层次分明、文笔简洁、流畅、图表清晰。学位论文应在调查研究的基础上，研究内容有一定学术价值，研究成果对国民经济发展有一定意义。围绕论文开展科研工作的时间不少于1年。\n2．学位论文评审结果合格方可答辩。\n3．学位基本要求按照学校下发的学位授予工作细则执行。\n七、其他要求 1．专业学位硕士研究生在读期间须以第一作者或导师第一作者研究生第二作者（署名第一单位为江西理工大学）公开发表本专业高水平学术论文1篇（以录用通知书为准），或者研究生在读期间取得下列学术成果之一：\n（1）获授权国家发明专利一件以上；\n（2）有一项技术方案被相关单位或企业所采用（以完整的技术方案和使用单位提供的证明材料为依据）；\n（3）撰写的咨询报告、调研报告、开发案例、政策建议等得到县级以上人民政府或市地级以上人民政府有关部门采纳和运用（以完整的技术方案和采纳单位提供的证明材料为依据）。\n对研究生申请学位应发表学术论文或取得科研实践成果的要求，各学院（学位点）可结合本学院（学位点）的实际情况制定不低于上述要求的规定，报学校研究生院批准后执行。\n2．申请提前毕业条件须满足《江西理工大学研究生学籍管理细则》相关规定。\n申请提前半年毕业的硕士研究生必须达到优秀毕业生，同时应满足以下条件：\n（1）读研期间无违纪行为，德智体美劳诸方面综合表现优秀。\n（2）已修满规定学分，无补考科目，课程加权平均成绩达85分及以上，论文开题至提交论文正式稿时间间隔不少于六个月；\n（3）以第一作者（作者单位为江西理工大学）在中文核心期刊以上刊物上公开发表与本专业相关的学术论文2篇以上；或者以第一作者出版了学术专著；或发表了高水平的期刊论文被SCI、EI、SSCI收录；或获国家发明专利（第一专利权人为江西理工大学）；或者在读期间获得省级及以上研究生科技竞赛二等奖及以上奖项。\n","date":"2025-01-10T00:00:00Z","image":"https://ayljzj520.github.io/p/%E7%A0%94%E7%A9%B6%E7%94%9F%E6%AF%95%E4%B8%9A%E8%A6%81%E6%B1%82/Amain_hu13077273176099163194.jpg","permalink":"https://ayljzj520.github.io/p/%E7%A0%94%E7%A9%B6%E7%94%9F%E6%AF%95%E4%B8%9A%E8%A6%81%E6%B1%82/","title":"研究生毕业要求"},{"content":" “Work！ ”\nJava学习相关顺序 学习思路 学习完java基础之后,先学习mysql，然后稍微了解一下javaweb的层，直接去学习springboot，学完了然后往前学ssm，理解为什么springboot淘汰了以前的ssm框架，然后再往前学javaweb，理解框架的好处。这样每个学习都有目标，不至于说学习了javaweb，然后学习ssm的时候觉得之前学习的东西都白学了，学习springboot，觉得ssm白学了。 等这一套学习了完了之后，去学习设计模式，了解设计思想。然后再去学习数据结构，了解底层。最后才是jvm 从入门，到实际开发，一开始给你成就感，让你有动力继续学习下去，而不是从javaweb开始，盼着早日学到springboot，我就能够出去找工作了。\n还有一点，springboot相较与javaweb和ssm，会简单很多，毕竟springboot约定大于配置。\njava语言方面常规八股要熟，那些java的集合，重点背hashmap八股吧，jvm类加载机制，运行时分区，垃圾回收算法，垃圾回收器CMS、G1这些，各种乐观锁悲观锁，线程安全，threadlocal这些。 在进阶一些的比如jvm参数，内存溢出泄漏排查，jvm调优。我这里说的只是冰山一角，详细八股可以去网上找，这不用去买，都免费资源。mysql、redis可以去看小林coding， 我看你简历上写了，你一定要熟，什么底层b+树、索引结构、innodb、mvcc、undo log、redo log、行级锁表级锁，这些东西高频出现，如果面试官问我这些我都能笑出来。消息队列rabbitmq也好kafka也好，学一种就行， 什么分区啊副本啊确认机制啊怎么保证不重复消费、怎么保证消息不丢失这些基本的一定要会，进阶一点的比如LEO、高水位线、kafka和rocketmq底层零拷贝的区别等等。计算机网络和操作系统既然你是科班应该理解起来问题不大，去看小林coding这两块吧，深度够了。 spring boot的八股好好看看吧，一般字节腾讯不这么问，其他的java大厂挺爱问的，什么循环依赖啥的去网上看看。数据结构的话科班应该问题不大，多去力扣集中突击刷题吧。 项目还是结合八股来，想一想你写的这些技术会给你挖什么坑。除此之外，还有场景题、rpc、设计模式、linux命令、ddd等。不会的就别往简历上写了，虽然技术栈很多的话好看些，但背起来确实累。总结一下，多去实习吧，多跳槽，直到跳到一个不错的中厂做跳板，这是一条可行的进大厂的路线。 找个小厂的工作的话，没必要全都照这些准备，重点放在框架的使用和一些基础八股吧。\njava架构层次\npojo(或entity)：实体类 util:工具类 service：代码逻辑 mapper：数据库接口层 web： 表现层(servlet,SpringMVC) 业务层() 数据层(JDBC,MyBatis)\n创建接口后，在接口中定义方法，在接口的实现类中实现方法\nspring MVC(表现层框架) 导jar包\n创建SpringMVC控制类\n创建SpringMVC配置类\n方法前加@controller\n设置访问路径@requestmapping(\u0026quot;/aaa\u0026quot;)\n@responsebody\nget请求与post请求\nrest代码风格\n查询get\n添加post\n修改put\n删除delete\n静态资源放行tomcat处理\nSSM整合 spring springConfig mybatis mybatisConfig jdbcConfig jdbc.properties SpringMVC servletConfig SpringMVCConfig 功能模块\n表与实体类 dao（接口+自动代理） service（接口+实现类） 业务层接口测试（整合JUnit） controller 表现层接口测试（PostMan） 表现层数据封装规范\n异常处理器\n表现层 → 业务层：表现层接收用户请求，调用业务层的接口处理请求。\n业务层 → 持久层：业务层通过调用持久层的接口（如Repository）来访问和操作数据库。\n持久层 → 数据库：持久层通过JPA、MyBatis或JDBC等技术与数据库进行交互。\n简单的流程示例： 用户通过浏览器发起HTTP请求。 控制器（Controller）接收请求，调用业务层（Service）的方法。 业务层（Service）处理逻辑，并可能调用持久层（Repository）进行数据库操作。 持久层（Repository）查询数据库或更新数据。 业务层（Service）将结果返回给控制器（Controller）。 控制器（Controller）将结果传递给视图层（View），并最终展示给用户。 MyBatisPlus 新增\n删除\n修改\n根据id查询\n查询全部\n分页查询（配置拦截器）\n按条件查询\n代码生成器（快速搭建框架）\n项目描述： 瑞吉外卖是一款专门为餐饮企业（餐厅、饭店）定制的软件产品，包括系统管理后台和移动端应用两部分。系统管理后台主要提供给餐饮企业内部员工使用，用于对餐厅的分类、菜品、套餐、订单、员工等进行管理维护。移动端应用主要提供给消费者使用，可以在线浏览菜品、添加购物车、下单等。\n开发环境： 环境(软件): JDK +MySQL +IDEA+Git+Tomcat\n技术: Spring Boot、SSM、Mybatis Plus、Spring Security、Redis、Spring Cache、Swagger、Linux、ShardingJDBC、Nginx 责任描述： 负责系统管理后台的员工、分类、菜品、套餐模块的编写。 负责移动端应用的开发，实现短信验证码登录功能。 开发移动端应用的菜品浏览功能，使用户可以方便地浏览菜品信息。 实现移动端应用中用户地址簿信息的管理功能，方便用户管理收货地址。 开发移动端应用的购物车功能，使用户可以方便地添加菜品到购物车并管理订单。 实现移动端应用中提交订单的功能，确保用户能够成功下单。 进行移动端应用的数据展示缓存优化，提高系统的响应速度和用户体验。 负责数据库主从配置以及读写分离的实现，提高数据库的性能和可靠性。 实现项目接口API文档生成功能，使用Swagger生成清晰明了的接口文档。 技术描述： 使用Redis缓存高频数据，并使用Spring Cache优化代码，提高系统的性能和响应速度。 在整个开发过程中使用Linux系统进行部署，充分利用Linux系统的稳定性和安全性。 使用Nginx部署前端项目，实现前后端分离的部署方式，提高系统的灵活性和可维护性。 使用Nginx实现反向代理和负载均衡，提高系统的并发处理能力和可用性。 使用ShardingJDBC实现数据库读写分离，提高数据库的读取性能和写入性能。 使用Spring Security框架进行权限模块的开发，采用经典的RBAC模型进行精细的权限管理。 使用YApi实现前后端分离开发，并使用Swagger生成接口API文档，提高团队的协作效率。 使用Git进行项目的版本控制和代码管理，充分利用分支功能进行项目优化和问题修复。 Controller 接收请求，调用 Service 层处理业务逻辑。\nService 层调用 Mapper 层进行数据库操作。\nMapper 层操作 Entity 对象，与数据库交互。\nDTO 用于在 Controller 和 Service 之间传递数据。\nUtils 和 Common 提供通用的工具和常量，供其他层级使用。\nConfig 定义全局配置，Filter 处理请求和响应的拦截逻辑。\ncommon： 功能：存放项目中通用的工具类、常量、枚举、异常处理等。 示例：自定义异常类、全局常量、通用工具类等。 config： 功能：存放项目的配置类，用于配置Spring Boot应用的各种行为。 示例：数据库配置、安全配置、Swagger配置、自定义Bean配置等。 controller： 功能：负责处理HTTP请求，接收前端传递的参数，调用Service层处理业务逻辑，并返回结果。 示例：RESTful API接口、请求参数校验、返回JSON数据等。 dto： 功能：存放数据传输对象（Data Transfer Object），用于在不同层之间传递数据，通常用于封装请求和响应的数据。 示例：前端传递的请求参数封装、返回给前端的响应数据封装等。 entity： 功能：存放与数据库表对应的实体类，通常使用JPA或MyBatis等ORM框架进行映射。 示例：数据库表的实体类，包含字段、getter/setter方法等。 filter： 功能：存放过滤器类，用于在请求到达Controller之前或响应返回客户端之前进行一些处理，如日志记录、权限校验等。 示例：自定义过滤器、拦截器等。 mapper： 功能：存放与数据库交互的接口或类，通常使用MyBatis或JPA进行数据库操作。 示例：MyBatis的Mapper接口、JPA的Repository接口等。 service： 功能：负责业务逻辑的处理，通常被Controller层调用，并调用Mapper层进行数据持久化操作。 示例：业务逻辑处理、事务管理、调用Mapper层接口等。 utils： 功能：存放项目中常用的工具类，提供一些通用的方法供其他模块调用。 示例：日期处理工具类、字符串处理工具类、加密解密工具类等。 后端代码部署tomcat\n前端代码部署nginx\ndocker相关配置与命令 docker源：\n1 2 3 4 5 6 7 8 \u0026#34;https://registry.docker-cn.com\u0026#34;, \u0026#34;http://f1361db2.m.daocloud.io\u0026#34;, \u0026#34;https://dockerhub.azk8s.cn\u0026#34;, \u0026#34;https://docker.mirrors.ustc.edu.cn\u0026#34;, \u0026#34;https://ud6340vz.mirror.aliyuncs.com\u0026#34;, \u0026#34;https://reg-mirror.qiniu.com\u0026#34;, \u0026#34;https://hub-mirror.c.163.com\u0026#34;, \u0026#34;https://mirror.ccs.tencentyun.com\u0026#34; docker自定义tag: 1 docker tag local-image:tagname new-repo:tagname docker镜像上传到hub: 1 docker push new-repo:tagname 查看容器ip： 1 docker inspect --format=\u0026#39;{{.NetworkSettings.IPAddress}}\u0026#39; mysql-slave 创建Docker网络 1 docker network create mysql-net 查看所有网络: 1 docker network ls 删除对应网络: 1 docker network rm my_net 进入容器内部： 1 docker exec -it \u0026lt;container\u0026gt; bash 启动redis容器： 1 docker run --name docker-redis -it -p 6379:6379 -v /data/redis-data ayljzj/redis:7.4.2 --requirepass \u0026#34;123456\u0026#34; 启动mysql容器： 1 docker run --name mysql- -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 -d ayljzj/mysql:8.0.41 rabbitmq 创建一个目录用于挂载 RabbitMQ 数据： mkdir -p /usr/local/docker/rabbitmq 启动 RabbitMQ 容器 使用以下命令启动一个新的 RabbitMQ 容器：\n1 docker run -id --name=rabbitmq --network rabbit -v /usr/local/docker/rabbitmq:/var/lib/rabbitmq -p 15672:15672 -p 5672:5672 -e RABBITMQ_DEFAULT_USER=root -e RABBITMQ_DEFAULT_PASS=123456 ayljzj/rabbitmq:3.8-management 在这条命令中，我们做了以下配置：\n-id：以交互模式启动容器并在后台运行。 \u0026ndash;name=rabbitmq：为容器指定一个名称。 -v /usr/local/docker/rabbitmq:/var/lib/rabbitmq：将主机目录挂载到容器内的 /var/lib/rabbitmq，用于持久化数据。 -p 15672:15672：映射 RabbitMQ 管理页面端口。 -p 5672:5672：映射 RabbitMQ 消息接收端口。 -e RABBITMQ_DEFAULT_USER=admin：设置默认用户名。 -e RABBITMQ_DEFAULT_PASS=admin：设置默认密码。 CentOs下redis设置 中文官网\n进入路径：/usr/local/redis-4.0.0/src\n运行命令：src/redis-server ./redis.conf\n修改为后台运行：/usr/local/redis-4.0.0/redis.conf\n配置修改：daemonize yes\n密码：123456\n退出：redis-cli -h 你的IP地址 -p 你的redis端口号 shutdown\n设置允许远程链接：127.0.0.1添加注释#\n./redis-cli.exe -h 192.168.179.135 -p 6379 -a 123456\ncentOs关闭防火墙：firewall-cmd \u0026ndash;zone=public \u0026ndash;add-port=6379/tcp \u0026ndash;permanent centOs重启防火墙：firewall-cmd \u0026ndash;reload\ncentOs关机：shutdown -h now\nredis 启动数据库：systemctl start mysqld\nupdate user set authentication_string=passworD(\u0026ldquo;root\u0026rdquo;) where user=\u0026lsquo;root\u0026rsquo;;\n–name:容器名称\n-p 6379:6379 将端口设置为6379\n-it参表示控制台显示Redis安装的交互信息\n如果后台运行，用-d参数\n-v /data/redis-data 将redis数据挂载到根目录的 /data/redis-data 目录下\n-v $PWD/data/redis-data 将redis数据挂载到当前目录的data/redis-data 目录下\n–requitepass “123456” : 指定redis连接密码，此参数要放在镜像名后面\nNginx 安装依赖：yum -y install gcc pcre-devel zlib-devel openssl openssl-devel\ndocker cp nginx:/var/log/nginx C:\\afordocker\\nginx\\log docker cp nginx:/usr/share/nginx/html C:\\afordocker\\nginx\ndocker cp nginx:/etc/nginx/nginx.conf C:\\afordocker\\nginx\\conf docker cp nginx:/etc/nginx/conf.d C:\\afordocker\\nginx\\conf\\conf.d\ndocker run -d \u0026ndash;name nginx -p 8880:80 -v C:\\afordocker\\nginx\\conf\\nginx.conf:\\etc\\nginx\\nginx.conf -v C:\\afordocker\\nginx\\conf\\conf.d:\\etc\\nginx\\conf.d -v C:\\afordocker\\nginx\\log\\log:\\var\\log\\nginx -v C:\\afordocker\\nginx\\log\\html:\\usr\\share\\nginx\\html \u0026ndash;privileged=true ayljzj/nginx:1.24.0\nWindows下docker的Mysql（5.7）主从辅助（一主一从） 1、拉取Mysql镜像 1 docker pull mysql:5.7 2、启动Mysql容器 先启动mysql-master容器：（即之后的主机） 1 docker run -d -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 --name mysql-master ayljzj/mysql:5.7 先启动mysql-slave容器：（即之后的从机） 1 docker run -d -p 3307:3306 -e MYSQL_ROOT_PASSWORD=123456 --name mysql-slave ayljzj/mysql:5.7 命令解释：\n-d： 后台运行容器，并返回容器ID -p 3307:3306 ：将容器的3306端口映射到宿主机3307端口 –name mysql-slave：将容器命名为mysql-slave -e MYSQL_ROOT_PASSWORD=123456 ：配置数据库连接密码 ayljzj/mysql:5.7：使用该镜像 3、编写主从复制文件 对主库文件进行如下配置： 找到file中的/etc/my.cnf文件，将以下内容复制进去\n1 2 3 4 5 6 7 8 9 10 11 12 [mysqld] #主服务器唯一ID server-id=1 #启用二进制日志 log-bin=mysql-bin # 设置不要复制的数据库(可设置多个) binlog-ignore-db=mysql binlog-ignore-db=information_schema #设置需要复制的数据库 需要复制的主数据库名字 binlog-do-db=testdb #设置logbin格式 binlog_format=STATEMENT 对从库文件进行如下配置： 找到file中的/etc/my.cnf文件，将以下内容复制进去\n1 2 3 4 #从服务器唯一ID,必须要与主服务器不同 server-id=2 #启用中继日志 relay-log=mysql-relay 4、搭建主从复制 4.1、主机设置 进入主机容器：\n1 docker exec -it mysql-master bash 连接容器：\n1 mysql -uroot -p123456 4.2、主机上建立帐户并授权（slave） 给从机授权，为了让从机能够和主机连接起来。 创建账户：slave，设置密码：123456\n1 CREATE USER \u0026#39;slave\u0026#39;@\u0026#39;%\u0026#39; IDENTIFIED BY \u0026#39;123456\u0026#39;; 对slave账户进行授权\n1 GRANT REPLICATION SLAVE ON *.* TO \u0026#39;slave\u0026#39;@\u0026#39;%\u0026#39;; 或者二者代码写为一行：\n1 GRANT REPLICATION SLAVE ON *.* TO \u0026#39;slave\u0026#39;@\u0026#39;%\u0026#39; IDENTIFIED BY \u0026#39;123456\u0026#39;; GRANT REPLICATION SLAVE ON . TO \u0026lsquo;slave\u0026rsquo;@\u0026rsquo;%\u0026rsquo; IDENTIFIED BY \u0026lsquo;123456\u0026rsquo;;\n4.3、查询master状态 1 show master status; #查询master的状态 记录出现的File和Position的值，后续要用\n注意：此步骤后不要再操作主服务器MySQL，防止主服务器状态值变化!\n4.4、从机设置 进入从机容器：\n1 2 docker exec -it mysql-slave bash mysql -uroot -p123456 进入容器后输入以下命令：\n1 2 3 4 5 6 7 8 9 10 11 CHANGE MASTER TO MASTER_HOST=\u0026#39;主机的ip地址\u0026#39;, MASTER_USER=\u0026#39;slave\u0026#39;, MASTER_PASSWORD=\u0026#39;123456\u0026#39;, MASTER_PORT=3306, MASTER_LOG_FILE=\u0026#39;mysql-bin.000003\u0026#39;,MASTER_LOG_POS=438; #解释： # CHANGE MASTER TO MASTER_HOST=\u0026#39;主机的IP地址\u0026#39;, #\tMASTER_USER=\u0026#39;slave\u0026#39;(刚刚配置的用户名), #\tMASTER_PASSWORD=\u0026#39;123456\u0026#39;(刚刚授权的密码), #\tmaster_port=主机开放的端口 我这里是3310端口, #\tMASTER_LOG_FILE=\u0026#39;mysql-bin.具体数字\u0026#39;,MASTER_LOG_POS=具体值(之前的Position); 若在这里出现错误，先执行完下面两条命令重置：\n1 2 stop slave; reset master; 完成后，启动从服务器复制功能\n1 start slave; 查看从服务器状态\n1 show slave status\\G 观察输出的结果，下面两个参数都是Yes，则说明主从配置成功！\nSlave_IO_Running: Yes,Slave_SQL_Running: Yes\n","date":"2025-01-08T00:00:00Z","image":"https://ayljzj520.github.io/p/java%E5%AD%A6%E4%B9%A0/Amain_hu15800079232963461917.jpg","permalink":"https://ayljzj520.github.io/p/java%E5%AD%A6%E4%B9%A0/","title":"java学习"},{"content":" “Work！ ”\nJava八股\n1、JDK下载 JDK下载\n2、编辑器下载 IDEA\u0026mdash; IDEA教程\nVS_code\u0026mdash; VS_code教程\n3、maven安装 前往阿帕奇官网，下载apache-maven-3.9.6-bin.zip， 解压缩到本地指定文件夹即可 国内Maven需要调整指定源为阿里云，修改setting.xml文件为如下\n1 2 3 4 5 6 7 8 9 10 \u0026lt;mirror\u0026gt; \u0026lt;!-- 指定镜像ID（可自定义名称） --\u0026gt; \u0026lt;id\u0026gt;Aliyun\u0026lt;/id\u0026gt; \u0026lt;!-- 匹配中央仓库（不可修改）--\u0026gt; \u0026lt;mirrorOf\u0026gt;central\u0026lt;/mirrorOf\u0026gt; \u0026lt;!-- 指定镜像名称（可自定义名称） --\u0026gt; \u0026lt;name\u0026gt;Aliyun\u0026lt;/name\u0026gt; \u0026lt;!-- 指定镜像路径（镜像地址） --\u0026gt; \u0026lt;url\u0026gt;http://maven.aliyun.com/nexus/content/groups/public\u0026lt;/url\u0026gt; \u0026lt;/mirror\u0026gt; 注意 3.9.6版本Maven默认开启禁止禁止http远端仓库，需将如下配置注释后，阿里云镜像才会生效\n1 2 3 4 5 6 7 \u0026lt;mirror\u0026gt; \u0026lt;id\u0026gt;maven-default-http-blocker\u0026lt;/id\u0026gt; \u0026lt;mirrorOf\u0026gt;external:http:*\u0026lt;/mirrorOf\u0026gt; \u0026lt;name\u0026gt;Pseudo repository to mirror external repositories initially using HTTP.\u0026lt;/name\u0026gt; \u0026lt;url\u0026gt;http://0.0.0.0/\u0026lt;/url\u0026gt; \u0026lt;blocked\u0026gt;true\u0026lt;/blocked\u0026gt; \u0026lt;/mirror\u0026gt; 完成后将Maven添加到ieda中。\n4、jmeter下载安装 JMeter是一个纯Java编写的开源软件，主要用于进行性能测试和功能测试。它支持测试的应用/服务/协议包括Web (HTTP, HTTPS)、SOAP/REST Webservices、FTP、Database via JDBC等。我们最常使用的是HTTP和HTTPS协议。 下载地址\n下载安装包后，解压安装 Jmeter 即可 环境变量配置 1.在环境变量中新建系统变量名为： JMETER_HOME 2.变量值为jmeter安装目录 修改系统变量的Path 添加一条：%JMETER_HOME%\\bin 查看环境变量是否配置成功,打开cmd运行 jmeter -v命令查看是否能查看到Jmeter版本信息 jmeter命令查看是否能启动jmeter 启动jmeter方式 进入apache-jmeter-5.6.3/bin，点击jmeter.bat文件，运行JMeter cmd下使用jmeter启动jmeter 注意：不管用使用哪一种方式打开，都会打开一个cmd窗口。如果关闭这个cmd窗口，打开的jmeter也会被关闭。 ","date":"2025-01-08T00:00:00Z","image":"https://ayljzj520.github.io/p/java%E8%B5%84%E6%BA%90%E4%B8%8E%E4%BB%8B%E7%BB%8D/Amain_hu15800079232963461917.jpg","permalink":"https://ayljzj520.github.io/p/java%E8%B5%84%E6%BA%90%E4%B8%8E%E4%BB%8B%E7%BB%8D/","title":"java资源与介绍"},{"content":"块引用 这是一段提示文字 “Write！” 我是一段 Alerts 提示文字 语法格式如下\n1 \u0026gt; 语法格式 标题语法 1 2 3 4 5 6 7 8 9 10 11 --- layout: post title: 此处为博客标题 description: 此处为博客介绍 date: 2024-12-30//博客创建日期 image: person-markdown.assets/main.jpg//博客封面图 author: AYLj catalog: true categories://博客分类 - 个人自用 --- 折叠语法 这是一段折叠内容，语法格式如下 此处为被折叠的内容 1 2 3 4 \u0026lt;details\u0026gt; \u0026lt;summary\u0026gt;这是一段折叠内容，语法格式如下\u0026lt;/summary\u0026gt; 此处为被折叠的内容 \u0026lt;/details\u0026gt; markdown基础语法 图片语法\n1 image: a.assets/main.jpg 1 \u0026lt;div align=\u0026#34;center\u0026#34;\u0026gt;\u0026lt;img src=\u0026#34;./a.assets/1.jpg\u0026#34;/\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;br\u0026gt; 1 \u0026lt;img src=\u0026#34;./boom-beach.assets/3.png\u0026#34; width=\u0026#34;70%\u0026#34; align=\u0026#34;center\u0026#34; /\u0026gt;\u0026lt;br\u0026gt; 多图并列：\n1 2 3 \u0026lt;div align=\u0026#34;center\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;./life02-diypc.assets/1-cpu-1.jpg\u0026#34; width=\u0026#34;40%\u0026#34;/\u0026gt;\u0026lt;img src=\u0026#34;./life02-diypc.assets/1-cpu-3.jpg\u0026#34; width=\u0026#34;40%\u0026#34;/\u0026gt; \u0026lt;/div\u0026gt; 文字格式\n1 \u0026lt;big\u0026gt;文字加大！！\u0026lt;/big\u0026gt;\u0026lt;br\u0026gt; 1 \u0026lt;font color=blue\u0026gt;文字加颜色！！\u0026lt;/font\u0026gt; 1 \u0026lt;big\u0026gt;\u0026lt;font color=blue\u0026gt;文字加大，加颜色！！！\u0026lt;/font\u0026gt;\u0026lt;/big\u0026gt;\u0026lt;br\u0026gt; 1 \u0026lt;center\u0026gt;文字居中\u0026lt;/center\u0026gt;\u0026lt;br\u0026gt; 超链接语法\n1 [百度](https://www.baidu.com/)\u0026lt;br\u0026gt; 1 [\u0026lt;font color=blue\u0026gt;百度\u0026lt;/font\u0026gt;](https://www.baidu.com/)\u0026lt;br\u0026gt; 表格语法\n1 2 3 4 | 标题1 | 标题2 |标题3 | | ---------- | ---------- | ---------- | | Header | Title | Title2 | | Paragraph | Text | Text | 效果如下：\n标题1 标题2 标题3 Header Title Title2 Paragraph Text Text 什么是 Markdown? Markdown 是一款轻量级标记语言，不同于HTML (Hypertext Markup Language)，Markdown 的语法非常简单，且容易上手 Markdown 以 纯文本格式 编写文档，依赖键盘而非鼠标，专注于写作本身，感受书写的魅力 Markdown 的通过添加一些简单的 标识符，让文本具有恰到好处的格式 Markdown 核心特征就是 删繁剪芜， 简扼 + 精炼 Markdown 是 笔记 与 网页文章 的最佳载体 Down 的核心：坐 下 来，就能把思维写 下 来 牛津高阶英汉双解词典第九版 中，关于 down 的释义： 为什么要使用 Markdown? 有朋友问我 ，Markdown 的效果 用Word 完全可以复现，甚至功能更多，那为何要用 Markdown 呢？\n答：\n功能多，不一定是好事 功能一多，选择就会变多，然后你会开始纠结…… 这个字号是不是该大一点呢？ 这个颜色好像有点不太搭呢？ 这个粗体，是不是该再加点颜色呢？ 这个图片的位置看起来有点不大对劲呢？ 结果，写了半天，就憋出一点点东西 写出来的内容\u0026hellip;好像\u0026hellip;也不咋滴 MD的优势：\nMarkdown 让我们免于 被繁杂臃肿的功能晃花了眼 的困扰 Markdown 让我们回归内容本身，拥抱笔记的内核，而非浮于表象的样式，写出高效精练的笔记！ 用 Markdown 写东西，记住一个原则\n能用10个字搞定的，绝不用11个字\n经常使用 Markdown 书写的朋友，也许会有一种奇妙的感触\n书写，会==倒逼==思维的跃进。像是有东西拽着你的思绪往前冲 倒逼：逆向逼迫，反向推动 关于标识符的滥用\n这个其实是写在最后的，之所以放在这里，是因为它很重要！\n如果你有一定的MD语法基础，可以直接[[#19 避免标识符的滥用|点击跳转]]\nMarkdown 相关软件推荐 Markdown 书写软件 推荐：Typora 优秀的 MD网页文章 书写软件 点击跳转下载地址 #提示 以前是免费的，现在收费了，不过是买断制 Markdown 笔记软件 推荐：Obsidian 银河系最强 MD+双向链 笔记软件 点击跳转下载地址 Markdown 语法 提示1： 本教程推荐使用 Obsidian 打开阅读 提示2： 下文提到的所有标识符都是 英文状态 的 ！ 1. 标题\u0026amp;目录 1.1 标题 Markdown标题共有 六级，和 HTML 一样 区分 一级标题 → 六级标题 标题 的格式： # × 标题级数 + 空格 + 文本内容 1 2 3 4 5 6 7 8 这是一段普通的文本 # 这是一级标题 ## 这是二级标题 ### 这是三级标题 #### 这是四级标题 ##### 这是五级标题 ###### 这是六级标题 1.2 目录 目录的 格式： 在文档的顶部 输入 [toc] ，会根据 标题 自动生成目录 ( Table of Content ) 不是所有 MD编辑器 都支持目录生成 Obsidian 就不支持，不过 OB 是自带大纲的，就是目录的效果 1 2 3 输入下方内容会生成一个目录： [toc] 2. 斜体\u0026amp;粗体 2.1 斜体 斜体 的格式： * + 文本内容 + * _ + 文本内容 + _ ( 下划线 ) 说明： 斜体文本，首尾只有 单个 标识符 1 2 3 4 这是一段普通文本 *这里是一段斜体文本* _这也是一段斜体文本_ 示范 这是一段普通文本\n这里是一段斜体文本 这也是一段斜体文本\n2.2 粗体 粗体 的格式：\n** + 文本内容 + ** __ + 文本内容 + __ (这里是两个 _ ) 说明：\n粗体文本，首尾各有 两个 标识符 1 2 3 4 这是一段普通文本 **这里是一段加粗文本** __这也是一段加粗文本__ 示范 这是一段普通文本\n这里是一段加粗文本 这也是一段加粗文本\n2.3 粗斜体 (斜粗体) 粗斜体 的格式：\n*** + 文本内容 + *** ___ + 文本内容 + ___ （ 这里是3个 _ ) **_ + 文本内容 + _** __* + 文本内容 + *__ *__ + 文本内容 + __* _** + 文本内容 + **_ 说明：\n粗斜体文本，首尾各有 三个 标识符 1 2 3 4 5 6 7 8 这是一段普通文本 ***粗斜体文本1*** ___粗斜体文本2___ **_粗斜体文本3_** __*粗斜体文本4*__ *__粗斜体文本5__* _**粗斜体文本6**_ 示范 这是一段普通文本\n粗斜体文本1 粗斜体文本2 粗斜体文本3 粗斜体文本4 粗斜体文本5 粗斜体文本6\n2.4 斜体包含粗体 斜体中包含粗体 的格式：\n* + 斜体文本 + ** + 粗体文本 + ** + 斜体文本 + * _ + 斜体文本 + __ + 粗体文本 + __ + 斜体文本 + _ （ 这里是两个 _ ) * + 斜体文本 + __ + 粗体文本 + __ + 斜体文本 + * _ + 斜体文本 + ** + 粗体文本 + ** + 斜体文本 + _ 说明：\n斜体 中包含 粗体，其实就是嵌套的关系，外层 是 斜体，内层 是 粗体 外层是斜体，标识符是单个；内层是粗体，标识符是两个 因为 粗体 是被包裹在 斜体 中的，所以显示效果为 斜粗体 1 2 3 4 5 6 这是一段普通文本 *这里是一段斜体中**包含粗体**的文字* _这也是一段斜体中**包含粗体**的文字_ *这又是一段斜体中__包含粗体__的文字* _这还是一段斜体中**包含粗体**的文字_ 示范 这是一段普通文本\n这里是一段斜体中包含粗体的文字 这也是一段斜体中包含粗体的文字 这又是一段斜体中__包含粗体__的文字 这还是一段斜体中包含粗体的文字\n2.5 粗体包含斜体 粗体中包含斜体 的格式： ** + 粗体文本 + * + 斜体文本 + * + 粗体文本 + ** __ + 粗体文本 + _ + 斜体文本 + _ + 粗体文本 + __ （ 这里是两个 _ ) ** + 粗体文本 + _ + 斜体文本 + _ + 粗体文本 + ** __ + 粗体文本 + * + 斜体文本 + * + 粗体文本 + __ 说明： 粗体 中包含 斜体，也就是嵌套的关系，外层 是 粗体，内层 是 斜体 外层是粗体，标识符是两个；内层是斜体，标识符是单个 因为 斜体 是被包裹在 粗体 中的，所以显示效果为 粗斜体 1 2 3 4 5 6 这是一段普通文本 **这里是一段粗体中*包含斜体*的文字** __这也是一段粗体中_包含斜体_的文字__ **这又是一段粗体中_包含斜体_的文字** __这还是一段粗体中*包含斜体*的文字__ 示范 这是一段普通文本\n这里是一段粗体中包含斜体的文字 这也是一段粗体中_包含斜体_的文字 这又是一段粗体中_包含斜体_的文字 这还是一段粗体中包含斜体的文字\n3. 线 3.1 水平分割线 水平分割线由至少 3 个 * 或 - 组成 1 2 3 下面是一条水平分割线： --- *** 示范 3.2 文本删除线 删除线 的格式： ~~ + 文本内容 +~~ 首尾各加两个 ~ 波浪号 1 ~~这是一段加了删除线的文本~~ 示范 这是一段加了删除线的文本\n3.3 文本下划线 下划线的格式，和 HTML 是一样的 \u0026lt;u\u0026gt; + 文本内容 + \u0026lt;/u\u0026gt; 1 \u0026lt;u\u0026gt;这是一段加了下划线的文本\u0026lt;/u\u0026gt; 示范 这是一段加了下划线的文本\n4. 列表\u0026amp;引用 4.1 有序列表 有序列表 的格式：\n1. + 空格 + 文本内容 说明：\n输入文本内容后，敲击 Enter 自动补全格式，并进入 下个 有序列表 若需要在同个列表内，增加 换行显示 的内容 (但不进入下个列表) 敲击 Shift + Enter ，即可另起一行输入文本 在有序列表的中间，插入一个新的列表，后面列表的 数字序号 会自动 递进 一层 即便在源代码模式中修改了数字序号，渲染界面依然是 依照顺序 显示的 1 2 3 4 5 6 7 8 9 1. 这是第一个有序列表 \u0026lt;!-- (Enter) --\u0026gt; 2. 这是第二个有序列表 \u0026lt;!-- (Enter) --\u0026gt; 3. 这是第三个有序列表 1. 这是第一个有序列表 \u0026lt;!-- (Shift + Enter) --\u0026gt; 这是同个列表下，另起一行的文本内容 \u0026lt;!-- (Enter) --\u0026gt; 2. 这是第二个有序列表 \u0026lt;!-- (Shift + Enter) --\u0026gt; 这是同个列表下，另起一行的文本内容 示范 这是第一个有序列表\n这是第二个有序列表\n这是第三个有序列表\n这是第一个有序列表 这是同个列表下，另起一行的文本内容\n这是第二个有序列表 这是同个列表下，另起一行的文本内容\n补充 由于有序列表存在强制排序性，它的数字序号必然是逐一递进的 若你希望内容前的数字，不依照递进顺序排序，或者以 整百，整十数 排序 可以配合无序列表，在无序列表中输入： 数字 + . + 内容\n#注意 点号 与 内容 之间，没有空格 (其实有空格也行，就是会感觉有点奇怪) 1 2 3 4 5 6 7 8 - 10.这是无序列表下，整十数排列的内容 - 20.这是无序列表下，整十数排列的内容 - 30.这是无序列表下，整十数排列的内容 - 100.这是无序列表下，整百数排列的内容 - 200.这是无序列表下，整百数排列的内容 - 300.这是无序列表下，整百数排列的内容 效果：\n10.这是无序列表下，整十数排列的内容 20.这是无序列表下，整十数排列的内容 30.这是无序列表下，整十数排列的内容 100.这是无序列表下，整百数排列的内容 200.这是无序列表下，整百数排列的内容 300.这是无序列表下，整百数排列的内容 4.2 无序列表 无序列表 的格式： - + 空格 + 文本内容 说明： 输入文本内容后，敲击 Enter 自动补全格式，并进入 下个 无序列表 若需要在同个列表内，增加换行显示的内容 (但不进入下个列表) 敲击 Shift + Enter ，即可另起一行输入文本 补充： 在Obsidian中，按下 Ctrl + Enter 即可快速生成一个无序列表 1 2 3 4 5 6 7 8 - 这是第1个无序列表 \u0026lt;!-- (Enter) --\u0026gt; - 这是第2个无序列表 \u0026lt;!-- (Enter) --\u0026gt; - 这是第3个无序列表 - 这是第一个无序列表 \u0026lt;!-- (Shift + Enter) --\u0026gt; 这是同个列表下，另起一行的文本内容 - 这是第二个无序列表 \u0026lt;!-- (Shift + Enter) --\u0026gt; 这是同个列表下，另起一行的文本内容 示范 这是第1个无序列表 这是第2个无序列表 这是第3个无序列表 这是第一个无序列表 这是同个列表下，另起一行的文本内容 这是第二个无序列表 这是同个列表下，另起一行的文本内容 4.3 引用 引用 的格式： \u0026gt; + 文本内容 （不需要空格) 说明： 同个引用段落内的换行直接敲击 Enter 即可 若需添加 第二个独立引用段落 ，连续敲击 两下 Enter 即可 1 2 3 4 5 \u0026gt;这是第一段引用文本的第1行 \u0026lt;!-- (Enter) --\u0026gt; \u0026gt;这是第一段引用文本的第2行 \u0026lt;!-- (Enter) --\u0026gt; \u0026lt;!-- (Enter) --\u0026gt; \u0026gt;这是第二段引用文本的第1行 \u0026lt;!-- (Enter) --\u0026gt; \u0026gt;这是第二段引用文本内第2行 示范 这是第一段引用文本的第1行 这是第一段引用文本的第2行\n这是第二段引用文本的第1行 这是第二段引用文本的第2行\n4.4 缩进\u0026amp;退格 在列表和引用的书写过程中，我们需要利用 ==缩进== 与 ==退格== ，让文章肌理分明，更具层级\n缩进：\nTab Ctrl + [ (左中括号) 退格：\nShift + Tab Ctrl + ] （右中括号） 4.4.1 有序列表的缩\u0026amp;退 1 2 3 4 1. 第一级有序列表1 \u0026lt;!-- (Enter) --\u0026gt; 1. 第二级有序列表1 \u0026lt;!-- 写文本之前，先( Tab 或 Ctrl + ] ) ；写完文本后，再(Enter) --\u0026gt; 2. 第二级有序列表2 \u0026lt;!-- (Enter) --\u0026gt; 2. 第一级有序列表2 \u0026lt;!-- 写文本前，先 ( Shift + Tab 或 Ctrl + [ ) --\u0026gt; 补充说明： 有序列表的数字序号，即便你在源代码模式里 强行改掉 数字，它仍然会 依照顺序 显示 示范 第一级有序列表1 第二级有序列表1 第二级有序列表2 第一级有序列表2 4.4.2 无序列表的缩\u0026amp;退 1 2 3 4 - 第一级无序列表1 \u0026lt;!-- (Enter) --\u0026gt; - 第二级无序列表1 \u0026lt;!-- 写文本前，先( Tab 或 Ctrl + ] ) ；写完后，再(Enter) --\u0026gt; - 第二级无序列表2 \u0026lt;!-- (Enter) --\u0026gt; - 第一级无序列表2 \u0026lt;!-- 写文本前，先 ( Shift + Tab 或 Ctrl + [ ) --\u0026gt; 示范 第一级无序列表1 第二级无序列表1 第二级无序列表2 第一级无序列表2 4.4.3 引用的缩\u0026amp;退 引用的 缩进 和列表 不同 引用需另起一行，并额外多打一个 \u0026gt; 来完成 缩进 引用的 退格 与列表 相同 Shift + Tab Ctrl + ] （右中括号） 1 2 3 4 \u0026gt;第一级引用1 \u0026lt;!-- (enter) --\u0026gt; \u0026gt;\u0026gt;第二级引用1 \u0026lt;!-- 先打1个 \u0026gt; (这里的第一个 \u0026gt; 是会自动补充的，只需额外增补1个即可) ，再(enter) --\u0026gt; \u0026gt;\u0026gt;第二级引用2 \u0026lt;!-- (enter) --\u0026gt; \u0026gt;第一级引用2 \u0026lt;!-- 写文本前，先 ( Shift + Tab 或 Ctrl + [ ) --\u0026gt; 示范 第一级引用1\n第二级引用1 第二级引用2\n第一级引用2\n补充： 在 Obsidian 中，引用的退格是不太一样的 **Obsidian **中，如果想让已经缩进的引用 退回一层 得使用 Shift + Enter ，配合方向键，在多个 \u0026gt; 之间灵活断行 并在下一行 根据需要 选择性补充 \u0026gt; 这个用文字比较难以描述，这里选择用2个带键位的 Gif图 来描述 Gif演示1：\n效果1： 111\n222\n333\n444\n555\nGif演示2： 效果2： 111\n222\n333\n444\n555\n666\n777\n4.4.4 有序\u0026amp;无序\u0026amp;引用 连续套娃 有序列表、无序列表、引用 三者之间，可以相互嵌套 核心键 ： Shift + Enter \u0026amp; Enter \u0026amp; Shift + Tab ( 或 Ctrl + [ ) Shift + Enter 在切换格式的嵌套中，是 自带一层 缩进 效果的 1 2 3 4 5 6 7 8 9 1. 第一级 有序列表1 \u0026lt;!-- (Shift + Enter) --\u0026gt; - 第二级 无序列表1 \u0026lt;!-- (Shift + Enter) --\u0026gt; \u0026gt;第三级 引用1 \u0026lt;!-- (Enter) --\u0026gt; - 第四级 无序列表2 \u0026lt;!-- (Shift + Enter) --\u0026gt; 1. 第五级 有序列表2 \u0026lt;!-- (Enter) --\u0026gt; - 第四级 无序列表3 \u0026lt;!-- 写文本前，先( Shift + Tab 或 Ctrl + [ ) ；写完后再 (Enter) --\u0026gt; \u0026gt;第三级 引用2 \u0026lt;!-- 写文本前，先( Shift + Tab 或 Ctrl + [ ) ；写完后再 (Enter × 2) --\u0026gt; - 第二级 无序列表4 \u0026lt;!-- 写文本前，先( Shift + Tab 或 Ctrl + [ ) --\u0026gt; 2. 第一级 有序列表3 \u0026lt;!-- 写文本前，先( Shift + Tab 或 Ctrl + [ ) --\u0026gt; 示范 第一级 有序列表1\n第二级 无序列表1\n第三级 引用1\n第四级 无序列表2 第五级 有序列表2 第四级 无序列表3 第三级 引用2\n第二级 无序列表4\n第一级 有序列表3\n4.4.5 Obsidian 的一些缩退问题 Obsidian 在列表首行使用缩进的时候，后续的列表会出现一些问题 Tab 和 Shift + tab 会无法 缩进 退格 可以使用 Ctrl + ] 与 Ctrl + [ 来解决问题 1 2 3 - - 这是第一段就被缩进的列表 - 这是第二段被再次缩进的列表 \u0026lt;!-- 这里需按两次 Ctrl + ] ,Tab键是无效的 --\u0026gt; - 这是第三段列表 \u0026lt;!-- Ctrl + [ --\u0026gt; 这是第一段就被缩进的列表 - 这是第二段被再次缩进的列表 这是第三段列表 5. 网页链接与图像 5.1 网页链接 网页链接的 格式： [ + 显示文本内容 + ] + ( + 链接地址 + 空格 + \u0026quot; + 提示信息文本 + \u0026quot; + ) 说明： 显示文本内容，是在渲染界面实际 可见 的文本，用以 说明 链接 提示信息文本，需鼠标悬停于 显示文本内容 方可触发，用于增加额外提示信息 #注意 \u0026quot;提示信息文本\u0026quot; 是可选项，一般不会填 一般来讲，需按住 Ctrl + 鼠标左键点击 才可跳转链接，不过也有 直接鼠标点击 就能跳转的 1 2 3 [显示文本内容](链接地址 \u0026#34;提示信息文本\u0026#34;) [百度一下，你就知道](http://www.baidu.com \u0026#34;按住Ctrl点击跳转百度\u0026#34;) 示范：\n百度一下，你就知道\n5.1.1链接的加粗 格式有两种： 把一对 ** 加在 ==显示文本内容==的首尾 格式1：[**显示文本内容**](链接地址) 效果： 百度一下，你就知道 把一对 ** 加在 链接格式==整体== 的首尾 格式2：**[显示文本内容](链接地址)** 效果： 百度一下，你就知道 5.2 图像 图像格式： 图像格式，就是在网页链接前面加个 ! (英文格式的)，! 代表 可见 图片的提示信息，和网页链接一样，写在 \u0026quot; \u0026quot; 内 [ ] 方括号里的文字信息在 Markdown 没啥实质的作用，只是方便在源代码模式下，知道这个图片是什么，在渲染界面是不会显示的。有点类似于HTML img标签 里的 alt属性。 1 2 3 ![文字信息](图片链接 \u0026#34;提示文本信息\u0026#34;)\t![湘湖1](https://z3.ax1x.com/2021/08/06/fuNkXq.jpg \u0026#34;湘湖一角\u0026#34;) 补充：\n图像链接可以是本地的，也可以是在线的 本地图像直接 Ctrl + C 黏贴，Ctrl + V 复制 就可以 在线图像推荐使用 图床 调整图像的大小需要使用 HTML 和 CSS，在 Typora编辑器 中右键可以直接缩放图片 本质是转成了HTML的格式，最后会有一个 style=\u0026quot;zoom: %;\u0026quot; ，这里数值可以自己修改 如果有使用 Obsidian 的朋友，在线图片链接是通用的。不过，因为 Obsidian 是双向链笔记 它的本地图片格式不太一样 ![[图片名]] Obsidian 中的图片是以双链的格式引用在目标笔记中，用 ! 使它可见 Obsidian的图片设置大小是用 | 分隔，后面写宽度数值，单位是px。 设定好宽度，高度会自动等比例调整 ![[图片名|宽度数值]] - 若想自主调整图片宽高，则用： - ![[图片名|宽度数值x高度数值]] - #提示 这里的 x 是 英文字母x 如果是在线图床，需要调整图片大小： ![图床|宽度数值](链接地址) 示范 6. 表格 Markdown的表格，比HTML简单很多 | 是构成表格的主要 框架 - 区分 表头 和 表格主体 : 控制 表格内 文本内容 的 对齐方式 **Typora编辑器中 ** 输入 Ctrl + T 即可快速插入表格，自由定义样式 1 2 3 4 |这里是表头1|这里是表头2|这里是表头3| |:-|:-:|-:| \u0026lt;!--区分表头和表格主体，:代表文本对齐方式，分别是左对齐，居中对齐，右对齐--\u0026gt; |单元格数据1|单元格数据2|单元格数据3| |单元格数据4|单元格数据5|单元格数据6| 示范 这里是表头1 这里是表头2 这里是表头3 单元格数据1 单元格数据2 单元格数据3 单元格数据4 单元格数据5 单元格数据6 6.1 表格中文本内容的换行 Mardown中表格，它的宽高是由 单元格数据内的文本内容 撑开 的 当我们输入一段很长很长的文本，它所在的单元格会变得过宽 如下图所示：\n表头1 表头2 这是一段很长很长很长很长很长很长很长很长很长很长很长很长很长很长的文本 普通文本 若想对一段长文本进行换行，可以在 中间 插入一个 \u0026lt;br\u0026gt; （ 换行标签 ) 1 2 3 | 表头1 | 表头2 | |:-:|:-:| |这是第一行文本\u0026lt;br\u0026gt;这是另起一行的文本|普通文本| 示范 表头1 表头2 这是第一行文本\n这是另起一行的文本 普通文本 7. 代码域 7.1 行内代码 行内代码 的格式： 输入两个 ` 反引号 ，在中间写代码内容 补充： 行内代码不一定非得写代码，也可以作为**着重标记**，突出显示内容 行内代码中，源代码界面和渲染界面是完全一致的，标识符会失效 所谓行内代码： 只要你的屏幕足够宽，它就不会换行 1 2 3 4 5 6 7 `这是一段行内代码` `\u0026lt;table border=\u0026#34;1\u0026#34; cellspacing=\u0026#34;0\u0026#34; width=\u0026#34;500\u0026#34; height=\u0026#34;500\u0026#34;\u0026gt;` `print(\u0026#34;Hello, World!\u0026#34;)` `这是一行突出显示的文本内容` 示范 \u0026lt;table border=\u0026quot;1\u0026quot; cellspacing=\u0026quot;0\u0026quot; width=\u0026quot;500\u0026quot; height=\u0026quot;500\u0026quot;\u0026gt;\nprint(\u0026quot;Hello, World!\u0026quot;)\n这是一行突出显示的文本内容\n7.2 代码块 代码块 的格式： 在首行和末行各加 三个 ` 反引号 ``` + 语言种类 代码内容 ``` 在首行和末行各加 三个 ~ 波浪号 ~~~ + 语言种类 代码内容 ~~~ 补充： 在代码块也不一定要写代码，可以写一段突出的文本内容，语言类型可以填写 txt 或者 干脆不写 代码块中，源代码界面和渲染界面是完全一致的，标识符会失效 在 Typora编辑器 ，用键盘按键脱离代码块区域，需输入： Ctrl + Enter 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 ```语言种类 代码内容 代码内容 代码内容 ``` 下面是HTML代码块 ```html \u0026lt;table border=\u0026#34;1\u0026#34;\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;row 1, cell 1\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;row 1, cell 2\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;row 2, cell 1\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;row 2, cell 2\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; ``` 下面是CSS代码块 ```css .box { width: 600px; height: 400px; margin: 100px auto; background-image: linear-gradient(black 33.3%,red 33.3%, red 66.6%, yellow 66.6%, yellow); }\t``` 下面是JavaScript代码块 ```js // 定义一个30个整数的数组，按顺序分别赋予从2开始的偶数；然后按顺序每五个数求出一个平均值，放在另一个数组中并输出。试编程 let arr = [2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60] let newarr = []; for (let i = 0, count = 0, sum = 0, len = arr.length; i \u0026lt; len; i++) { sum += arr.shift(); count++; if (count % 5 === 0) { newarr.push(sum / 5); sum = 0; } } console.log(newarr); let arr = [2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60] let newarr = []; for (let i = 0, len = arr.length; i \u0026lt; len / 5; i++) { let subarr = arr.splice(0, 5) for (let j = 0, sum = 0; j \u0026lt; subarr.length; j++) { sum += subarr[j]; } newarr.push(sum / 5); } console.log(newarr); ``` 下面是Python代码块 ```python #!/usr/bin/python # -*- coding: UTF-8 -*- i = 2 while(i \u0026lt; 100): j = 2 while(j \u0026lt;= (i/j)): if not(i%j): break j = j + 1 if (j \u0026gt; i/j) : print i, \u0026#34; 是素数\u0026#34; i = i + 1 print \u0026#34;Good bye!\u0026#34; ``` 下面是一块突出显示的文本 ```txt 这是一段 突出显示的 文本内容 ``` 示范 1 2 3 4 5 6 7 8 9 10 \u0026lt;table border=\u0026#34;1\u0026#34;\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;row 1, cell 1\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;row 1, cell 2\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;row 2, cell 1\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;row 2, cell 2\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; 1 2 3 4 5 6 .box { width: 600px; height: 400px; margin: 100px auto; background-image: linear-gradient(black 33.3%, red 33.3%, red 66.6%, yellow 66.6%, yellow); }\t1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // 定义一个30个整数的数组，按顺序分别赋予从2开始的偶数；然后按顺序每五个数求出一个平均值，放在另一个数组中并输出。试编程 let arr = [2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60] let newarr = []; for (let i = 0, count = 0, sum = 0, len = arr.length; i \u0026lt; len; i++) { sum += arr.shift(); count++; if (count % 5 === 0) { newarr.push(sum / 5); sum = 0; } } console.log(newarr); let arr = [2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60] let newarr = []; for (let i = 0, len = arr.length; i \u0026lt; len / 5; i++) { let subarr = arr.splice(0, 5) for (let j = 0, sum = 0; j \u0026lt; subarr.length; j++) { sum += subarr[j]; } newarr.push(sum / 5); } console.log(newarr); 1 2 3 4 5 6 7 8 9 10 11 12 13 #!/usr/bin/python # -*- coding: UTF-8 -*- i = 2 while(i \u0026lt; 100): j = 2 while(j \u0026lt;= (i/j)): if not(i%j): break j = j + 1 if (j \u0026gt; i/j) : print i, \u0026#34; 是素数\u0026#34; i = i + 1 print \u0026#34;Good bye!\u0026#34; 1 2 3 这是一段 突出显示的 文本内容 7.2.1 代码块的嵌套 格式：\n使用4个 ` 包裹 3个 ` 示范 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ````txt ```js // 3. 输出 100以内(不包括100) 所有偶数的和 // 这类求和问题的核心 ： 利用循环 (总和 = 旧数的和 + 新数) let sum = 0; for (let i = 1, sum = 0; i \u0026lt; 100; i++) { if (i % 2 == 0) { // 筛选偶数 sum += i; // sum = sum + i // 累加偶数并赋值给sum // sum为(旧的，已经进入循环的数)的和，i 为新进入循环的数。当加到(最后一个新数i)时，sum就是最后的 总和 } } console.log(sum); // 打印总和 ``` ```` 如果要再套一层，就在最外层 加 5个 ` ，以此类推……\n7.3 如何在行内代码里显示反引号 首尾各用 两个反引号`+ 空格 包裹\n格式：\n1 2 3 ``+空格+带`的内容+空格+`` \u0026lt;!-- 不要忘记前后的两个空格 --\u0026gt; `` 这是一段能显示`反引号`的行内代码 `` 效果：\n这是一段能显示`反引号`的行内代码\n8. 任务列表（待办） 任务列表 的格式：\n- + 空格 +[ ] +空格 + 任务列表内容 ( 中括号[ ] 里面必须有个空格) 给待办任务列表打 √ ，变成 已办 在渲染界面，直接鼠标左键点击框框 在源代码界面，在中括号内输入 英文字母x 部分编辑器，在 中括号内 输入任意字符都可以打 √ ( 例如 Obsidian ) 补充：\n大部分 MD编辑器 支持输入第一个任务列表后，按下 Enter 进入下一行会 自动补全待办格式 在Obsidian中，连续输入两次 Ctrl + Enter ，即可生成一个待办列表 再输入一次 Ctrl + Enter ，会在待办列表 打 √ 格式：\n1 2 3 4 - [ ] 待办任务列表1 - [ ] 待办任务列表2 - [x] 已办任务列表1 \u0026lt;!-- 英文字母X --\u0026gt; - [x] 已办任务列表2 示范 待办任务列表1 待办任务列表2 已办任务列表1 已办任务列表2 在 Obsidian 中，可以利用 Ctrl + Enter ，快速生成任务列表 - + 空格 + Ctrl + Enter +待办文本内容 待办文本内容 + Ctrl + Enter ×2 ( 输入文本后，连续2次 Ctrl + enter ) 任务列表也是可以缩进+退格的，操作跟 无序、有序列表一样 示范 第一级待办列表1 第二级待办列表1 另起一行的第二级待办列表1 第三级已办列表1 第三级已办列表2 第二级待办列表2 另起一行的第二级待办列表2 第一级待办列表2 9. 注释 Markdown 的 注释 和 HMTL 一样，注释的内容在 渲染界面 不可见 （部分编辑器可见)\n注释 的格式： \u0026lt;!-- 这里是注释的内容 --\u0026gt; 注释可以是单行，也可以是多行 如果有在使用 Obsidian 的，它的注释格式是不一样的 %%这是Obsidian的注释内容%% 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026lt;!-- 这里是一行注释 --\u0026gt; \u0026lt;!-- 这里是 一段 假装有 很多行的 注释 --\u0026gt; %%这是一行Obsidian里的注释%% %% 这里是 一段 假装有 很多行的 Obsidian里的 注释 %% 示范 (只有切换至 编辑模式 才能看到喔) %%这是一行Obsidian里的注释%%\n%% 这里是 一段 假装有 很多行的 Obsidian里的 注释 %%\n10. 变量 10.1 网页链接变量 网页链接变量 的格式： 首先输入 [显示文本内容] + [变量名] 变量名可以自己取，没啥限制，任意字符都可以 在文档任意一个区域，输入： [变量名] + : + 空格 + 链接地址 （这个**空格** 不打也没事) 1 2 3 4 5 6 [百度一下，你就知道][度娘] [知乎-有问题，就会有答案][知乎] \u0026lt;!-- 这里是变量区域 --\u0026gt; [度娘]: http://www.baidu.com [知乎]: https://www.zhihu.com 示范 百度一下，你就知道\n知乎-有问题，就会有答案\n10.2 脚注 脚注 的格式： 在需要脚注的地方，输入： [^脚注代号] ( 脚注代号会直接显示在渲染界面 ) 脚注代号可以随便命名，不过推荐使用 数字序号 在其他区域，输入： [^脚注代号] + : + 空格 + 脚注内容 （这个 空格 不打也没事) 1 2 3 4 5 鲁迅原名是什么[^1] ，浙江哪里人[^2] \u0026lt;!-- 这里是变量区域 --\u0026gt; [^1]: 周树人 [^2]: 绍兴人 示范 鲁迅原名是什么1，浙江哪里人2\n11. 拓展文本格式标记 Markdown 想实现更多的文本显示效果，只能依赖HTML标记实现 个人不是很推荐在 MD 中使用 HTML，不过一些简单的标记还是可以 轻度使用 的 11.1 键盘文本 键盘文本的 格式：\n\u0026lt;kbd\u0026gt;键盘文本\u0026lt;/kbd\u0026gt; \u0026lt;kbd\u0026gt;Ctrl\u0026lt;/kbd\u0026gt; + \u0026lt;kbd\u0026gt;X\u0026lt;/kbd\u0026gt; 效果：\n键盘文本 Ctrl + X ( 剪切 ) 说明：\n键盘文本也不一定非得是键盘按键，也可以作为着重文本突出显示 效果： 这也算一种着重文本的方式 11.1.1 加粗键盘文本 加粗键盘文本的格式有两种：\n\u0026lt;kbd\u0026gt;**键盘文本**\u0026lt;/kbd\u0026gt; **\u0026lt;kbd\u0026gt;ctrl + x\u0026lt;/kbd\u0026gt;** 效果：\n键盘文本 ctrl + x 11.2 放大文本 放大文本 的格式：\n这是一段普通文本 \u0026lt;big\u0026gt;这是一段放大文本\u0026lt;/big\u0026gt; 效果：\n这是一段普通文本 这是一段放大文本 11.2.1 放大粗体文本 放大加粗文本的格式有两种： **\u0026lt;big\u0026gt;这是一段放大粗体文本\u0026lt;/big\u0026gt;** \u0026lt;big\u0026gt;**这是一段放大粗体文本**\u0026lt;/big\u0026gt; 效果： 这是一段放大粗体文本 这是一段放大粗体文本 11.3 缩小文本 缩小文本 的格式： 这是一段普通文本 \u0026lt;small\u0026gt;这是一段缩小文本\u0026lt;/small\u0026gt; 效果： 这是一段普通文本 这是一段缩小文本 11.3.1 缩小斜体文本 斜体缩小文本 的格式有两种： \u0026lt;small\u0026gt;*这是一段缩小斜体文本*\u0026lt;/small\u0026gt; *\u0026lt;small\u0026gt;这是一段缩小斜体文本\u0026lt;/small\u0026gt;* 效果： 这是一段缩小斜体文本 这是一段缩小斜体文本 11.4 多彩文本 多彩文本 的格式： \u0026lt;font color=orange\u0026gt;这是一段橘色文本\u0026lt;/font\u0026gt; 效果： 这是一段橘色文本 color 里的颜色支持 英文单词，16进制，rgb，rgba 11.4.1 多彩粗体文本 只需要在上面示例的基础上，加上 加粗标识符，有两种格式： 格式1： **\u0026lt;font color=teal\u0026gt;这是一段加粗的水鸭色文本\u0026lt;/font\u0026gt;** 效果： 这是一段加粗的水鸭色文本 格式2： \u0026lt;font color=teal\u0026gt;**这是一段加粗的水鸭色文本**\u0026lt;/font\u0026gt; 效果： 这是一段加粗的水鸭色文本 若上述混搭方法的样式失效 ，可以使用 纯HTML标记 格式： \u0026lt;strong style=\u0026quot;color:teal;\u0026quot;\u0026gt;这是一段加粗的水鸭色文本\u0026lt;/strong\u0026gt; (标记略复杂，不是很推荐) 效果： 这是一段加粗的水鸭色文本 11.4.2 多彩斜体文本 跟多彩加粗文本完全一样，只需把首尾的 ** 换成 * 即可 格式1： *\u0026lt;font color=teal\u0026gt;This is an italic teal text\u0026lt;/font\u0026gt;* 效果： This is an italic teal text 格式2： \u0026lt;font color=teal\u0026gt;*This is an italic teal text*\u0026lt;/font\u0026gt; 效果： This is an italic teal text 11.4.2 多彩粗斜体文本 首尾换成 *** 格式1： ***\u0026lt;font color=teal\u0026gt;This is a bold italic teal text\u0026lt;/font\u0026gt;*** 效果： This is a bold italic teal text 格式2： \u0026lt;font color=teal\u0026gt;***This is a bold italic teal text***\u0026lt;/font\u0026gt; 效果： This is a bold italic teal text #注意 多彩文本尽量慎用，Markdown 的核心就是 简洁精炼，注重 实质内容，而非花哨的 颜色样式\n12. 拓展文本显示效果 拓展显示效果既不是原生 Markdown语法 支持的，也非 HTML标记，而是部分编辑器 提供的 额外标识符，属于拓展语法，旨在为 Markdown使用者 提供更多样式选择 不同编辑器，支持不一样，这里以 Typora编辑器 为例 12.1 文本高亮 文本高亮 的格式： ==这里是一段高亮文本== 效果： ==这里是一段高亮文本== 12.2 上标 用一对 ^ 包裹 (Shift+ 6) 格式： x^2^ 效果： x^2^ Obsidian 没效果的，可以用后面会讲的 Latex 或者，也可以使用 HTML标记 \u0026lt;sup\u0026gt;这里是上标内容\u0026lt;/sup\u0026gt; X\u0026lt;sup\u0026gt;2\u0026lt;/sup\u0026gt; 效果： X2 12.3 下标 用一对 ~ 包裹 (Shift + `) 格式： H~2~O 效果： H2O Obsidian 没效果的，可以用后面会讲的 Latex 或者，也可以使用 HTML标记 \u0026lt;sub\u0026gt;这里是下标内容\u0026lt;/sub\u0026gt; H\u0026lt;sub\u0026gt;2\u0026lt;/sub\u0026gt;O 效果： H2O 12.4 Emoji 符号 用一对 : 包裹，里面是 Emoji 符号的 语义化文本 ( Typora编辑器 中，输入 : 就会带提示器 )\n示例： :smile: :sweat: :cat: :woman_cartwheeling: 效果： :smile: :sweat: :cat: :woman_cartwheeling: 补充： 不支持上述方式的 MD编辑器或笔记软件，直接用 输入法 输入也是可以的 Windows系统 用户 win + . 就可以输入 Emoji 了 Obsidian 用户可以安装第三方插件来支持 Emoji 的输入，推荐两个 ==Emoji Shortcodes== ==Emoji Toolbar== 13. 转义字符 在 Markdown 中，我们 通过 标识符 改变 文本显示效果 现在我们希望它不作为标识符，而是 作为字符本身呈现出来 （不具备改变文本显示效果的功能，只是一个普通字符) 首先我们可以用前面介绍的 代码域 ，因为代码模式的显示效果就是源代码完全一致的 还有一种方法，可以利用转义字符，在这些标识符 前面 加上 反斜线 \\ ( 反斜线要紧贴在标识符前面，不能 有 空格 ) 原理： \\ 的作用是让标识符 转义 变为一个普通字符，完成这个效果后，反斜线会自动隐藏 隐藏后的反斜线仅在源代码界面可见，在渲染界面不可见 反斜线只争对标识符起作用，其他字符添加 \\，\\ 不会自动隐藏 补充： 如果想给已经被加在标识符前面，会自动隐藏的 \\ 显示出来，可以在反斜线前面再加一个 \\ ，用它自己来转义自己 示例： 这里紧跟在标识符前面的反斜线\\\\*会被转义成普通字符显示出来，不会自动隐藏，且这段文件会是斜体* **效果： ** 这里紧跟在标识符前面的 反斜线\\会被转义成普通字符显示出来，不会自动隐藏，且这段文件会是斜体 例1 以普通字符显示星号 如何让被一对或多对 * 号 包裹的文本内容，能够正常显示 * ，且文本不改变格式 \\*这段文本被一对星号包裹，但不会倾斜\\* 效果： *这段文本被1对星号包裹，但不会倾斜* \\*\\*这段文本被2对星号包裹，但不会加粗\\*\\* 效果： **这段文本被2对星号包裹，但不会加粗** \\*\\*\\*这段文本被3对星号包裹，但它既不倾斜也不加粗\\*\\*\\* 效果： ***这段文本被3对星号包裹，但它既不倾斜也不加粗*** 例2 表格内 单元格中的竖杠 在表格中，使用 | 作为单元格的内容，但不会被识别为表格的结构，不会增加额外的单元格 1 2 3 |表头1|表头2| |-|-| |这里的文本被\\|分隔|这里的文本也被\\|分隔| 效果： 表头1 表头2 这里的文本被|分隔 这里的文本也被|分隔 #补充 该技巧可用于 Obsidian 表格内 双链的文本修饰\n文本修饰：\n在 双链[[ ]]内 以 | 引导的内容\n格式： [[链接的内容|文本修饰]] 说明： 文本修饰是渲染界面实际显示的文本，便于更好地融入语境 表格内的格式：\n在 | 前面加上 \\\n[[表格内的链接内容\\|文本修饰]] 示例：\n1 2 3 | 表头1 | 表头2 | |:---------------------------------------:|:---------------------------------------------------:| | [[#例2 表格内 单元格中的竖杠\\|单元格中的竖杠]] | [[#例3 不会变成代码的反引号\\|不会变成代码的反引号]] | 效果：\n表头1 表头2 [[#例2 表格内 单元格中的竖杠|单元格中的竖杠]] [[#例3 不会变成代码的反引号|不会变成代码的反引号]] 例3 不会变成代码的反引号 使用 转义符号\\ 让 反引号` 变成普通字符，不再具有[[#7 1 行内代码|行内代码]]的标识符功能\n格式：\n\\`这段被反引号包裹的内容不会变成行内代码\\`\n效果：\n`这段被反引号包裹的内容不会变成行内代码`\n例4 链接中的中括号 在 网页链接 的 显示文本内容 中，使用 中括号 [ ]\n在显示文本内容中，在其中一个中括号前面，加上转义符号 反斜杠 \\ 格式： [链接里的 \\[中括号\\] 能被正常显示](https://www.runoob.com) 效果： 链接里的 \\[中括号\\] 能被正常显示 例5 不是列表的连接符(横杠) 引用一段话，一般会在换行之后，加上 - 出处 因为 - 是标识符，会变成一个无序列表 如下所示：\nThe Web, the Tree, and the String. 写作之难，在于把网状的思考，用树状结构，体现在线性展开的语句里。\n史蒂芬·平克 解决方法：\n在 - 前面加上 转义符号 \\ 1 2 3 \u0026gt;The Web, the Tree, and the String. \u0026gt;写作之难，在于把网状的思考，用树状结构，体现在线性展开的语句里。 \u0026gt;\\- 史蒂芬·平克 \u0026lt;!-- 加上转义符号 \\ , 不会变成无序列表 --\u0026gt; 效果：\nThe Web, the Tree, and the String. 写作之难，在于把网状的思考，用树状结构，体现在线性展开的语句里。 - 史蒂芬·平克\n例6 不是标题的 # 让 # 不被识别为标题标识符\n格式：\n\\# 这里的内容不会被识别为标题\n效果：\n# 这里的内容不会被识别为标题\n例7 不会注释的 % 在 Obsidian 中 注释是前后各两个 % 号\n使用 转义符号\\，让 %% 作为普通字符显示出来，不具备注释的功能\n格式： \\%\\%这里的内容可以被显示喔\\%\\% 效果： %%这里的内容可以被显示喔%% 例8 木有链接的双链 Obsidian 的双向链格式是2个方括号 [[ ]] (双方)，使用 转义符号\\，让 [ ] 不再具有 双链功能\n格式：\n\\[\\[这段文本被双方包裹，但不是一个双向链\\]\\]\n效果：\n\\[\\[这段文本被双方包裹，但不是一个双向链\\]]\n例9 页链接里 显示文本内的 中括号 使用转义符号\\，让中括号可以作为显示文本 在[[#5 1 网页链接|网页链接]]中显示出来\n格式：\n1 [\\[这是一个带中括号的网页链接显示文本，点击会跳转至百度\\]](https://www.baidu.com/) 效果：\n\\[这是一个带中括号的网页链接显示文本，点击会跳转至百度\\]\n特殊情况 文本修饰的中括号 文本修饰的 中括号[ ] 不需要使用 转义符号\\\n示范：\n[[#例8 木有链接的双链|[这是一个带中括号的文本修饰]]]\n效果：\n[[#例8 木有链接的双链|[这是一个带中括号的文本修饰]]]\n14. 空格\u0026amp;换行\u0026amp;强制删除 14.1 空格 在一些编辑器或者支持MD的笔记软件里，无论你打多少个空格，它只会显示单个 空格 的距离 可以使用 HTML中 空格 的 字符实体 —— \u0026amp;nbsp; 若要添加 多个 空格，就输入多个 —— \u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp; 格式： 这里有\u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;6个空格分隔 效果： 这里有 6个空格分隔 14.2 换行 场景1：\n在一些编辑器或者支持MD的笔记软件里，无论你打多少个 回车，它只会显示单个 回车 的空行间距 可以使用之前表格里提到的 \u0026lt;br\u0026gt; 标签，在 单独一行 中使用，增加额外的空行间距 如果要增加 多个，就输入 多个 —— \u0026lt;br\u0026gt;\u0026lt;br\u0026gt;\u0026lt;br\u0026gt;\u0026lt;br\u0026gt;\u0026lt;br\u0026gt; #注意 当单独一行使用 \u0026lt;br\u0026gt; 标签的时候，如果前后有标题标识符或者列表标识符，确保 br元素 前后两行都是空白行 格式：\n1 2 3 4 5 这里是第一段文本 \u0026lt;br\u0026gt;\u0026lt;br\u0026gt;\u0026lt;br\u0026gt;\u0026lt;br\u0026gt;\u0026lt;br\u0026gt; \u0026lt;!-- 这里插入了5个空行间距 --\u0026gt; 这里是第二段文本 效果：\n这里是第一段文本\n这里是第二段文本\n场景2：\n在列表中也可以插入换行符 1 2 3 4 - 这是一段无序列表 \u0026lt;br\u0026gt; \u0026lt;!-- 插入一个空行间距，需单独一行，上下不用预留空格 --\u0026gt; 这是同一段无序列表中，空一行距离显示的内容 - 这是第二段无序列表 效果：\n这里是第一段无序列表 这里是同一段无序列表中，空一行距离显示的内容 这里是第二段无序列表 补充： 有一些MD编辑器或笔记软件，严格遵循MD的换行规则，你敲一个回车是没法换行的，必须在 行末 敲 2个空格，再按回车键 格式： 这里是一段想换行的文本空格 空格 Enter 这是换行后的文本 14.3 强制删除 很多编辑器都有英文标点自动补全功能，自动生成一对，光标落在中间 只想删除前面1个，却会把 一整对 都删掉 在多个列表的嵌套中，也许会遇到一些 无法被删除 的 列表标识符 解决方法： 使用 Shift + Backspace 即可强制删除 Bcakspace ( 退格键 ) 15. 嵌入 嵌入都是依赖 HTML标签 实现的，嵌入的都是在线链接格式 如果是本地的，Obsidian 中音频是有自带的可录制的录音机插件的，其他的 音频、视频 直接复制黏贴就可以了，也可以直接拖拽到OB的笔记界面 其他的媒体文件在 Obsidian 也和图片一样，以双链的格式引用在目标笔记中，使用 ! 使它可见 15.1 嵌入音频 格式：\n\u0026lt;audio controls=\u0026quot;controls\u0026quot; preload=\u0026quot;none\u0026quot; src=\u0026quot;音频链接地址\u0026quot;\u0026gt;\u0026lt;/audio\u0026gt; 示例：\n1 \u0026lt;audio controls=\u0026#34;controls\u0026#34; preload=\u0026#34;none\u0026#34; src=\u0026#34;https://www.ldoceonline.com/media/english/exaProns/p008-001803372.mp3?version=1.2.37\u0026#34;\u0026gt;\u0026lt;/audio\u0026gt; 效果： 15.2 嵌入视频 格式： 1 2 3 4 5 \u0026lt;video width=\u0026#34;600\u0026#34; height=\u0026#34;420\u0026#34; controls\u0026gt; \u0026lt;source src=\u0026#34;movie.mp4\u0026#34; type=\u0026#34;video/mp4\u0026#34;\u0026gt; \u0026lt;source src=\u0026#34;movie.ogg\u0026#34; type=\u0026#34;video/ogg\u0026#34;\u0026gt; \u0026lt;source src=\u0026#34;movie.webm\u0026#34; type=\u0026#34;video/webm\u0026#34;\u0026gt; \u0026lt;/video\u0026gt; 说明： width ( 宽度 ) height ( 高度 ) ，可以自己设置，直接输入数字即可，单位默认是 px(像素) 也可以使用 百分比 width=100% 代表水平撑满整个窗口 height=50% 代表垂直撑满半个窗口 Video标签 支持的视频格式 ：MP4 ogg webm 15.3 嵌入页面 格式： \u0026lt;iframe width=600 height=400 src=\u0026quot;页面链接地址\u0026quot; scrolling=\u0026quot;auto\u0026quot; border=\u0026quot;0\u0026quot; frameborder=\u0026quot;no\u0026quot; framespacing=\u0026quot;0\u0026quot; allowfullscreen=\u0026quot;true\u0026quot;\u0026gt; \u0026lt;/iframe\u0026gt; 1 \u0026lt;iframe width=600 height=400 src=\u0026#34;https://www.runoob.com/html/html-tutorial.html\u0026#34; scrolling=\u0026#34;auto\u0026#34; border=\u0026#34;0\u0026#34; frameborder=\u0026#34;no\u0026#34; framespacing=\u0026#34;0\u0026#34; allowfullscreen=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;/iframe\u0026gt; 效果： iframe标签 除了嵌入页面，也可以嵌入在线视频，主流的视频网站都会提供嵌入代码\n具体可以看这个 iframe视频嵌入教程 B站 的视频，得在 // 前面补充 http: 不是所有的 编辑器和笔记软件 都支持这个 示例：\n1 \u0026lt;iframe width=600 height=400 src=\u0026#34;http://player.bilibili.com/player.html?aid=20190823\u0026amp;bvid=BV1yW411s7og\u0026amp;cid=32964980\u0026amp;page=1\u0026#34; scrolling=\u0026#34;no\u0026#34; border=\u0026#34;0\u0026#34; frameborder=\u0026#34;no\u0026#34; framespacing=\u0026#34;0\u0026#34; allowfullscreen=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;/iframe\u0026gt; 宽高设置和前面的 video 一样 效果： 16. Latex 数学公式 主要用于 数学公式 与 化学公式 的书写 16.1 行内公式 格式：\n$ + 行内公式 + $ 示例： $x^2 + 2x + 5 + \\sqrt x = 0$ $\\ce{CO2 + C -\u0026gt; 2 CO}$ $\\ce{CO2 + C -\u0026gt; 2 CO}$ $\\ce{2Mg + O2 -\u0026gt;[燃烧] 2 MgO}$ 效果： $x^2 + 2x + 5 + \\sqrt x = 0$ $e^{i\\pi} + 1 = 0$ $\\ce{CO2 + C -\u0026gt; 2 CO}$ $\\ce{2Mg + O2 -\u0026gt;[燃烧] 2 MgO}$ 16.2 公式块 格式： $$ 公式块 $$ 示例： 1 2 3 4 % 化学公式 $$ \\ce{Zn^2+ \u0026lt;=\u0026gt;[+ 2OH-][+ 2H+] $\\underset{\\text{amphoteres Hydroxid}}{\\ce{Zn(OH)2 v}}$ \u0026lt;=\u0026gt;[+ 2OH-][+ 2H+] $\\underset{\\text{Hydroxozikat}}{\\ce{[Zn(OH)4]^2-}}$} $$ 1 2 3 4 5 6 7 8 9 % 麦克斯韦方程组 $$ \\begin{array}{lll} \\nabla\\times E \u0026amp;=\u0026amp; -\\;\\frac{\\partial{B}}{\\partial{t}} \\ \\nabla\\times H \u0026amp;=\u0026amp; \\frac{\\partial{D}}{\\partial{t}}+J \\ \\nabla\\cdot D \u0026amp;=\u0026amp; \\rho \\ \\nabla\\cdot B \u0026amp;=\u0026amp; 0 \\ \\end{array} $$ 1 2 3 4 % 薛定谔方程 $$ i\\hbar\\frac{\\partial \\psi}{\\partial t} = \\frac{-\\hbar^2}{2m} \\left(\\frac{\\partial^2}{\\partial x^2} + \\frac{\\partial^2}{\\partial y^2}+\\frac{\\partial^2}{\\partial z^2} \\right) \\psi + V \\psi $$ 效果： $$ % 化学公式 \\ce{Zn^2+ \u003c=\u003e[+ 2OH-][+ 2H+] $\\underset{\\text{amphoteres Hydroxid}}{\\ce{Zn(OH)2 v}}$ \u003c=\u003e[+ 2OH-][+ 2H+] $\\underset{\\text{Hydroxozikat}}{\\ce{[Zn(OH)4]^2-}}$} $$\n$$ % 麦克斯韦方程组 \\begin{array}{lll} \\nabla\\times E \u0026=\u0026 -\\;\\frac{\\partial{B}}{\\partial{t}} \\ \\nabla\\times H \u0026=\u0026 \\frac{\\partial{D}}{\\partial{t}}+J \\ \\nabla\\cdot D \u0026=\u0026 \\rho \\ \\nabla\\cdot B \u0026=\u0026 0 \\ \\end{array} $$\n$$ i\\hbar\\frac{\\partial \\psi}{\\partial t} = \\frac{-\\hbar^2}{2m} \\left(\\frac{\\partial^2}{\\partial x^2} + \\frac{\\partial^2}{\\partial y^2}+\\frac{\\partial^2}{\\partial z^2} \\right) \\psi + V \\psi $$ 补充： 需要详细教程的，可戳下方链接 Latex详细教程 17. Mermaid 一些 MD编辑器 和 笔记软件 支持通过 Mermaid 及其所提供的 编译器 来为用户提供图表的绘制功能\n这里只提供一些演示的图表，具体教程可戳下方\n[[MOC Mermiad 教程 Obsidian版| Mermiad 超级教程 Obsidian版]] 17.1 流程图 源码1：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 ```mermaid graph TB %% s=start e=end f=fork n=normal s([开始])--\u0026gt;f1{{if条件}}; %% 分支点2 f1--true--\u0026gt;n1[if语句块]--\u0026gt;e([结束]); f1--false--\u0026gt;f2{{else if条件}}; %% 分支点1 f2--true--\u0026gt;n2[else if语句块]--\u0026gt;e; f2--false--\u0026gt;n3[else语句块]--\u0026gt;e; ``` 渲染1：\n1 2 3 4 5 6 7 8 9 10 11 12 graph TB %% s=start e=end f=fork n=normal s([开始])--\u0026gt;f1{{if条件}}; %% 分支点1 f1--true--\u0026gt;n1[if语句块]--\u0026gt;e([结束]); f1--false--\u0026gt;f2{{else if条件}}; %% 分支点2 f2--true--\u0026gt;n2[else if语句块]--\u0026gt;e; f2--false--\u0026gt;n3[else语句块]--\u0026gt;e; 源码2：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 ```mermaid graph LR %% s=start e=end f= fork n=normal %% 虚线 s[朱百六]-.-\u0026gt;|子|n1[朱四九]-.-\u0026gt;|子|n2[朱五四]-.-\u0026gt;|子|f1_帝((朱八八)) %% 分支点 朱八八 f1_帝--\u0026gt;|长子|f2[朱标] f1_帝--\u0026gt;|次子|n3[朱樉] f1_帝--\u0026gt;|三子|n4[朱棢] f1_帝--\u0026gt;|四子|n5_帝((朱棣)) %% 分支点 朱标 f2--\u0026gt;|长子|e1[朱雄英] f2--\u0026gt;|次子|e2_帝((朱允炆)) n5_帝--\u0026gt;|长子|e3[朱高炽] ``` 渲染2：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 graph LR %% s=start e=end f= fork n=normal %% 虚线 s[朱百六]-.-\u0026gt;|子|n1[朱四九]-.-\u0026gt;|子|n2[朱五四]-.-\u0026gt;|子|f1_帝((朱八八)) %% 分支点 朱八八 f1_帝--\u0026gt;|长子|f2[朱标] f1_帝--\u0026gt;|次子|n3[朱樉] f1_帝--\u0026gt;|三子|n4[朱棢] f1_帝--\u0026gt;|四子|n5_帝((朱棣)) %% 分支点 朱标 f2--\u0026gt;|长子|e1[朱雄英] f2--\u0026gt;|次子|e2_帝((朱允炆)) n5_帝--\u0026gt;|长子|e3[朱高炽] 17.2 饼图 源码：\n1 2 3 4 5 6 7 8 ```mermaid pie title 为什么总是宅在家里？ \u0026#34;喜欢宅\u0026#34; : 45 \u0026#34;天气太热\u0026#34; : 70 \u0026#34;穷\u0026#34; : 500 \u0026#34;关你屁事\u0026#34; : 95 ``` 渲染：\n1 2 3 4 5 6 pie title 为什么总是宅在家里？ \u0026#34;喜欢宅\u0026#34; : 45 \u0026#34;天气太热\u0026#34; : 70 \u0026#34;穷\u0026#34; : 500 \u0026#34;关你屁事\u0026#34; : 95 17.3 序列图 (时序图) 源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 ```mermaid sequenceDiagram %% 自动编号 autonumber %% 定义参与者并取别名，aliases：别名 participant A as Aly participant B as Bob participant C as CofCai %% 便签说明 Note left of A: 只复习了一部分 Note right of B: 没复习 Note over A,B: are contacting A-\u0026gt;\u0026gt;B: 明天是要考试吗？ B--\u0026gt;\u0026gt;A: 好像是的！ %% 显示并行发生的动作，parallel：平行 %% par [action1] rect rgb(0, 25, 155) par askA C --\u0026gt;\u0026gt; A:你复习好了吗？ and askB C --\u0026gt;\u0026gt; B:你复习好了吗？ and self C -\u0026gt;\u0026gt;C:我还没准备复习...... end end %% 背景高亮，提供一个有颜色的背景矩形 rect rgb(25, 55, 0) loop 自问/Every min %% \u0026lt;br/\u0026gt;可以换行 C -\u0026gt;\u0026gt; C:我什么时候\u0026lt;br/\u0026gt;开始复习呢？ end end %% 可选择路径 rect rgb(153, 83, 60) alt is good A -\u0026gt;\u0026gt; C:复习了一点 else is common B -\u0026gt;\u0026gt; C:我也是 end %% 没有else时可以提供默认的opt opt Extra response C -\u0026gt;\u0026gt; C:你们怎么不回答我 end endsequenceDiagram %% 自动编号 autonumber %% 定义参与者并取别名，aliases：别名 participant A as Aly participant B as Bob participant C as CofCai %% 便签说明 Note left of A: 只复习了一部分 Note right of B: 没复习 Note over A,B: are contacting A-\u0026gt;\u0026gt;B: 明天是要考试吗？ B--\u0026gt;\u0026gt;A: 好像是的！ %% 显示并行发生的动作，parallel：平行 %% par [action1] rect rgb(0, 25, 155) par askA C --\u0026gt;\u0026gt; A:你复习好了吗？ and askB C --\u0026gt;\u0026gt; B:你复习好了吗？ and self C -\u0026gt;\u0026gt;C:我还没准备复习...... end end %% 背景高亮，提供一个有颜色的背景矩形 rect rgb(25, 55, 0) loop 自问/Every min %% \u0026lt;br/\u0026gt;可以换行 C -\u0026gt;\u0026gt; C:我什么时候\u0026lt;br/\u0026gt;开始复习呢？ end end %% 可选择路径 rect rgb(153, 83, 60) alt is good A -\u0026gt;\u0026gt; C:复习了一点 else is common B -\u0026gt;\u0026gt; C:我也是 end %% 没有else时可以提供默认的opt opt Extra response C -\u0026gt;\u0026gt; C:你们怎么不回答我 end end ``` 渲染：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 sequenceDiagram %% 自动编号 autonumber %% 定义参与者并取别名，aliases：别名 participant A as Aly participant B as Bob participant C as CofCai %% 便签说明 Note left of A: 只复习了一部分 Note right of B: 没复习 Note over A,B: are contacting A-\u0026gt;\u0026gt;B: 明天是要考试吗？ B--\u0026gt;\u0026gt;A: 好像是的！ %% 显示并行发生的动作，parallel：平行 %% par [action1] rect rgb(0, 25, 155) par askA C --\u0026gt;\u0026gt; A:你复习好了吗？ and askB C --\u0026gt;\u0026gt; B:你复习好了吗？ and self C -\u0026gt;\u0026gt;C:我还没准备复习...... end end %% 背景高亮，提供一个有颜色的背景矩形 rect rgb(25, 55, 0) loop 自问/Every min %% \u0026lt;br/\u0026gt;可以换行 C -\u0026gt;\u0026gt; C:我什么时候\u0026lt;br/\u0026gt;开始复习呢？ end end %% 可选择路径 rect rgb(153, 83, 60) alt is good A -\u0026gt;\u0026gt; C:复习了一点 else is common B -\u0026gt;\u0026gt; C:我也是 end %% 没有else时可以提供默认的opt opt Extra response C -\u0026gt;\u0026gt; C:你们怎么不回答我 end end 17.4 甘特图 源码：\n1 2 3 4 5 6 7 8 9 10 11 ```mermaid gantt title A Gantt Diagram dateFormat YYYY-MM-DD section Section A task :a1, 2014-01-01, 30d Another task :after a1 , 20d section Another Task in sec :2014-01-12 , 12d another task : 24d ``` 渲染：\n1 2 3 4 5 6 7 8 9 gantt title A Gantt Diagram dateFormat YYYY-MM-DD section Section A task :a1, 2014-01-01, 30d Another task :after a1 , 20d section Another Task in sec :2014-01-12 , 12d another task : 24d 17.5 类图 源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 ```mermaid classDiagram Animal \u0026lt;|-- Duck Animal \u0026lt;|-- Fish Animal \u0026lt;|-- Zebra Animal : +int age Animal : +String gender Animal: +isMammal() Animal: +mate() class Duck{ +String beakColor +swim() +quack() } class Fish{ -int sizeInFeet -canEat() } class Zebra{ +bool is_wild +run() } ``` 渲染：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 classDiagram Animal \u0026lt;|-- Duck Animal \u0026lt;|-- Fish Animal \u0026lt;|-- Zebra Animal : +int age Animal : +String gender Animal: +isMammal() Animal: +mate() class Duck{ +String beakColor +swim() +quack() } class Fish{ -int sizeInFeet -canEat() } class Zebra{ +bool is_wild +run() } 18. 标签 (Tag) 标签是 Obsidian 特有的一个功能，标签可以通过点击唤起快速搜索 (搜索包含该标签的所有笔记) 格式：\n# + 标签名 #标签名 关于空格 在一段正文文本的后面添加 Tag， # 的前面 需要有个空格 空格 + # + 标签名 # 与 标签名 之间，不能有空格，否则就变成 一级标题 了 标签名的内部，不允许使用空格，若想区分标签中的词语，可使用以下三种方法： 驼峰式大小写： #BlueTopaz 下划线： #blue_topaz 连字符： #blue-topaz 关于数字 标签内允许使用数字，但不能完全由数字组成 #1984 ❌ #1984Date ⭕ #da_1984_te ⭕ #date-1984 ⭕ 标签的嵌套 在标签名内，使用 / 斜杠 可以实现标签的嵌套\n格式：\n#主标签/子标签1 #主标签/子标签2 #主标签/子标签3 嵌套标签可以像普通标签一样通过点击来唤起搜索，嵌套标签允许你选择搜索的层次。例如：\n搜索 #主标签 ，即可找到包含任意一个子标签的所有笔记 返回的结果会是上述的三个例子 当你在一个主分类下设置了多个子分类，想找到这个主分类包含的所有内容时，该功能会很实用 能被使用的符号 综上所述，标签内能被使用的符号共有三种\n_ 下划线 - 连字符 / 斜杠 如何让 # 不被识别 可以使用前面提到的转义符号 \\ 反斜杠，与上述的 转义标题 类似\n格式：\n\\#这里的内容不会被识别为标签\n效果：\n#这里的内容不会被识别为标签\n19. 避免标识符的滥用 即使在 Markdown 中，也要尽量避免标识符的滥用\n比如我的这篇教程，就存在一定程度的滥用\n其实是因为我这篇是教学性质的，不太一样，有些不能避免 (好吧，我就是在甩锅) 标识符的本质是突出显示，代表重点\n一篇笔记里的某段文本，使用各式各样的的标识符，会造成重点不清晰 有三种标识，慎用！\n词中对单个汉字的标识 卧==虎==藏==龙== 短语中对单个英语单词的标识 get a ==bang== out of 标识符的多层嵌套 我感觉快要==原地起飞==了 原因：\n词义的割裂 视觉的混乱 不利于搜索 卧==虎==藏==龙== 搜 卧虎 \u0026ndash; 搜不到 搜 藏龙 \u0026ndash; 搜不到 周树人\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n绍兴人\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2024-12-30T00:00:00Z","image":"https://ayljzj520.github.io/p/hugo%E5%8D%9A%E5%AE%A2%E8%AF%AD%E6%B3%95%E7%A4%BA%E8%8C%83/Amain_hu5908995170573528190.jpg","permalink":"https://ayljzj520.github.io/p/hugo%E5%8D%9A%E5%AE%A2%E8%AF%AD%E6%B3%95%E7%A4%BA%E8%8C%83/","title":"hugo博客语法示范"},{"content":" “NetWork”\n前言 这篇文章针对本人的需求设计而来，也为了需要自动登录校园网的同学提供一个相关思路。\n本文所处的地理位置为：江西理工大学三江校区（东区）\n网络环境：电信网\n由于电信网的原因，每登录24小时，网络就会自动断开，又要去浏览器页面重新登陆（对于一个把电脑扔在工作室的人来说，这是一件令人头疼的事）\n1、原理 首先打开登录校园网的网页（前提是电脑已经连接了校园网JXUST-WLAN）\n按下 F12 打开浏览器开发者工具（如果没反应那就 fn + F12）\n输入账号密码，登录进入校园网\n找到这一串请求url，就是通过这一串url就能够成功登录校园网，把这一串复制下来\nhttp://10.17.8.18:801/eportal/portal/login?callback=dr1003\u0026amp;login_method=1\u0026amp;user_account=你的校园网账号%%40telecom\u0026amp;user_password=你的校园网密码。\n其中，user_account就是学号；user_password就是密码；login_method是运营商信息。里面信息不需要全部保留也可以登录校园网，保留至user_password的结束位置也能登陆。\n在搜索栏直接粘贴上文所说的url点击回车，若出现下图的情况即联网成功。\n原理可行！\n那我只要每次开机后电脑能自动访问这条url那不就自动登录校园网了吗？\n直接进入实操！！！\n2、实际操作 在桌面新建一个txt文本文件，将文件后缀名修改为.bat格式\n右键选择编辑或用记事本打开，在里面粘贴如下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 @echo off :: 设置控制台为 UTF-8 编码 chcp 65001 :: 启用延迟变量扩展 setlocal EnableDelayedExpansion :: 初始化计数器 set /a counter=0 :loop :: 增加计数器 set /a counter+=1 :: 输出当前是第几次判断 echo 当前为第 !counter! 次判断。 :: 检测是否有网络连接（超时 10 秒） ping -n 1 -w 10000 baidu.com \u0026gt;nul 2\u0026gt;\u0026amp;1 if errorlevel 1 ( echo 无网络连接（ping超时10秒），尝试在浏览器中访问登录页面... :: 指定浏览器路径（假设使用 Chrome）打开指定网址 start \u0026#34;\u0026#34; \u0026#34;http://10.17.8.18:801/eportal/portal/login?callback=dr1003\u0026amp;login_method=1\u0026amp;user_account=你的校园网账号%%40telecom\u0026amp;user_password=你的校园网密码\u0026#34; echo 登录页面已在浏览器中打开。 ) else ( echo 网络连接正常，跳过登录操作... ) :: 倒计时循环输出（每分钟输出一次） for /l %%i in (5,-1,1) do ( set /a minutes=%%i echo 倒计时（结束后会检测网络）：!minutes! 分 timeout /t 60 \u0026gt;nul ) :: 循环检测 goto loop 我对代码做一个简单的解释：（如果不想了解原理可以跳过该解释）\n这段代码主要功能是持续监测网络连接状况，并在网络断开时自动通过浏览器打开校园网登录页面。\n首先，代码设置控制台编码为 UTF-8(将运行在控制台下输出中文内容)，并启用延迟变量扩展以便在循环中动态使用变量。然后，它初始化一个计数器，用于记录执行循环的次数。\n接下来，进入一个无限循环，程序每次都会通过 ping 命令检测是否ping通百度，如果检测到网络连接失败，则输出“无网络连接”并尝试在默认浏览器中访问指定的校园网登录请求。如果网络正常，程序则输出“网络连接正常”，跳过登录操作。\n然后，为了避免频繁检测，代码会在每次检测后进入倒计时状态，每分钟输出倒计时信息，直到检测下次网络连接状态。整个过程会持续进行，直到手动终止脚本。\n注意：start \u0026quot;\u0026quot; \u0026ldquo;http://10.17.8.18:801/eportal/portal/login?callback=dr1003\u0026amp;login_method=1\u0026amp;user_account=你的校园网账号%%40telecom\u0026amp;user_password=你的校园网密码\u0026rdquo;\n这段代码的url需要你自己通过上面的方法去获取。\n接下来最重要的事一定要仔细看！\n接下来最重要的事一定要仔细看！\n接下来最重要的事一定要仔细看！\n重要的事说三遍！！！\n请检查你自己所获取到的url，在校园网账号后面应该会有%40字符，由于复制进脚本后，由脚本通过start命令发起访问会将%40识别为@，从而导致输进浏览器的url缺失这一关键信息\n若不进行修改就会导致下图的访问结果。\n解决方法：在%40这个字符前再加一个%，这样就能确保url的正确读取并访问。\n接下来运行这个.bat文件，就会自动向校园网登录端发送请求，然后登录你的校园网账号，并且每五分钟会ping一次百度的网站。\n若ping不通，则会再次执行登录请求。\n在运行过程中请不要关闭此命令行窗口！！！\n3、进阶操作 为了使开机能自动运行该脚本，需要将该脚本文件加入开机自启动。\n按win+r打开运行窗口，输入下述指令进入到开机启动目录：\n1 shell:startup 将编写好的.bat脚本复制进去，即可做到开机自动运行。\n补充 有的时候电脑开机后没有自动连接到校园网，自然也无法完成登录请求。\n由于只ping一个站点有时会造成误判，从而反复执行。所以增加一次操作，对baidu.com和qq.com均ping一次，\n只有在两次都ping不通的情况下，才会去执行操作，使电脑先连接校园网再执行登录操作。\n对代码循环执行时间调整为10分钟一次\n本校的校园网名称为“JXUST-WLAN”，所以经过修改后的代码应该这么写：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 @echo off :: 设置控制台为 UTF-8 编码 chcp 65001 :: 启用延迟变量扩展 setlocal EnableDelayedExpansion :: 设置无线网络名称（SSID） set SSID=JXUST-WLAN :: 获取脚本所在的路径 set scriptPath=%~dp0 :: 设置 wlan-connect.txt 文件的完整路径 set filePath=%scriptPath%wlan-connect.txt :: 检测 wlan-connect.txt 文件是否存在 if exist \u0026#34;%filePath%\u0026#34; ( :: 文件存在，删除文件后重新创建 del \u0026#34;%filePath%\u0026#34; ) :: 新建 wlan-connect.txt 文件 echo. \u0026gt; \u0026#34;%filePath%\u0026#34; :loop :: 增加计数器 set /a counter+=1 :: 输出当前是第几次判断 echo 当前为第 !counter! 次判断。 :: 检测是否有网络连接（ping baidu.com 或 qq.com，超时 10 秒） ping -n 1 -w 10000 baidu.com \u0026gt;nul 2\u0026gt;\u0026amp;1 if errorlevel 1 ( echo 百度 ping 超时，尝试 ping qq.com... ping -n 1 -w 10000 qq.com \u0026gt;nul 2\u0026gt;\u0026amp;1 if errorlevel 1 ( echo 无网络连接（百度和qq.com都 ping 超时），尝试在浏览器中访问登录页面... :: 获取当前连接的 SSID（检测是否连接JXUST-WLAN） for /f \u0026#34;tokens=2 delims=:\u0026#34; %%i in (\u0026#39;netsh wlan show interfaces ^| findstr /i \u0026#34;SSID\u0026#34;\u0026#39;) do ( set currentSSID=%%i :: 去除前后空格 set currentSSID=!currentSSID: =! ) :: 判断是否已经连接到指定的 WLAN 网络 if /i \u0026#34;%currentSSID%\u0026#34;==\u0026#34;%SSID%\u0026#34; ( echo 已经连接到网络 %SSID%，跳过连接操作。 ) else ( echo 未连接到指定网络 %SSID%，尝试连接... :: 执行连接操作 netsh wlan connect name=%SSID% :: 等待一段时间，确保网络连接 timeout /t 10 \u0026gt;nul echo 连接操作完成。 ) start \u0026#34;\u0026#34; \u0026#34;http://10.17.8.18:801/eportal/portal/login?callback=dr1003\u0026amp;login_method=1\u0026amp;user_account=你的校园网账号%%40telecom\u0026amp;user_password=你的校园网密码\u0026#34; echo 登录页面已在浏览器中打开。 timeout /t 5 \u0026gt;nul :: 写入执行次数和当前时间到 wlan-connect.txt echo 第 !counter! 次网络判断后执行重连，当前执行时间为: !date! !time! \u0026gt;\u0026gt; \u0026#34;%filePath%\u0026#34; ) else ( echo 网络连接正常（qq.com ping 通），跳过登录操作... ) ) else ( echo 网络连接正常（baidu.com ping 通），跳过登录操作... ) :: 倒计时循环输出（每 10 分钟输出一次） for /l %%i in (30,-10,0) do ( set /a minutes=%%i echo 倒计时（结束后会检测网络）：!minutes! 分 timeout /t 600 \u0026gt;nul ) echo 倒计时结束，开始检测网络... :: 循环检测 goto loop 至此，全部完成\n会在脚本所在目录下输出`wlan-connect.txt`的日志文件。\n最后实现的效果如下图所示：\n","date":"2024-12-29T00:00:00Z","image":"https://ayljzj520.github.io/p/%E6%B1%9F%E8%A5%BF%E7%90%86%E5%B7%A5%E5%A4%A7%E5%AD%A6%E6%A0%A1%E5%9B%AD%E7%BD%91%E8%87%AA%E5%8A%A8%E7%99%BB%E5%BD%95/Amain_hu12269823502898717755.jpg","permalink":"https://ayljzj520.github.io/p/%E6%B1%9F%E8%A5%BF%E7%90%86%E5%B7%A5%E5%A4%A7%E5%AD%A6%E6%A0%A1%E5%9B%AD%E7%BD%91%E8%87%AA%E5%8A%A8%E7%99%BB%E5%BD%95/","title":"江西理工大学校园网自动登录"},{"content":" “Work. ”\n前言 git相关指令学习 1. git基础指令 1 git add . 1 git commit -m \u0026#34;测试\u0026#34; 1 git push -u origin main 1 git pull 1 git clone 2. 在使用不同的代理工具时会有不同的端口，需要将git的代理设置相同的端口 在终端执行以下命令，可以清除Git的原代理设置： 1 2 git config --global --unset http.proxy git config --global --unset https.proxy 根据系统设置中的代理端口号（7890）设置Git使用本地代理，在终端输入以下命令，设置本地代理： 1 2 git config --global http.proxy http://127.0.0.1:7890 git config --global https.proxy http://127.0.0.1:7890 设置完成后，可以通过以下命令检验是否设置成功： 1 git config --global -l 3.常见linux指令 列出当前目录中的文件和子目录 1 ls 显示当前工作目录的路径 1 pwd 切换工作目录 1 cd 创建新目录 1 mkdir directory_name 删除空目录 1 rmdir directory_name 删除文件或目录 1 2 rm file_name rm -r directory_name # 递归删除目录及其内容 复制文件或目录 1 2 cp source_file destination cp -r source_directory destination # 递归复制目录及其内容 移动或重命名文件或目录 1 mv old_name new_name 显示当前运行的进程 1 ps aux 终止进程 1 kill process_id 查看和配置网络接口信息 1 2 ifconfig ip addr show 修改文件或目录的权限 1 chmod permissions file_name 用于压缩和解压文件和目录 1 2 tar -czvf archive.tar.gz directory_name # 压缩目录 tar -xzvf archive.tar.gz # 解压文件 以超级用户权限运行命令 1 sudo command_to_run_as_superuser ","date":"2024-12-27T00:00:00Z","image":"https://ayljzj520.github.io/p/git%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/Amain_hu2329034020457868427.jpg","permalink":"https://ayljzj520.github.io/p/git%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/","title":"git相关操作"},{"content":" “Work. ”\n前言 安装前可以浏览这三个教程：\nwsl安装教程\n安装wsl后虚拟机无法启动\n原生ubuntu安装教程\n1、安装系统 步骤1 - 启用适用于 Linux 的 Windows 子系统： 需要先启用“适用于 Linux 的 Windows 子系统”可选功能，然后才能在 Windows 上安装 Linux 分发。 以管理员身份打开 PowerShell 并运行：\n1 dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart 步骤2 - 启用虚拟机功能： 安装 WSL 2 之前，必须启用“虚拟机平台”可选功能。 计算机需要虚拟化功能才能使用此功能。 以管理员身份打开 PowerShell 并运行：\n1 dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart 步骤3 - 下载 Linux 内核更新包： 以管理员身份打开 PowerShell 并运行：\n1 wsl --install 步骤4 - 将 WSL 2 设置为默认版本： 打开 PowerShell，然后在安装新的 Linux 发行版时运行以下命令，将 WSL 2 设置为默认版本：\n1 wsl --set-default-version 2 步骤5 - 安装所选的 Linux 分发版： •\tUbuntu 16.04 LTS\n•\tUbuntu 18.04 LTS\n•\tUbuntu 20.04 LTS\n•\topenSUSE Leap 15.1\n•\tSUSE Linux Enterprise Server 12 SP5\n•\tSUSE Linux Enterprise Server 15 SP1\n•\tKali Linux\n•\tDebian GNU/Linux\n•\tFedora Remix for WSL\n•\tPengwin\n•\tPengwin Enterprise\n•\tAlpine WSL\n2、修改环境 切换镜像 修改源：找到 cd /etc/apt 路径下的 sources.list 文件对其进行修改\n在此路径下打开命令行，输入sudo vim sources.list\n命令行中相关操作命令如下：\n•\tg 光标到头部\n•\td 删除\n•\tshift + g 全部删除\n•\ti 写入\n•\t粘贴 以下 阿里源 或 清华源\n•\tESC 退出写入模式\n•\t:wq 保存退出\n复制镜像源 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 deb http://mirrors.aliyun.com/ubuntu/ xenial main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse ##测试版源 deb http://mirrors.aliyun.com/ubuntu/ xenial-proposed main restricted universe multiverse # 源码 deb-src http://mirrors.aliyun.com/ubuntu/ xenial main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse ##测试版源 deb-src http://mirrors.aliyun.com/ubuntu/ xenial-proposed main restricted universe multiverse # Canonical 合作伙伴和附加 deb http://archive.canonical.com/ubuntu/ xenial partner deb http://extras.ubuntu.com/ubuntu/ xenial main deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse 更新镜像 操作完成后使用如下命令更新镜像：\n•\tsudo apt-get update 更新\n•\tsudo apt-get upgrade 更新\nsudo add-apt-repository ppa:openjdk-r/ppa\n安装jdk：sudo apt-get install openjdk-8-jdk\n拓展篇(在环境Ubuntu/Mint物理机上安装python环境)：\n1 ls /usr/bin/python* 1 update-alternatives --list python 1 sudo update-alternatives --install /usr/bin/python python /usr/bin/python3.6 1 1 sudo update-alternatives --install /usr/bin/python python /usr/bin/python2.7 2 1 sudo update-alternatives --config python 1 sudo apt install python3-pip 3、 纠错 错误1：证明器不存在 检查dist文件夹下有没有这个cprover_priority\n若没有那就把cse 改成这个名字，然后再添加可执行权限\n错误2：判定异常 若验证检查结果异常，需记录判定情况，需要记录的有： 策略：多策略模式下为桌面的strategy文件夹；单策略模式下为strategy.txt文件 判定过程文件夹：桌面output文件夹下与判定例子同名的文件夹。 在代码操作中，指针越界\n错误3：格式转换失败 可能的原因： 1、没有放置公理集Axioms 2、没有使用Eprover融合系统，没有使用到转换的文件 3、由于问题的原因，可能无法转换 4、可能转换成功，但是界面显示错误\n错误4：调试失败（一般少见） 问题： 同样的例子在调试过程中超时导致无法判定 但是在带界面版本能得到不可满足 在别的电脑上调试也能成功 解决方法： 重装ubuntu系统\n","date":"2024-12-26T00:00:00Z","image":"https://ayljzj520.github.io/p/%E8%87%AA%E5%8A%A8%E6%8E%A8%E7%90%86%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/Amain_hu12645121008201569857.jpg","permalink":"https://ayljzj520.github.io/p/%E8%87%AA%E5%8A%A8%E6%8E%A8%E7%90%86%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","title":"自动推理（环境搭建）"},{"content":" “Work. ”\n前言 进行此项内容前，请确保已经完成环境的配置。\n相关网站：TPTP官网\n1、实验前准备 准备条件 拷贝好dist文件夹，确保内部具有正确的文件\nproblems文件夹中存放问题以及Axiom公理集，测试完output中会存放生成相关文件，strategy中存放策略集合，proofStatistics.txt内存放所有问题的证明时间。\n在dist文件夹内打开命令行窗口，使用ls命令，检查文件是否具有可执行权限：\ncse,eprover,tptp4X,以及相关jar包。\n若没有权限，使用如下命令对文件授予权限：chmod +x 文件名\n使用./eprover --verson或./vampire --verson查看对应软件的版本\n使用命令行版本测试时，将cse替换为自己导出的cse\n替换eprover的版本时，要将eprover和mcs_eprover.jar同时替换才正确。\n3.1以上的版本的Eprover会出现异常，则需要进行以下操作（重新打开一个终端，输入下述指令）：\n1 ps -ef|grep eprover 然后使用kill指令将前三个icdc进程杀死\n拓展(输入./vampire \u0026ndash;ignore_missing on \u0026ndash;mode casc -t 300 +一个问题的绝对路径，就能得到下面这样的证明搜索路径和时间，这样子只能测单个的原始时间)\n带界面版本测试命令 在虚拟机内：\n(1)启动Terminal;\n(2)切换⽬录：cd Desktop/dist;\n(3) 执⾏命令：./kzprover.sh，脚本没有可执⾏权限时， sudo chmod +x kzprover.sh;\n(4) 启动时把单组合模式改为多组合模式，其他不需要改.\n命令行版本测试命令 测试CSE和Eprover融合系统命令：\n1 java -jar mcs_epr.jar CSE_E problems 0 1 4 1 300 0 1 10 测试CSE和Vampire融合系统命令：\n1 java -jar mcs_vampire.jar CSE_V problems 0 1 2 1 260 30 1 10 单独测试CSE系统命令：\n1 java -jar mcs_scs.jar CSE problems 0 1 0 1 1 150 其中260 20 为时间参数 如果那两个数值变为300 0，意味着是原始测出来的数据， 前一个数值代表eprover测的时间，后一个数值代表CSE测的时间， 300秒减去前两个数值所剩下的时间也是eprover参与的\n2、代码相关逻辑 基础代码修改项 必改项 2217 Resolution.cpp for(int i=0;iuLitNum;++1i){删除1 使用776行的main函数 替换原始800行的main函数 验证检查 原始代码 修改后，会生成run文件 Prover.cpp\n319 if(1){\nFileOp::delRunFiles();\n} if(0){\nFileOp::delRunFiles();\n} 选改项 main.cpp debug 编译release 216 #define newTriDebug //#define newTriDebug 755 //child = fork();\nif (0 == 0) child = fork();\nif (child == 0) { 生成cse文件 部分演绎框架 CSE1.3_pre 文件 位置 方法名 较优子句 TriAlg.cpp 345 GenerateTriByRecodePath 优化演绎路径 TriAlg.cpp 1832 GenerateTriByRecodePathLROptimalProofSearch 充分使用子句 TriAlg.cpp 2983 GenerateTriByRecodePathLR 单元子句排序规则 SortRule.h 168 候选子句排序 Resolution.cpp 4833 合一算法 Unify.cpp 320 LitMgu 预处理 Resolution.cpp 3183 构建标准矛盾体思想 方法 从左到右构建 从右到左构建 思想 选择了候选子句集的文字，\n在决策文字集上遍历文字判断是否互补 选择了决策文字集上的文字，\n在候选子句集中遍历子句，再遍历文字是否互补 代表算法 充分使用子句，优化演绎路径 较优子句 标准矛盾体：\n决策文字及其下拉文字，但不包含对角线最后一位\n文字变元输出\n1 2 cout\u0026lt;\u0026lt; QLit-\u0026gt;subTerm-\u0026gt;ToString()\u0026lt;\u0026lt;endl;//debug输出当前文字项 cout\u0026lt;\u0026lt;QLit-\u0026gt;subTerm-\u0026gt;ToStringBind()\u0026lt;\u0026lt;endl;//debug输出当前文字项和变元元替换项 3、融合系统E3.1以上版本卡住解决方法 解决方法1：原始方法\n新打开一个命令行窗口输入以下指令：\n1 ps -ef|grep eprover 使用kill指令将前三个eprover的进程杀死。\n解决方法2：自编sh脚本方法\n新建一个名为kill.sh的文件，其内代码编写如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 # 获取脚本文件所在的路径 SCRIPT_DIR=$(dirname \u0026#34;$(readlink -f \u0026#34;$0\u0026#34;)\u0026#34;) # 日志文件路径 LOG_FILE=\u0026#34;$SCRIPT_DIR/kill-log.txt\u0026#34; # 检查并删除已存在的日志文件 if [ -f \u0026#34;$LOG_FILE\u0026#34; ]; then rm \u0026#34;$LOG_FILE\u0026#34; fi # 创建新的日志文件 touch \u0026#34;$LOG_FILE\u0026#34; # 循环执行 echo \u0026#34;实验进程守护中，请勿关闭此窗口\u0026#34; while true; do # 获取 proofStatistics.txt 的路径 PROOF_FILE=\u0026#34;$SCRIPT_DIR/proofStatistics.txt\u0026#34; # 如果 PROOF_FILE 为空或文件不存在，直接跳到 sleep 420 if [ -z \u0026#34;$PROOF_FILE\u0026#34; ] || [ ! -f \u0026#34;$PROOF_FILE\u0026#34; ]; then echo \u0026#34;实验进程守护中，请勿关闭此窗口\u0026#34; sleep 350 continue fi # 获取 proofStatistics.txt 的修改时间（单位：秒） FILE_MOD_TIME=$(stat -c %Y \u0026#34;$PROOF_FILE\u0026#34;) # 获取当前系统时间（单位：秒） CURRENT_TIME=$(date +%s) # 计算时间差（单位：秒） TIME_DIFF=$((CURRENT_TIME - FILE_MOD_TIME)) # 判断时间差是否超过 7 分钟 (420 秒) if [ \u0026#34;$TIME_DIFF\u0026#34; -le 420 ]; then # 如果时间差未超过 7 分钟，结束本轮循环 echo \u0026#34;实验进程守护中，请勿关闭此窗口\u0026#34; else # 如果时间差超过 7 分钟，杀死所有名为 eprover 的进程 PIDS=$(pgrep -f eprover) if [ -n \u0026#34;$PIDS\u0026#34; ]; then # 获取当前系统时间 CURRENT_TIME_READABLE=$(date \u0026#34;+%Y-%m-%d %H:%M:%S\u0026#34;) # 记录杀死进程的 PID 并写入日志文件 for PID in $PIDS; do echo \u0026#34;$CURRENT_TIME_READABLE - 成功杀死进程, PID: $PID\u0026#34; \u0026gt;\u0026gt; \u0026#34;$LOG_FILE\u0026#34; done # 杀死所有名为 eprover 的进程 pkill -f eprover echo \u0026#34;成功杀死进程\u0026#34; fi fi # 等待 7 分钟后再次循环 sleep 420 # 420秒 == 7分钟 done 其原理如下：\n脚本检测dist路径下的proofStatistics.txt文件的修改时间，若超过7分钟，则杀死名为eprover的所有进程。 若proofStatistics.txt文件的修改时间，未超过7分钟则等待7分钟后进入下一轮循环 若未检测到proofStatistics.txt文件，则休眠7分钟。 使用规则：\n将kill.sh文件置于dist文件夹内； 使用chmod +x kill.sh授予权限； 在命令窗口使用./kill.sh启动脚本； 脚本会在dist文件夹内生成kill-log.txt日志文件。 ","date":"2024-12-26T00:00:00Z","image":"https://ayljzj520.github.io/p/%E8%87%AA%E5%8A%A8%E6%8E%A8%E7%90%86%E5%AE%9E%E9%AA%8C%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9/Amain_hu12645121008201569857.jpg","permalink":"https://ayljzj520.github.io/p/%E8%87%AA%E5%8A%A8%E6%8E%A8%E7%90%86%E5%AE%9E%E9%AA%8C%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9/","title":"自动推理（实验相关内容）"},{"content":" “A Happy Game. ”\n相关链接 海岛奇兵下载链接：海岛奇兵国服\n海岛奇兵相关脚本：\n梦想脚本\n梦想梦想模拟雕像脚本(链接失效)\n养号说明：单号配置\nToast：【下载链接】\nGG修改器：【下载链接】\n卡首雕：【下载链接】\n芝麻海岛工具：【下载链接】\n最新版腾讯切号使用教程+qq突破登录上限说明\n海岛奇兵数据网地址发布页\n相关介绍 养号：\n1 ULGOXKK 查序列：\n1 VZNKMZK zhima123\u0026mdash;666\u0026mdash;17306971\nobsidian常用技巧， 中文论坛\n小号QQ：\n龙行天下\n注册手机一加12\n2024年6月\n江西赣州\n卡首雕 序号 正在进行 47,51,52,53,54,55 已卡好 48,49,50, 已卡好 删除 暗月流金 删除 快乐无限 删除 快乐无限 沙滩树教程 想种沙滩树要先种压岸树！\n1压岸树 压岸树首先将基地左上角靠山的位置空出来，别的位置用建筑填上，建筑直接的间隔不要留有大于(包括)2×2的位置（防止长树），确保树往左上角长。\n2砍部分树 当树长的较多的时候，可以将靠近上方的树砍掉，然后用建筑堵住，防止长回去，将树生长的方向挤向岸边。\n3挂脚本 当岸边长满树的时候，或者长较多树的时候，可以尝试开始挂航母脚本，促进沙滩树的生长。\n","date":"2024-12-25T00:00:00Z","image":"https://ayljzj520.github.io/p/%E6%B5%B7%E5%B2%9B%E5%A5%87%E5%85%B5/Amain_hu12494988652238919125.jpg","permalink":"https://ayljzj520.github.io/p/%E6%B5%B7%E5%B2%9B%E5%A5%87%E5%85%B5/","title":"海岛奇兵"}]